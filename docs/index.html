<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">

    <title>Sqimitive.js – The Frontend Primitive | Squizzle.me Toolkit</title>

    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <link href="prism.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet" media="all">
  </head>
  <body>
    <nav>
      <ol>
        <li><a href="#">The Beginning</a></li>

        <li>
          <a href="https://github.com/ProgerXP/Sqimitive">GitHub</a>:
          <a href="https://github.com/ProgerXP/Sqimitive/archive/master.zip">download</a>,
          <a href="https://github.com/ProgerXP/Sqimitive/issues">issues</a>
        </li>

        <li><a href="#vs-backbone">Why not Backbone?</a></li>

        <li>
          <a href="#overview">Overview</a>
          <ol>
            <li><a href="#ov-opt">Options</a> (<code>this._opt</code>)</li>
            <li><a href="#ov-child">Children</a> (<code>this.nest()</code>)</li>
            <li><a href="#ov-evt">Events</a> (<code>this.events</code>)</li>
            <li><a href="#ov-el">Views</a> (<code>this.el</code>)</li>
          </ol>
        </li>

        <li>
          <a href="#tips">Examples, Tips n' Tricks</a>
          <ol>
            <li><a href="#tt-backbonization">Backbonization</a></li>
            <li><a href="#tt-nestmodels">Babysitting Models</a></li>
            <li><a href="#tt-classname">Figuring "class name"</a></li>
            <li><a href="#tt-countdown">Countdown</a></li>
            <li><a href="#tt-activity">Activity Pipeline</a></li>
          </ol>
        </li>

        <li>
          <a href="#api">API Reference</a>
          <input type="checkbox">
          <ol>
            <li class="sort">
              <a href="#corei-_cid">_cid</a>
              <a href="#corei-_events">_events</a>
              <a href="#corei-_autoOff">_autoOff</a>
              <a href="#corei-fire" title="fire (event[, args])">fire</a>
              <a href="#corei-firer" title="firer (event[, prependArgs[, self]])">firer</a>
              <a href="#corei-logEvents" title="logEvents ([enable])">logEvents</a>
              <a href="#corei-on" title="on ({events} | event[, func[, cx]])">on</a>
              <a href="#corei-once" title="once (event, func[, cx])">once</a>
              <a href="#corei-fuse" title="fuse (event, func[, cx])">fuse</a>
              <a href="#corei-off" title="off (key)">off</a>
              <a href="#corei-autoOff" title="autoOff ( [sqim[, events[, cx]]] )">autoOff</a>
              <a href="#sqimitivei-_opt">_opt</a>
              <a href="#sqimitivei-_parent">_parent</a>
              <a href="#sqimitivei-_parentKey">_parentKey</a>
              <a href="#sqimitivei-_children">_children</a>
              <a href="#sqimitivei-_owning">_owning</a>
              <a href="#sqimitivei-_childClass">_childClass</a>
              <a href="#sqimitivei-_childEvents">_childEvents</a>
              <a href="#sqimitivei-_respToOpt">_respToOpt</a>
              <a href="#sqimitivei-el">el</a>
              <a href="#sqimitivei-elEvents">elEvents</a>
              <a href="#sqimitivei-length">length</a>
              <a href="#sqimitivei-constructor" title="new (opt)">constructor</a>
              <a href="#sqimitivei-init" title="init (opt)">init</a>
              <a href="#sqimitivei-postInit" title="postInit (opt)">postInit</a>
              <a href="#sqimitivei-render">render</a>
              <a href="#sqimitivei-attach" title="attach ([parent])">attach</a>
              <a href="#sqimitivei-get" title="get ([opt])">get</a>
              <a href="#sqimitivei-set" title="set (opt, value[, options])">set</a>
              <a href="#sqimitivei-ifSet" title="ifSet (opt, value[, options])">ifSet</a>
              <a href="#sqimitivei-normalize_OPT" title="normalize_OPT (value, options)">normalize_OPT</a>
              <a href="#sqimitivei-change_OPT" title="change_OPT (value, old, options)">change_OPT</a>
              <a href="#sqimitivei-change" title="change (opt, value, old, options)">change</a>
              <a href="#sqimitivei-nest" title="nest ([key,] sqim[, options])">nest</a>
              <a href="#sqimitivei-_defaultKey" title="_defaultKey (sqim)">_defaultKey</a>
              <a href="#sqimitivei-owned">owned</a>
              <a href="#sqimitivei-_forward" title="_forward (prefix, events, sqim)">_forward</a>
              <a href="#sqimitivei-unlist" title="unlist (key/sqim)">unlist</a>
              <a href="#sqimitivei-unnest">unnest</a>
              <a href="#sqimitivei-remove">remove</a>
              <a href="#sqimitivei-unnested" title="unnested (sqim)">unnested</a>
              <a href="#sqimitivei-nested" title="nested ([key/sqim])">nested</a>
              <a href="#sqimitivei-slice" title="slice (start[, length])">slice</a>
              <a href="#sqimitivei-slice" title="at (index)">at</a>
              <a href="#sqimitivei-assignChildren" title="(resp, options)">assignChildren</a>
              <a href="#sqimitivei-assignResp" title="(resp, options)">assignResp</a>
              <a href="#sqimitivei-bubble" title="bubble (event, args, fireSelf)">bubble</a>
              <a href="#sqimitivei-sink" title="sink (event, args, fireSelf)">sink</a>
              <a href="#sqimitivei-$" title="$ (path)">$</a>
            </li>
          </ol>
          <ol>
            <li class="sort">
              <a href="#cores-_mergeProps">_mergeProps</a>
              <a href="#cores-_shareProps">_shareProps</a>
              <a href="#cores-extend" title="extend (protoProps[, staticProps])">extend</a>
              <a href="#cores-events">events</a>
              <a href="#cores-stub">stub</a>
              <a href="#cores-unique">unique</a>
              <a href="#cores-picker" title="picker (prop[, args])">picker</a>
              <a href="#cores-expandFunc" title="expandFunc (func[, obj])">expandFunc</a>
              <a href="#cores-masker" title="masker (func[, mask[, cx[, args]]])">masker</a>
              <a href="#cores-deepClone" title="deepClone (obj)">deepClone</a>
              <a href="#cores-parseEvent" title="parseEvent (str)">parseEvent</a>
              <a href="#cores-fire" title="fire (funcs[, args])">fire</a>
              <a href="#cores-toArray" title="toArray (value)">toArray</a>
              <a href="#cores-is$" title="is$ (obj)">is$</a>
            </li>
          </ol>
          <a href="#sqimitivei-underscore">+ Underscore methods</a>
        </li>
      </ol>
    </nav>

    <script>
    (function () {
      var all = document.querySelectorAll('nav .sort')
      for (var k = 0; k < all.length; k++) {
        var list = all[k]
        var sorted = []

        for (var i = 0; i < list.children.length; i++) {
          var item = [list.children[i].textContent.replace(/^\s+|\s+$/g, ''), list.children[i]]
          for (var j = 0; j < sorted.length && item; j++) {
            if (sorted[j][0] > item[0]) {
              sorted.splice(j, 0, item)
              item = null
            }
          }
          item && sorted.push(item)
        }

        var prev = null
        for (var j = sorted.length - 1; j >= 0; j--) {
          var item = sorted[j]
          if (prev != item[0][0]) {
            prev != null && (sorted[j + 1][1].className += ' fl')
            prev = item[0][0]
          }
          list.insertBefore(item[1], list.firstChild)
        }
      }
    })()
    </script>

    <script src="orphusm.js"></script>

    <article>
      <h1><b>Sqimitive.js</b> – Lightweight library to build concrete applications</h1>

      <p><b>Sqimitive.js</b> is a fat-free implementation of well-known <a href="http://backbonejs.org">Backbone.js</a> JavaScript frontend framework. Sqimitive avoids certain less used (usually project-specific) features while conceptually bringing the rest under one roof.</p>

      <p>In particular, Sqimitive:</p>
      <ul class="rareline">
        <li>Removes somewhat <b>artificial separation</b> for Model, Collection and View classes providing single unified "primitive" (<kbd>Sqimitive</kbd>) class. This way Views can use <a href="#ov-opt">options</a> (attributes with <a href="#sqimitivei-change_OPT">on-change</a> notifications), Underscore.js <a href="#sqimitivei-underscore">filtering</a> and <a href="#ov-child">nesting</a> (just like Collections) and all other features, shared by all, not imposed on any.</li>
        <li>Greatly expands the idea of <a href="#ov-evt">events</a> making <b>inheritance</b> as sensible as it is possible given JavaScript’s idea of OOP.</li>
        <li>Removes <b>server-side communication layer</b> (<kbd>sync</kbd>) while <a href="#sqimitivei-assignChildren">keeping</a> <a href="#sqimitivei-assignResp">routines</a> to smart-update object states. Instead of overriding standard parts as it’s often done with Backbone you implement them yourself just once given your unique project specification.</li>
        <li>Is <b>half the size of Backbone</b> while being loaded with even more comments. <a href="http://underscorejs.org">Underscore.js</a> is still required to operate while <a href="http://jquery.com">jQuery</a>/<a href="http://zeptojs.com">Zepto</a> are optional..</li>
        <li>Still lets you work <b>the way you used</b> with Backbone – if you wish. You can create base Model, Collection and View, use traditional <kbd>__super__</kbd>-style inheritance, write your specific API sync routines, use Underscore.js <a href="#sqimitivei-underscore">filtering</a> and jQuery/Zepto <a href="#sqimitivei-el">this.el</a> and so on.</li>
      </ul>

      <p>While different, Sqimitive will appear very familiar to current Backbone users so just give it a try – <a href="demo/">this classic To-Do application</a> is a good place to start.</p>

      <div class="dl">
        <p><b>Download for</b> <a href="http://squizzle.me/js/sqimitive/sqimitive.js">development</a> / <a href="http://squizzle.me/js/sqimitive/sqimitive.min.js">production</a> (minified, 12K)</p>
        <p>Check out <a href="demo/">sample To-Do App</a> and its <a href="http://todomvc.com"><s>ToDo-MVC version</s></a> (under construction)</p>
        <p><a href="https://github.com/ProgerXP/Sqimitive/issues">Report issues</a>. <a href="https://github.com/ProgerXP/Sqimitive">Fork on GitHub</a></p>
      </div>

      <p><b>See a typo?</b> Select the fragment and press <b>Ctrl+Enter</b>. Help us keep this memo free of vexatious mistakes! (Powered by <a href="http://orphus.ru" id="orphus" target="_blank" rel="nofollow">Orphus.ru</a>.)</p>

      <p><b>This page is printer-friendly!</b> Make yourself a PDF and take along.</p>

      <aside id="book">
        <img id="blogo" src="lotus.png" alt="The Lotus">
        <p><b>Sqimitive:</b> <i>The Zen Book</i></p>
        <p id="bmotto">
          Achieving nirvana through<br>mindful web development <small>Read on…</small>
        </p>
        <p id="bcc">
          <a href="https://creativecommons.org/licenses/by/4.0/" rel="nofollow" target="_blank">
            <img src="data:image/gif;base64,R0lGODlhWAAfAKIHAM3QzENDQ7u/uoKEgv///6uxqgAAAAAAACH5BAEAAAcALAAAAABYAB8AAAP/eLbc/jDKSWtURugtgP/gx21FaZ5oqq5sWzJjF85gLLh4rqsLFw6BR2AQGu1UwMbw6OppQIMKUcRhlpKGIXZpTTlBQcZQg10EZAAj0wwguAmA8KCL+nrChsF7TyiIZWo7QQFvC29+AXQnPR9hAW18fI5UJDpRj4UGe0Fzin4ZHlFZkaQEcpQ3OkGQpQBZnp8fDKyle7MeVTqjb46bBrALoQt6tZGfU4FNxG4Ne1HABneGbgIB1sTV15mPuJU4ebYMzr+ewa67Ag6J6m5hqLqEvGa+0B7D7cHpBYMAfgVusbppUBUt3B5XicpFOyeAGbhMy96kW5jGm4tLBuV1UmSux4fDiPf4THxHMB6BaQQuwQoYMgycPINeEgtYceAONgflrOy465MYn/NSmquZSpCZIY42KpSmiZq1IQCfLmMjsOiOMlmU1gMgKmIxgMOqWl1Jduisr+Eo5iLL9pOMTya/niI6tq3CPEwx1YpDVZSFv4ADM5iCx+sbv9z8Cl7MOAJhJQPI4MkirHEzhycNWaYwBajjyps1a9KcObSEKVwnm0GtOHQm0aYnJKIRYl9scbBL35YwZoYArLdfj95NvLjxBRiOK7d8IAEAOw==" alt="CC BY Attribution">
          </a>
          feel free to copy<br>
          but please link<br>back to this page
        </p>
      </aside>

      <img id="btri" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAAAPCAYAAAChmULXAAACPklEQVR4Xs2WzWsTQRiHM8kaMVEQImLipeQTqfiBiNhjUupBIliQKkEP4p9maGhLtYK2iNieil5FCkkOxg3NrTGU0DQLyfos7KHUj5fMWNmBh3fyLvwWHt7Jjmq329PD4fDBeDyuhEKhLJyGiZZS6pff0nJdV+z5OcbZfq4p33n3G8uylhWBZ7xOt9uN9nq9W6PR6Bm9WVqXRUlyX0feSWTrSjxA1GY4HK7FYrH3yWRy32t60qLHA2zbTjB9ZcKf0rgK5wWBwjMtUfq55u/8iqzlSCSymk6nG8ejPGmRvwU0m82bvrwSTIMkKTAgapLne4h6B4vxeHwrlUo5fxwGgsNUcbVarZjjOPcR+ITGHbgkTNnJH0/zaXNhm+waR3Atm83uiiJ8aZOOh2L6riBvgX2ROqMEQwGcOBtee7Ly+fynSfOUHyihftfjyxsdDAZF9vPklHA3FWBZh7AJVaZqPZfL/TjqVVeatjz/v2+KrDLbOeoc1RKOlcaVQ+tY7pCzQl1iqnb8nizLXJosz0d1Oh2r3+/fZX+P7HlqAf736sEGvORe9TGTyRwKsrSk6aKEL+9FLs0ltmV4KF6czfkMNSbrFVNlew1tWebSzCU2Go3r/qW5Ajf+oahdWEPUYiKR2AZXkBQ0aTL1ev0sZQYewQKc04hxYAuq8LZQKOwJAQGSZi4wTSnCc7gNluQcVmAJUV+E+IBLM5d3inINKvAYkkcC9mEDqvABWQcaAgIuzVzgBcosvIB1WEXUt1CA1k/8kRPijbO8RgAAAABJRU5ErkJggg">

      <fieldset id="history">
        <legend>Forever Grateful</legend>
        Sqimitive was created by <a href="http://proger.me">Proger</a> while working at <a href="http://www.belstonecapital.com">Belstone Capital</a>. Fellow freelancers: this company is your dream of unrestricted creativity and freedom. <em>Belstone</em> kindly allowed me to share this internal code with everyone. Deep thank you, guys.
      </fieldset>

      <h2 id="vs-backbone">Showdown: Why not Backbone?</h2>

      <p>There are already dozens of client-side frameworks. Why create yet another one? Simply enough – Sqimitive strives to fill in some gaps that Backbone implementation and others have left wide open.</p>

      <h3>OOP with a human face</h3>

      <p>In Backbone and other JS frameworks inheritance (overriding of parent properties and methods) is painful.</p>

      <p><b>With properties</b>, if it’s a complex object that you would rather extend (append to) rather than replace entirely – as it is the case with Model attributes, defaults, View events (DOM bindings) and others – you have to add them in the constructor because if you define such a property in the child class you will <b>entirely overwrite the inherited value</b>. Moreover, if at some point base class that did not have that property decided to define it – all its subclasses overwrite it without notice... Unless you remember to update them, which we humans often do not.</p>

      <p><b>With methods</b>, you have to hardcode base class reference – that’s not to mention the entire construct which is already ugly: <kbd>My.Class.__super__.baseMethod.apply(this, arguments)</kbd>. So if you later rename base class or move this subclass under another parent, or rename the method, or just make a typo – the entire inheritance chain for this method is broken. You may or may not get an error, too.</p>

      <p>This is the price for trying to push classic OOP into JavaScript prototype model.</p>

      <p>Sqimitive solves both problems by using <a href="#cores-_mergeProps">_mergeProps</a> for listing which properties should be merged together on extension. For methods, there is a fantastic <a href="#ov-evt">event-driven inheritance</a> that makes JavaScript OO coding a breeze. Any method can be turned into an event without altering the base class.</p>

      <p>At the same time, the <kbd>__super__</kbd> way of doing this is still available if you are feeling a bit masochistic.</p>

      <p>Below is just one simple example. Look for more details at the mentioned sections.</p>

      <pre class="language-javascript">
var MyBaseClass = Sqimitive.Sqimitive.extend(
  complexProp: {
    base: 123,
  },

  init: function () {
    alert('I init()!')
  },
))

// _mergeProps is a static property.
MyBaseClass._mergeProps.push('complexProp')

var MySubclass = MyBaseClass.extend({
  complexProp: {
    sub: 'foo',
  },

  events: {
    init: function () {
      alert('Now I init() too!')
    },
  },
})

var obj = new MySubclass
  // 1. alert: I init()!
  // 2. alert: Now I init() too!
alert(obj.complexrop.base)
  // alert: 123
alert(obj.complexrop.sub)
  // alert: foo
</pre>

      <h3>Built-in nesting</h3>

      <p>Backbone offers no nested views out of the box. There are plugis such as <a href="https://github.com/marionettejs/backbone.babysitter">Babysitter</a> (from Marionette.js) but they don't provide a complete solution.</p>

      <p>In Sqimitive, nested views are native. When used, they are automatically managed: elements and <a href="#corei-autoOff">event listeners</a> removed when coresponding view is removed, DOM events rebound and root element <a href="#sqimitivei-attach">reinserted</a> when root element is moved (e.g. on <a href="#sqimitivei-render">render()</a>), it is possible to <a href="#sqimitivei-underscore">filter</a> nested views using Underscore methods (just like Collection contents in Backbone), notifications about newly nested/unnested/changed views and so on.</p>

      <p>No more need for <kbd>delegateEvents()</kbd>, <kbd>off(null, null, this)</kbd> or <kbd>return this</kbd> (when overriding <kbd>render()</kbd>).</p>

      <p>See more details and examples in the <a href="#ov-el">Views overview</a> section.</p>

      <h3>Change-driven behaviour</h3>

      <p>In Backbone and other frameworks, you have to track changes to your data and view states. Backbone eases this task by providing standard events like <kbd>change:attr</kbd> event for Models. However, this approach must be explored even further to take its full advantage.</p>

      <p>In Sqimitive, you get a special object property – <b>_opt</b> ("options") – that is a pool of trackable states, similar to Backbone’s Model attributes. Items in this pool are read with <a href="#sqimitivei-get">get()</a> and written with <a href="#sqimitivei-set">set()</a>. When a new and different value is written a bunch of events occur. Within these events you can cancel or normalize the change (<a href="#sqimitivei-normalize_OPT">normalize_attr()</a>) or perform an action (<a href="#sqimitivei-change_OPT">change_attr()</a> and <a href="#sqimitivei-change">change()</a>). For parent sqimitives, they can optionally be forwarded (<a href="#sqimitivei-_childEvents">_childEvents</a>.</p>

      <p>This can be used to create event observation spots too. Suppose that you have an object that’s loading some data from the server. Since it’s asynchronous you don't know when (or if) it will finish. Usually you would either create a callback property and call it or use a custom event (jQuery or Backbone) and call it once loading is done. In Sqimitive, you simply introduce some <kbd>_opt.loading</kbd>, set it to <kbd>false</kbd> and then once done – set it to <kbd>true</kbd>. Observers listen to <kbd>change_loading</kbd> event having the <a href="#corei-on">full</a> <a href="#corei-once">set</a> <a href="#corei-fuse">of</a> <a href="#corei-off">event</a> <a href="#corei-autoOff">handling</a> <a href="#corei-logEvents">routines</a> at their disposal instead of introducing <kbd>isLoading()</kbd>, <kbd>abortLoading()</kbd>, <kbd>onLoading()</kbd>, etc.</p>

      <p>Now this works the other way too: an external object can <kbd>set('loading', true)</kbd> to force refreshing of the data. Better still – the loading object itself can set this option to trigger its own loading routine – naturally, avoiding code duplication.</p>

      <p>Moreover, since options are not accessed directly you can always listen for their access with <kbd>get</kbd> or add custom behaviour with <kbd>set</kbd>. This leads to more stable code base.</p>

      <p>Given this mechanism you can significantly lower your <kbd>render()</kbd> and custom event rates while being much more aware of what has triggered the change so you can perform a lightweight update. And since there’s no distinct separation between Models and Views this universally works for any kind of object you might have.</p>

      <pre class="language-javascript">
var MyView = Sqimitive.Sqimitive.extend(
  _opt: {
    loading: false,
    people: [],   // array of names.
  },

  // We will keep jqXHR object here to be able to abort the request.
  _loadingXHR: null,

  events: {
    init: function () {
      // Wait 300 msec and then start fetching server data.
      _.delay(_.bind(this.set, this, 'loading', true), 300)
    },

    // Loading was either cancelled or started.
    change_loading: function (value) {
      // Update class name of our DOM element.
      this.el.toggleClass('loading', value)
      // Abort old request, if any.
      this._loadingXHR && this._loadingXHR.abort()

      if (value) {
        // Fetch the data, pass to _load().
        this._loadingXHR = $.getJSON('some/long/process', _.bind(this._load, this))
      }
    },

    // _opt.people changed - update names.
    change_people: '_updatePeople',

    render: function () {
      // Retrieve all _opt to pass them to the template.
      var vars = this.get()
      // Overwrite with new HTML.
      this.el.html(_.template($('#MyViewTemplate').text(), vars))
      // Add peoples' names.
      this._updatePeople()
    },
  },

  _updatePeople: function () {
    var el = this.$('.people').empty()

    _.each(this.get('people'), function (name) {
      $('&lt;em&gt;').text(name).appendTo(el)
    })
  },

  _load: function (resp) {
    // Do something with resp, then finally:
    this.set('loading', false)
  },
})
</pre>

      <h3>Events do occur on events. No cheating</h3>

      <p>If you have used Backbone’s <kbd>add</kbd>, <kbd>remove</kbd> and <kbd>change</kbd> events then you probably know that they do not occur <em>always</em>. For example, if you <kbd>reset()</kbd> a Collection it won't fire <kbd>add</kbd> for new Models, <kbd>remove</kbd> for gone or <kbd>change</kbd> for existing Models that were updated.</p>

      <p>This smells like an optimization – after all, firing hundreds of events when resetting a huge Collection might be slow. However, this case is very rare and yet the availability of <kbd>reset()</kbd> makes it not trivial to track the updates because often you will end up with your own routine bound to <kbd>reset</kbd> as an event that will figure the difference between old Collection contents and new one.</p>

      <p>This also happens with attribute normalization on Models which for some reason doesn't occur when assigning an API response.</p>

      <p>Sqimitive fires events when things change, period. In case you do have a performance-heavy object you can always implement your own more silent update routines. However, 90% of the time you will rely on <a href="#sqimitivei-nest">nest</a>, <a href="#sqimitivei-unnested">unnested</a>, <a href="#sqimitivei-change_OPT">change</a> and others to keep you notified.</p>

      <h3>Cloned instance properties</h3>

      <p>In JavaScript, when you create a prototype with non-scalar values (like objects or arrays) what you actually create are <b>shared instance properties</b>. If at runtime you modify (but not reassign) such a property this operation will affect all objects where that property is defined, unless its value was overwritten with a new object.</p>

      <p>Backbone inherits this behaviour which most of the time leads to very confusing results (from the human’s perspective). Consider this short snippet (<a href="http://jsfiddle.net/Proger/vwqk67h8/">JSFiddle</a>):</p>

      <pre class="language-javascript">
var MyView = Backbone.View.extend({foo: []})
var first = new MyView
var second = new MyView
first.foo.push(123)
alert(second.foo[0])
  // alert: 123
</pre>

      <p>The only way around is to assign such properties in the constructor, which you should first override using the crazy <kbd>My.Class.__super__.baseMethod.apply(this, arguments)</kbd> construct. This gives your code -50 points in the ability to save kittens on this planet.</p>

      <p>Sqimitive eliminates this problem by automatically <a href="#cores-deepClone">deep cloning</a> all complex values upon new object instantination. Of course, sometimes this is not desired – for this you can always assign them in the constructor just like before or list in <a href="#cores-_shareProps">_shareProps</a> to prevent auto cloning.</p>

      <h2 id="overview">Anatomy Of A Sqimitive</h2>

      <p>Anything in Sqimitive is, well, a <em>sqimitive</em> – a combination of "Squizzle" and "primitive", first being what we call "The Squizzle Way" – eliminating superfluous concepts to produce lean and reliable code. See <a href="http://squizzle.me">squizzle.me</a> for other goodness.</p>

      <p>Each <em>sqimitive</em> has three fundamental features that sprout out all of its many use cases: <b><a href="#ov-opt">options</a></b>, <b><a href="#ov-child">children</a></b> and <b><a href="#ov-evt">events</a></b>. Below is a quick high-level overview to demonstrate the main idea; remember to proceed to the <a href="#api">detailed API docs</a> if you want to get all of Sqimitive (and there’s as much to learn as there’s text, really).</p>

      <h3 id="ov-opt">Options</h3>

      <p><b>Options</b> are <b>attributes</b> in Backbone’s terms – set of key/value pairs which trigger events on change or access, can be normalized and can be virtual (i.e. you can write your accessor that won't correspond to a "physical", listed option). They are solely accessed via <kbd>set()</kbd> and <kbd>get()</kbd> methods to create a sort-of public object interface.</p>

      <p>Sample code below defines a class with two options – <kbd>isCompleted</kbd> (boolean) and <kbd>caption</kbd> (string). When one of them is changed associated DOM node is updated.</p>

      <pre class="language-javascript">
var MyToDoItem = Sqimitive.Sqimitive.extend({
  _opt: {
    isCompleted: true,
    caption: 'Do me at home!',
  },

  events: {
    // When task becomes complete or incomplete its DOM element gets that
    // class added or removed on the fly.
    change_isCompleted: function (newValue) {
      this.el.toggleClass('done', newValue)
    },

    change_caption: 'render',
  },

  // HTML template for this node's contents as used below.
  _tpl: '&lt;h3&gt;&lt;%- caption %&gt;&lt;/h3&gt;',

  normalize_isCompleted: function (value) {
    // Turn whatever is given as a new value for isCompleted into a boolean.
    // If the result is identical to the current value – change is not fired.
    return !!value
  },

  // Trim whitespace around the caption.
  normalize_caption: _.trim,

  render: function () {
    // Retrieve map of all options/values and pass to the template.
    var vars = this.get()   // = {isCompleted: false, caption: 'foo'}
    this.el.html(_.template(this._tpl, vars))
  },
})
</pre>

      <h3 id="ov-child">Children</h3>

      <p><b>Children</b> are zero or more <em>sqimitives</em> nested into one parent <em>sqimitive</em>. Their events may be forwarded to parent – but only while they are still part of that parent; upon removal they are automatically unbound. When a children is added or removed its parent, if any, gets notified. Also, all standard <b>Underscore.js</b> methods are available to filter or transform them into a native array or object.</p>

      <p>Parent <em>sqimitives</em> can be of two types: <b>owning</b> (by default) and <b>non-owning</b>. First represent a typical tree where each child has exactly one parent and you can traverse the tree in either direction starting from any node. If you nest one children into another parent it’s automatically removed from the former owner. Second type is more of a list where you can only traverse from the outside because a child doesn't know in what other <em>sqimitives</em> it might be listed in, if at all. No automatic removal is done either.</p>

      <p>Sample code below defines a to-do list that is meant for storing <kbd>MyToDoItem</kbd>’s. Note that in Backbone you would have at least two classes: one Collection for storing the list of to-do items and one View for displaying that collection. Or, to be 100% correct, you would create four classes: Model holding single to-do item data, View to display it, Collection to hold to-do items and another View to hold the Collection to hold the Models – and you still have to link each Model to its View and keep track of their events and DOM elements.</p>

      <p>In Sqimitive you can still do that but let’s be honest – such pure concepts are good for academics and very large projects but most of the time you would rather have something slightly more dirty but more practical. Sqimitive gives you this choice since everything is ultimately a primitive and can be purified to the point you need.</p>

      <p>This kind of nesting doesn't necessary reflect the DOM – children can have their elements under their parent’s <a href="#sqimitivei-el">el</a> or elsewhere, or not have DOM elements at all.</p>

      <pre class="language-javascript">
var MyToDoList = Sqimitive.Sqimitive.extend({
  // Add extra protection against accidental foreign class being added as a child.
  _childClass: MyToDoItem,
  // Leading dash means "listen before" - see next section about events.
  _childEvents: ['-change', 'change'],

  events: {
    // To avoid collisions between children-generated and self events
    // those forwarded from children get prepended with a period. If you
    // have another parent that is forwarding its child's children events
    // then another period appears - e.g. '..change'. Think of this as of
    // regular '../../path' notation where each period means "one level above".
    '.-change': function (sqim, optName, newValue, currentValue) {
      // Outputs something like "To-do item's caption ... from foo to bar".
      console.log('To-do item\'s ' + optName +' is about to be changed' +
                  ' from ' + currentValue + ' to ' + newValue)
    },

    '.change': function (sqim, optName, newValue, currentValue) {
      console.log(optName + ' has changed to ' + newValue)
    },
  },

  postInit: function () {
    var itemOptions = {isCompleted: false, caption: 'Dummy item'}
    var sqim = this.nest(new MyToDoItem(itemOptions))
    sqim.set('caption', 'fire them!')
    // Because of forwarded events two new messages have appeared in the console.

    // Can also assign an explicit name (if omitted _cid is used).
    this.nest('childName', new this._childClass)
    // Can retrieve the object like this:
    var sqim = this.nested('childName')
    sqim.unnest()
  },

  // Use Underscore to retireve only children with isCompleted being false.
  getIncomplete: function () {
    // picker() gets inherited from Sqimitive.Core and is simply a
    // function calling a method on the given object with given parameters.
    // In other words, equivalent to: function (o) { return o.get('isCompleted') }
    return this.reject(MyToDoList.picker('get', 'isCompleted'))
  },
})
</pre>

      <h3 id="ov-evt">Events</h3>

      <p><b>Events</b> are Squimitive’s Swiss Army Knife to deal with everything from inheritance (OOP style) and prototyping (JavaScript-native style) to dynamic property morphing and dispatching notifications in an Observer-like fashion. When defined upon class declaration handlers are "fused" into the class (hence introducing no performance overhead at all), otherwise they work as regular event listeners that can be removed on runtime (this happens automatically once a nested <em>sqimitive</em> is unnested, for instance).</p>

      <p>When you try to listen to an event and there is a method of the same name, Sqimitive turns that method into an event slot and the method itself becomes its first listener. This way every method is potentially an event which you can manipulate on runtime as well as upon declaration. This way you can use "normal" OOP as found in languages like C and PHP while still utilizing the power of dynamic object manipulation as it’s meant with JavaScript.</p>

      <p>Likewise, if there is no method when you define an event – Sqimitive creates it so that calling it actually triggers the event. This way you can always invoke a method without knowing if it’s a real function or an event trampoline.</p>

      <p>Sample code below shows side-by-side how traditional and Sqimitive inheritance correlate with each other.</p>

      <pre class="language-javascript">
var MyBase = Sqimitive.Sqimitive.extend({
  effect: function (arg) {
    console.log('MyBase.effect(' + arg + ')')
    return this
  },
})

// Traditional JS-OOP inheritance.
var JsOopSubclassing = Sqimitive.Sqimitive.extend({
  // This way you would override former method with yours, entirely.
  effect: function (arg) {
    return 'foo'
  },

  // ...optionally calling the inherited implementation.
  effect: function (arg) {
    console.log('pre-actions')
    // We have to hardcode current class name and the whole call is quite long.
    var result = JsOopSubclassing.__super__.effect.apply(this, arguments)
    console.log('post-actions')
    return result
  },
})

// Event-oriented Sqimitive inheritance.
var SqimitiveSubclassing = Sqimitive.Sqimitive.extend({
  events: {
    // This is how you override the entire method in Sqimitive.
    '=effect': function (sup, arg) {
      return 'foo'
    },

    // ...and this is how you call the inherited implementation.
    '=effect': function (sup, arg) {
      console.log('pre-actions')
      // No hardcoded class reference, concise calling format.
      var result = sup(this, arguments)
      console.log('post-actions')
      return result
    },

    // However, full override is rarely needed - most often you need just
    // to do something after the original method and keep its return value.
    // This one is identical to the above but without 'pre-actions'.
    effect: function (arg) {
      console.log('post-actions')
    },

    // Sometimes we need to do just 'pre-actions' - this is how.
    '-effect': function (arg) {
      console.log('pre-actions')
    },

    // Yet at other times we need to call the original code and perhaps
    // change or read its return value.
    '+effect': function (result, arg) {
      console.log('post-actions')

      if (result === this) {
        // Return something other than the original code produced.
        return new That(arg)
      }

      // Returning undefined or not returning at all retains initial result.
      // These are identical:
      //return undefined
      //return
    },
  },
})
</pre>

      <p>Code below demonstrates the usage of dynamic event binding and method overriding.</p>

      <pre class="language-javascript">
var DynamicEvents = Sqimitive.Sqimitive.extend({
  events: {
    slotA: function () {
      console.log('slotA')
      return 'slotA'
    },
  },

  slotB: function () {
    return 'slotB'
  },

  // Just a property that isn't a function.
  notASlot: 123,

  listeners: function () {
    // When slotA is fired, it outputs "slotA" and "post-effect" to the
    // console and returns 'slotA'. Exactly the same would be with slotB
    // even though it was't explicitly declared as an event - it becomes
    // one as soon as a first handler is attached.
    this.on('slotA', function () {
      console.log('post-effect')
    })

    // Nobody said we can't create events out of thin air without defining
    // them anywhere first. Note that since it's an event handler and not
    // class method it cannot return any value (it is ignored). This way no
    // disruption is caused if the class suddenly acquires native method
    // of the same name (this handler will be called after it).
    this.on('slotC', function () {
      console.log('post-effect')
      return 'ignored'
    })

    this.slotC()
    this.fire('slotC')  // equivalent.

    // Of course, events can have prefixes seen in the previous sample.
    this.on('+slotC', function (result) {
      console.log('post-effect')
      return 'new result'
    },

    this.on('-slotC', function () {
      console.log('pre-effect')
      return 'ignored'
    })

    // You can do a full override as well - and the beauty is that later
    // you can off() it and former (sup) method will be put back in place.
    this.on('=slotC', function (sup) {
      console.log('pre-effect')
      var result = sup(this, arguments)
      console.log('post-effect')
      return result
    })

    // However, if you try to turn a non-method into an event nothing
    // will break - you will add event listener all right but doing
    // notASlot() won't fire the event - only access that property.
    this.on('notASlot', function () {
      alert('Boo!')
    })

    alert(this.notASlot)    // alerts 123.
    this.fire('notASlot')   // alerts Boo!
  },

  dynamic: function () {
    var handler = function () { };
    var context = new SomeObject;

    // Each event handler unless it's "fused" on class declaration time gets
    // a unique ID that can be used to very quickly unbind it later.
    // Contrary to common approach, Sqimitive offers no event namespaces
    // (such as my.handler) used to unbind group of events - by-context lookup
    // covers most cases and is available 9see below).
    var id = this.on('event', handler)
    this.off(id)

    // You are free to use dots and colons in event names for your needs.
    this.on('com.myapi.proc:group', handler)

    // Slower but removes all bindings to the given context object among all
    // events of this object in one go.
    this.on('withContext', handler, context)
    this.off(context)

    // You can also clear all listeners to a particular event.
    this.on('wipeEvent', handler)
    this.off('wipeEvent')
  },
})
</pre>

      <h3 id="ov-el">Opening The Views</h3>

      <p>Options, children and events are 90% of what a <em>sqimitive</em> is. However, they all are mostly about the logic and data; to make the user happy we should interact with him and present information in a good way. This is when Views, in MVC and Backbone terminology, come into play.</p>

      <p>By default, each <em>sqimitive</em> possesses a <b>DOM element</b> – that familiar <kbd>this.el</kbd> – which is any jQuery/Zepto/other DOM-like object. This can be disabled for pure-data classes (like Models or Collections) but if it’s not, such a node is automatically created upon the <em>sqimitive</em> construction and assigned to its <kbd>el</kbd>. It can utilize automatic binding of DOM events via <kbd>elEvents</kbd> property, as well as convenient methods like <kbd>this.$('sel.ector')</kbd>, <kbd>bubble('eventForAllParents')</kbd> and <kbd>sink('eventForChildren')</kbd>.</p>

      <p>Sample code below creates a simple login form. It stores data in its own options but, as you must know by now, Sqimitive allows you to separate it into another Model-like object if you need more abstraction in your application.</p>

      <pre class="language-javascript">
var MyFormView = Sqimitive.Sqimitive.extend({
  // If omitted will create just a plain &lt;div&gt;.
  el: {tag: 'form', action: '#', className: 'login-form'},

  _opt: {
    login: '',
    password: '',
    remember: false,
  },

  elEvents: {
    submit: function () {
      var data = this.el.serializeArray()
      $.each(data, _.bind(this.set, this))

      $.ajax({
        url: 'login',
        type: 'POST',
        data: data,
        context: this,
        success: this.loggedIn,
        error: function () {
          this.addClass('error')
        },
      })

      return false
    },

    'change [name=remember]': function (e) {
      this.set('remember', e.target.checked)
    },
  },

  render: function () {
    this.el.empty()
      .append('&lt;input name=login autofocus&gt;')
      .append('&lt;input name=password type=password&gt;')
      .append('&lt;input name=remember type=checkbox&gt;')
      .append('&lt;button type=submit&gt;Log In&lt;/button&gt;')

    this.update()
    return this
  },

  update: function () {
    this.$('[name=login]').val(this.get('login'))
    this.$('[name=password]').val(this.get('password'))
    this.$('[name=remember]')[0].checked = this.get('remember')
  },

  // stub() is just a function that returns undefined (nothing).
  // When it's used in place of a method and if that method becomes
  // an event (and gets a listener) then there's a small optimization -
  // Sqimitive will remove the old method entirely not putting it
  // as a listener for that event.
  // Alternatively, you could just leave this undefined and always use
  // fire('loggedIn') but it's more tricky and less obvious if you ever
  // get a loggedIn() method that for any reason does something else.
  loggedIn: Sqimitive.Sqimitive.stub,
})
</pre>

      <p>Given the above class we can use it as follows:</p>

      <pre class="language-javascript">
// A typical use case - just create new form object along with a DOM element:
var sqim = new MyFormView({login: 'default@login'})

// Or if we have a ready-made container element - use it:
var sqim = new MyFormView({login: 'default@login', el: '#loginForm'})

// Then we can listen to new sqimitive's events as:
sqim.on('loggedIn', function () { alert('Hello, ' + this.get('login')) })

// ...or morph it dynamically - just like good old JavaScript but better:
sqim.on('=render', function (sup) {
  if (location.protocol != 'https:') {
    this.el.text('Your connection is not secure!')
  } else {
    sup(this, arguments)
  }
})

// This is not Sqimitive-way as it is long-winded and will override whatever is
// already defined as render() including all events (if 'render' is an event slot)
// and hardcodes class name and return value but if you don't mind - go ahead.
sqim.render = function () {
  if (location.protocol != 'https:') {
    this.el.text('Your connection is not secure!')
    return this
  } else {
    return MyFormView.render.apply(this, arguments)
  }
}
</pre>

      <h2 id="tips">Examples, Tips &amp; Tricks</h2>

      <h3 id="tt-backbonization">Backbonization</h3>

      <p>The following tricks can be used to make Sqimitive appear more like Backbone API. It will not make it 100% identical, don't use it in production as it is – it's just to give you a good direction.</p>

      <dl>
        <dt>General</dt>
        <dd>
          <p>In Backbone, <a href="#corei-_cid">_cid</a> is named <kbd>cid</kbd>, <a href="sqimitivei-el">el</a> is <kbd>$el</kbd> with <kbd>el</kbd> counterpart (native DOM node), <a href="#corei-fire">fire()</a> is named <kbd>trigger()</kbd>, <kbd>listenTo()</kbd> and <kbd>stopListening()</kbd> are <a href="#corei-autoOff">autoOff()</a>  flavours, <kbd>toJSON()</kbd> is basically <a href="#sqimitivei-get">get()</a>, <kbd>attributes</kbd> is the same as <a href="#sqimitivei-_opt">_opt</a>, <kbd>defaults</kbd> are declaration-time <kbd>_opt</kbd>.</p>

          <pre class="language-javascript">
extend({
  cid: null,    // alias to _cid; do not write to.

  events: {
    '-init': function () {
      this.cid = this._cid
    },

    init: function () {
      this._childClass = this._childClass || this.model
    },
  },

  trigger: function (event, arg_1) {
    return this.fire(event, _.rest(arguments))
  },

  listenTo: function (sqim, event, func) {
    this.autoOff(sqim, _.object([[event, func]]))
    return this
  },

  stopListening: function (sqim, event, func) {
    if (!arguments.length) {
      return this.autoOff()
    } else if (func || (sqim && event)) {
      throw 'Unsupported stopListening() call.'
    } else {
      return this.off(event || sqim)
    }
  },
})
</pre>
        </dd>

        <dt>Collection</dt>
        <dd>
          <p>Collections have <kbd>model</kbd> (class reference) which simply specifies <a href="#sqimitivei-_childClass">_childClass</a>, <kbd>reset()</kbd> is alike to <a href="#sqimitivei-assignChildren">assignChildren</a> (Collection’s <kbd>set()</kbd> is entirely different though), <kbd>push()</kbd>, <kbd>pop()</kbd>, <kbd>shift()</kbd>, <kbd>unshift()</kbd> are shortcuts for <a href="#sqimitivei-nest">nest()</a> and company (there’s no built-in ordering in Sqimitive), <kbd>clone()</kbd> is another shortcut for non-<a href="#sqimitivei-_owning">_owning</a> lists. Models are keyed by their <kbd>id</kbd> attribute value (or <kbd>idAttribute</kbd>) which are like <a href="#sqimitivei-_defaultKey">_defaultKey</a>.</p>

          <pre class="language-javascript">
extend({
  model: null,  // alias to _childClass; do not write to.
  el: null,
  idAttribute: 'id',

  events: {
    '=assignChildren': function (sup, resp, options) {
      options = _.extend({eqFunc: this.idAttribute}, options)
      return sup(this, [resp, options])
    },
  },

  _defaultKey: function (model) {
    return model.get(this.idAttribute)
  },

  reset: function (models, options) {
    if (!arguments.length) {
      this.invoke('remove')
      return this
    } else {
      return this.assignChildren(models, {
        eqFunc: this.idAttribute || 'id',
        keepMissing: !('remove' in options) || !options.remove,
      })
    }
  },

  push: function (model) {
    this.nest(model)
  },

  unshift: function (model) {
    this.nest(model)
  },

  pop: function () {
    var model = this.last()
    model && model.remove()
    return model
  },

  shift: function () {
    var model = this.first()
    model && model.remove()
    return model
  },

  toJSON: function () {
    return this.invoke('get')
  },

  clone: function () {
    if (this._owning) { throw 'clone() will clear base instance.' }
    var copy = new this.constructor(this.get())
    this.each(function (child, key) { copy.nest(key, child) })
    return copy
  },
})
</pre>
        </dd>

        <dt>Model</dt>
        <dd>
          <p>Models have <kbd>escape()</kbd>, <kbd>has()</kbd> shortcuts for <a href="#sqimitivei-get">get()</a>. <kbd>id</kbd> option ("attribute") is readable/writable as <kbd>get('id')</kbd>/<kbd>set('id', X)</kbd> and also readable directly as <kbd>obj.id</kbd> (write attempts won't be caught nor will they change "real" <kbd>id</kbd>).</p>

          <pre class="language-javascript">
extend({
  attributes: {}, // alias to _opt; do not write to.
  defaults: {},   // alias to initial _opt; do not write to.
  id: null,       // alias to get('id'); do not write to.

  _opt: {
    id: null,
  },

  events: {
    '-init': function () {
      this.defaults = Sqimitive.Sqimitive.deepClone(this._opt)
    },

    init: function () {
      this.attributes = this._opt
    },

    change_id: function (id) { this.id = id },
  },

  toJSON: function () {
    return this.get()
  },

  escape: function (opt) {
    return _.escape(this.get(opt))
  },

  has: function (opt) {
    return this.get(opt) != null
  },
})
</pre>
        </dd>

        <dt>View</dt>
        <dd>
          <p>Views have <kbd>setElement()</kbd>, <kbd>delegateEvents()</kbd>, <kbd>undelegateEvents()</kbd> that do similarly what <a href="#sqimitivei-attach">attach()</a> does.</p>

          <pre class="language-javascript">
extend({
  el: null,
  $el: null,    // alias to el; do not write to.

  events: {
    init: function () {
      this.$el = this.el
    },
  },

  setElement: function (el) {
    this.undelegateEvents()
    this.el = this.$el = el
    return this.attach()
  },

  delegateEvents: function (events) {
    this.elEvents = events
    return this.attach()
  },

  undelegateEvents: function () {
    this.el.off('.sqim-' + this._cid)
  },
})
</pre>
        </dd>
      </dl>

      <h3 id="tt-nestmodels">Babysitting Models</h3>

      <p>One of the most common problems when developing a complex client-side app is keeping track of multiple Models or a Collection connected to a particular View. When a new Model appears you need to create and display a new nested View; when it’s removed – its View should go away you; when Model attributes change the View should be updated (this case is often but not always handled by that Model’s View).</p>

      <p>On top of that, when parent View acquires another Collection it should properly detach itself from the previously assigned Collection, attach to the new object and repopulate itself.</p>

      <p>Things get even more complex with asynchronous operations – sometimes the user gets ahead of his connection and you don't want the interface to tangle up.</p>

      <p>Sqimitive addresses these challenges with a full set of methods:</p>

      <ul>
        <li>Attach/detach event handlers to the tracked Collection with <a href="#corei-autoOff">autoOff()</a> or <a href="#sqimitivei-off">off(collection)</a>.</li>
        <li>Keep that Collection as an <a href="#sqimitivei-_opt">option</a> so once it changes you receive <a href="#sqimitivei-change_OPT">change_collection(newCol, oldCol)</a> event.</li>
        <li>Make sure only proper Collections are assigned by checking value-to-be-set in <a href="#sqimitivei-normalize_OPT">normalize_collection(newCol)</a>.</li>
        <li>Listen to new/gone Models with <a href="#sqimitivei-on">on('+nest')</a> and <kbd>'unnested'</kbd>.</li>
        <li>Listen to changed Models with <a href="#sqimitivei-_childEvents">_childEvents = ['change']</a> and <a href="#sqimitivei-on">on('.change')</a>.</li>
        <li>Automatically manage nested Views' DOM connection with <a href="#sqimitivei-_opt">attachPath</a> and <a href="#sqimitivei-attach">attach()</a>. Quite often there’s no need for <a href="#sqimitivei-render">render()</a> at all.</li>
      </ul>

      <p>Sample code below demonstrates these methods in practice. It’s a good idea to make an abstract base class and reuse it throughout your project.</p>

      <pre class="language-javascript">
var ParentView = Sqimitive.Sqimitive.extend({
  _childEvents: ['change'],
  _childClass: NestedView,

  _opt: {
    collection: null,   // Collection.Foo.
  },

  normalize_collection: function (newCol) {
    if (!(newCol instanceof Collection.Foo)) {
      throw 'Bad collection type.'
    } else {
      return newCol
    }
  },

  change_collection: function (newCol, oldCol) {
    // Unbind self from the old collection, if any.
    oldCol && oldCol.off(this)

    // Clear existing nested Views, if any.
    this.invoke('remove')

    // Set up new collection link.
    if (newCol) {
      this.autoOff(newCol, {
        // Note the leading + which makes _modelAdded's first argument to be
        // nest()'s return value which is the new child. Without it if key
        // (optional nest()'s first argument) is present it will be _modelAdded's
        // first argument instead of the child.
        '+nest': '_modelAdded',
        unnested: '_modelRemoved',
        '.change': '_modelChanged',
      })

      // Populate with the existing models.
      newCol.each(this._modelAdded, this)
    }
  },

  _modelAdded: function (model) {
    // This is the place when new nested View gets created and linked to the model.
    // First argument to nest() is view's parent key by which it can be retrieved
    // later. ID is usually unique so it's a good candidate. If this key already
    // existed such a View will be removed and replaced by the new View.
    var view = this.nest(model.get('id'), new this._childClass({
      model: model,
      attachPath: '.models',
    }))

    // Append view.el to this.el.find('.models') and bind its DOM event listeners.
    // This won't render() the View but it might listen to attach() and render
    // automatically.
    view.attach()
    // ...if it doesn't auto-render - no big deal:
    view.render()
  },

  _modelRemoved: function (model) {
    var view = this.nested(model.get('id'))
    if (view) {
      // Removes its element from this.el and then unnests from the list of
      // this View's children, removing its event listeners on the parent View.
      view.remove()
    } else {
      console.warn('Removed a Model with no nested View.')
    }
  },

  _modelChanged: function (model) {
    // Update something when model options change...
  },
})
</pre>

      <p>Given the above code it can be used like this:</p>
      <pre class="language-javascript">
var col = new Collection.Foo
col.nest(new Model.Foo({id: 1}))

new ParentView({collection: col, attachPath: 'body'})
  // Gets created with one nested View. Parent view was appended to &lt;body&gt;.

col.nest(new Model.Foo({id: 2}))
  // New View nested.

col.nested(2).remove()
  // Just nested View got removed.

col.nested(1).set('smth', 'foo')
  // '.change' event got fired on the parent View.
</pre>

      <h3 id="tt-classname">Figuring "class name"</h3>

      <p>With its concept of "functions as first-class citizens", JavaScript lacks any kind of "class name" references in instantinated objects. The best we can afford is duck-typing where we see if object X has properties Y and Z and if it does – it’s <em>probably</em> that kind of object (i.e. "class").</p>

      <p>Sometimes (or rather quite often while debugging) we need to figure what’s the object we see. If your app has all Sqimitive classes defined under a certain object (like <kbd>window</kbd> – which is a bad practice – or <kbd>window.MyApp</kbd>) you can go through all prototypes on start up and add <b>sqClassName</b> property holding string reference to that prototype.</p>

      <p>First, let’s override <a href="#cores-extend">extend()</a> with our own that will mark each produced prototype so we know we're looking at something we have created:</p>

      <pre class="language-javascript">
var BaseSqimitive = Sqimitive.Sqimitive.extend()

BaseSqimitive.extend = function (protoProps, staticProps) {
  var child = Sqimitive.Sqimitive.extend.apply(this, arguments)
  child.sqIsClass = true

  // If your classes are defined like AppRoot, AppRoot.View, AppRoot.View.Cart
  // the following code will skip subclasses when extending a class:
  //   AppRoot.OtherBaseView = AppRoot.View.extend()
  // Without it OtherBaseView would get AppRoot.View.Cart as OtherBaseView.Cart.
  for (var prop in this) {
    if (/^[A-Z]/.test(prop) && typeof this[prop] == 'function' && this[prop].sqIsClass) {
      delete child[prop]
    }
  }

  return child
}
</pre>

      <p>Now on start up we go through all classes and add <b>sqClassName</b> like <kbd>View.Cart</kbd>:</p>

      <pre class="language-javascript">
// Define classes above or wrap the following into $().
;(function (cls, prefix) {
  for (var key in cls) {
    var member = cls[key]
    if (/[A-Z]/.test(key[0]) && typeof member == 'function' && member.sqIsClass) {
      member.prototype.sqClassName = prefix + key
      arguments.callee(member, prefix + key + '.')
    }
  }
})(window.MyAppRoot, '')
// Replace MyAppRoot reference with your root.
</pre>

      <p>Here’s an example of what you get:</p>

      <ul>
        <li><kbd><b>MyAppRoot.BaseView</b>.sqClassName = 'BaseView'</kbd></li>
        <li><kbd><b>MyAppRoot.BaseView.SubView</b>.sqClassName = 'BaseView.SubView'</kbd></li>
        <li><kbd><b>MyAppRoot.BaseModel</b>.sqClassName = 'BaseModel'</kbd></li>
      </ul>

      <h3 id="tt-countdown">Countdown</h3>

      <p>Sometimes you get a number of actions to be completed before performing a specific task. For example, you need to preload a bunch of images and work on them once they are all ready.</p>

      <p>This synchronization task can be carried out with this simple class:</p>
      <pre class="language-javascript">
var Countdown = Sqimitive.Sqimitive.extend({
  el: false,

  _opt: {
    count: 0,
    cx: null,
  },

  events: {
    init: function (opt, onDone) {
      // This way dec() and inc() calls will always happen on this object instance.
      _.bindAll(this, 'dec', 'inc')
      onDone && (this.done = onDone)
    },
  },

  done: Sqimitive.Sqimitive.stub,
  error: Sqimitive.Sqimitive.stub,

  dec: function () {
    if (--this._opt.count == 0) {
      this.done.call(this.get('cx') || this)
    } else if (this._opt.count < 0) {
      console && console.warn('Countdown below zero.')
    }

    return this
  },

  inc: function () {
    ++this._opt.count
    return this
  },
})
</pre>

      <p>Usage is straightforward:</p>
      <pre class="language-javascript">
var images = ['pic1.jpg', 'pic2.jpg']

var countdown = new Countdown({count: images.length}, function () {
  // Ran when all images have been loaded.
});

// Start loading images.
_.each(images, function (path) {
  var img = new Image
  // dec() is bound to the instance so can be called with free context.
  img.onload = countdown.dec
  img.src = path
})
</pre>

      <h3 id="tt-activity">Activity Pipeline</h3>

      <p>At other times, you would ran into a complex synchronization routine with multiple stages that in addition should have those stages easy to override, e.g. in a subclass.</p>

      <p>For example, imagine a <kbd>Page</kbd> class. Its objects occupy all available window space and when switched from one to another must perform a visual effect (e.g. slide or fade). Effect can be changed in specific <kbd>Page</kbd> subclass, there are various actions to perform when it's done (e.g. freeing of data), and there are also conditions when pages should not be changed - e.g. when it's busy or asking for confirmation. And it must be singular - we don't want effects or other phases overlap.</p>

      <p>Below is a helper class that represents a pipeline of actions: begins with <b>prereq()</b>, then <b>passthru()</b>, then <b>transition()</b> and finally <b>done()</b>. If the action has been stopped <b>cancel()</b> occurs at any point. They are all methods but can be turned into events by overriding with <a href="#corei-on">on()</a> according to Sqimitive's <a href="#ov-evt">event model</a>.</p>

      <p>One instance can be only active once at a time - ignores consequent <b>start()</b> calls until <b>done()</b> or <b>cancel()</b> are reached. <kbd>done</kbd> callbacks given during one run are all retained and called upon completion.</p>

      <pre class="language-javascript">
var Activity = Sqimitive.Sqimitive.extend({
  el: false,
  _done: [],
  cx: null,   // autoset to _opt.cx.

  _opt: {
    cx: null,
    active: false,
  },

  events: {
    change_cx: function (value) {
      this.cx = value
    },
  },

  // (1) Proceed to 'passthru' if the activity can be performed (e.g. if
  // popup window can be closed without explicit user choice), otherwise
  // proceed to 'cancel'.
  prereq: function () {
    this.passthru()
  },

  // (2) Proceed to 'transition' if need to perform any action (e.g. if
  // a window is visible, not hidden) or to 'done'.
  passthru: function () {
    this.transition()
  },

  // (3) Proceed to 'done' when all actions are finished.
  transition: function () {
    this.done()
  },

  // (4) Invokes all pending callbacks.
  done: function () {
    var funcs = this._done.splice(0, this._done.length)
    this.set('active', false)
    this._invoke(funcs)
  },

  // (2) Remove all on-done callbacks (not possible to perform the activity).
  cancel: function () {
    this._done = []
    this.set('active', false)
  },

  _invoke: function (list) {
    _.each(list, function (item) {
      try {
        item[0].call(item[1])
      } catch (e) {
        console && console.error('Activity callback exception: ' + e)
      }
    })
  },

  // If currently active func will be called upon completion. If not active
  // the activity will be started and func called when it's done.
  start: function (func, cx) {
    this.enqueue(func, cx, true)
    this.ifSet('active', true) && this.prereq()
    return this
  },

  // Unlike start() doesn't run the activity but instead calls func if it's
  // currnetly active or calls func right away if not, without starting up.
  enqueue: function (func, cx, always) {
    cx = cx || this.cx || this
    if (_.isFunction(func)) {
      ;(always || this.get('active')) ? this._done.push([func, cx]) : func.call(cx)
    }
    return this
  },
})
</pre>

      <p>When you want to start running a new activity use <b>start()</b> with an optional callback:</p>
      <pre class="language-javascript">
var MyPage = Sqimitive.Sqimitive.extend({
  _activity: null,

  elEvents: {
    'click .close': function () {
      this._activity.start(function () {
        alert('Completely went away...')
      })
    },
  },

  events: {
    init: function () {
      this._activity = new Activity({
        // Since Activity's event handlers are called within activity's
        // context we can use this.cx or this.get('cx') to access this page.
        cx: this,
      })

      // You don't have to implement every method down here, this is just a sample.
      this._activity.on({
        passthru: function () {
          if (this.el(':visible')) {
            this.transition()
          } else {
            this.done()
          }
        },

        transition: function () {
          this.cx.el.fadeOut(_.bind(this.done, this))
        },

        done: function () {
          this.cx.remove()
        },
      })
    },
  },
})

var MyAskingPage = MyPage.extend({
  events: {
    init: function () {
      this._activity.on('prereq', function () {
        if (confirm('Really close this page?')) {
          this.passthru()
        } else {
          this.cancel()
        }
      })
    },
  },
})
</pre>

      <p>When you want to have your callback fired right away without startign the activity and postpone if it is active - use <b>enqueue()</b>:</p>
      <pre class="language-javascript">
(new MyPage)._activity.enqueue(function () {
  // At this point it's guaranteed that the activity is no more/was not running.
})
</pre>

      <h2 id="api">API Reference</h2>

      <p>This section describes all of Sqimitive features in detail. Most of this can be found in extensive code comments (and it’s usually more up to date). It makes sense to first read the <a href="#overview">overview</a> before diving in.</p>

      <h3 id="codeconv">Conventions</h3>

      <p>Before we move on let’s quickly review <a href="http://squizzle.me">Squizzle.me Toolkit</a>’s coding conventions:</p>
      <ul>
        <li><b>Protected class fields begin with underscore (<kbd>_</kbd>)</b> – such fields (data properties and methods) are only meant to be read or written by the class they are defined in, or by any of its subclasses. It’s bad practice to try to access them from an ancestor or, mind you, from a disconnected class – this is only justified, if ever, by really severe optimizations (such as tons of <kbd>_opt</kbd> calls).</li>
        <li><b>Underscores separating camelCase</b> – when an identifier (<kbd>oneId</kbd>) needs to be mixed into another (<kbd>TwoId</kbd>) it simply becomes <kbd>oneId_twoId</kbd> instead of <kbd>oneIdTwoId</kbd>, <kbd>one_id_two_id</kbd> or something else dictated by "pretty printing" rules. For example, event identifier for a <kbd>change</kbd> event of an <kbd>attrName</kbd> option is simply <kbd>change_attrName</kbd>.</li>
        <li><b>Semicolon-free zone</b> – you don't have to follow this hype but the author believes that such a code is cleaner and faster to type with a few insignificant drawbacks. No need to pay more where you don't have to, right?</li>
      </ul>

      <h3 id="api-core">Core class</h3>

      <p><a href="#ov-evt">Events</a> play fundamental role in Sqimitive – so fundamental that half of its code implements just that. For this reason Sqimitive per se is split into two classes: <kbd>Core</kbd> and <kbd>Sqimitive</kbd> (both reside under common <kbd>Sqimitive</kbd> namespace).</p>

      <p><kbd>Core</kbd> implements inheritance and event binding, tracking and unbinding. It lacks any serious functionality and can be easily mixed into any other classes of your choice. The class is accessible globally as <kbd>Sqimitive.Core</kbd> but you most likely won't need to access it directly, using <a href="#sqimitive"><kbd>Sqimitive.Sqimitive</kbd></a> instead</p>

      <h4 id="cores">Static properties and methods</h4>

      <dl id="corei-constructor">
        <dt>constructor ()</dt>
        <dd>
          <p>Assigns new unique <a href="#corei-_cid">_cid</a> ("p" + unique number) and clones all instance properties of self that are not listed in <a href="#corei-_shareProps">_shareProps</a>. This puts a stop to accidental static sharing of properties among all instances of a class where those properties are defined; see <a href="#corei-_shareProps">_shareProps</a> for details.</p>
        </dd>

        <dt id="cores-_mergeProps">_mergeProps</dt>
        <dd>
          <p>In Backbone, when you extend a parent class with a property that it already has you end up with a completely new property. This makes sense but not always – for example, if a class has its own <kbd>events</kbd> then what you really need is merge its own (base) events with the events of new subclass. Same thing with Model attributes and defaults, Router routes and others.</p>

          <p>Consider this example (<a href="http://jsfiddle.net/Proger/u2n3e6ex/">JSFiddle</a>):</p>
          <pre class="language-javascript">
var MyView = Backbone.View.extend({
  events: {
    'click .me': function () { alert('You clicked it!') },
  },
})

var MyOtherView = MyView.extend({
  // This object entirely replaces MyView's event map.
  events: {
    'keypress .me': function () { alert('Oh noes, we broke a button :(') },
  },
})
</pre>

          <p><b>_mergeProps</b> lists such properties (only instance) that you want to merge rather than overwrite when subclassing a Sqimitive – exactly as <kbd>_.extend(parentProp, subclassProp)</kbd>. In human language, this means that if subclass defines a merging property and inside it has a key that also exists in the base class' property then subclass overwrites that, but only that, value. All other keys are retained and there is no way to delete a base class' key other than replacing it with <kbd>null</kbd> or <kbd>undefined</kbd> (in contrast with <b>delete</b> such properties are still iterable with <kbd>for..in</kbd>). You can <b>delete</b> them after the instance was constructed.</p>

          <p>By default, <kbd>Core</kbd> class sets it to <a href="#corei-_shareProps">_shareProps</a> while <a href="#sqimitive">Sqimitive</a> class adds <a href="#sqimitivei-_opt">_opt</a> and <a href="#sqimitivei-elEvents">elEvents</a>.</p>
          <p>When passing <b>_mergeProps</b> inside <kbd>staticProps</kbd> (second argument of <a href="#cores-extend">extend()</a>) all inherited items will be removed; correct way to add your properties while keeping those in base classes is this:</p>

          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend({
  // Define instance fields...
}, {
  // Define static fields - if you need. If not don't pass this parameter.
})

// extend() has copied the inherited _mergeProps list which we can now append
// to or modify using regular Array functions.
MySqimitive._mergeProps.push('prop1', 'prop2', ...)
</pre>

          <p>These are <b>wrong</b> ways to append to this property:</p>
          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend({
  // _mergeProps is static so it won't be read from here.
  _mergeProps: ['prop'],
}, {
  // This is fine but it will entirely replace base class' list, if any.
  _mergeProps: ['prop'],
})

// This will work but once again will replace all the inherited items.
MySqimitive._mergeProps = ['prop']

// What you want to do is most often this:
MySqimitive._mergeProps.push('prop')
</pre>
        </dd>

        <dt id="cores-_shareProps">_shareProps</dt>
        <dd>
          <p>In Backbone, every subclass gets values of its inherited properties shared among all instances of the base class where they are defined. Just like in Python, if you have <kbd>extend({array: []})</kbd> then doing <kbd>this.array.push(123)</kbd> will affect all instances where <b>array</b> wasn't overwritten with a new object.</p>

          <p>Consider this short snippet (<a href="http://jsfiddle.net/Proger/vwqk67h8/">JSFiddle</a>):</p>

          <pre class="language-javascript">
var MyView = Backbone.View.extend({foo: {}})
var x = new MyView
var y = new MyView
x.foo.bar = 123
alert(y.foo.bar)
</pre>

          <p>Can you guess the alert message? It’s <kbd>123</kbd>. What a surprise!</p>

          <p>In Sqimitive, every non-scalar property gets cloned upon object instantination. If you don't want this overhead (usually it’s miniscule) – simply assign all complex values in the constructor,  <a href="#sqimitivei-init">init()</a> or <a href="#sqimitivei-postInit">postInit()</a> or list such properties (only instance) in <b>_shareProps</b>. Be safe by default.</p>

          <p>One particular case to be aware of is when you are assigning classes to properties, like <kbd>extend({_model: MyApp.MyModel})</kbd> – it will be recursively copied resulting in a broken prototype. Do this instead:</p>

          <pre class="language-javascript">
var MyView = Sqimitive.Sqimitive.extend({
  _model: MyApp.MyModel,
})

// _shareProps is a static property.
MyView._shareProps.push('_model')
</pre>

          <p>Or you can assign the class after instantination, which is less elegant:</p>

          <pre class="language-javascript">
var MyView = Sqimitive.Sqimitive.extend({
  _model: null,   // MyApp.MyModel

  events: {
    init: function () {
      this._model = MyApp.MyModel
    },
  },
})
</pre>

          <p>By default, base <a href="#sqimitive">Sqimitive</a> class sets it to <a href="#sqimitivei-_childClass">_childClass</a>. When passing <b>_shareProps</b> inside <kbd>staticProps</kbd> (second argument of <a href="#cores-extend">extend()</a>) all inherited items will be removed; correct way to add your properties while keeping those in base classes is this:</p>
          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend(...)
MySqimitive._shareProps.push('prop1', 'prop2', ...)
</pre>

          <p><b>_shareProps</b> inheritance works exactly the same way as <a href="#corei-_mergeProps">_mergeProps</a>' – see its description for more examples.</p>
        </dd>

        <dt id="cores-extend">extend (protoProps[, staticProps])</dt>
        <dd>
          <p>Lets you create a new subclass of the given class. <b>protoProps</b> are new instance fields (properties or methods; can include <a href="#cores-events">events</a> pseudo-property) while <b>staticProps</b> are new static fields – i.e. the ones called as <kbd>MyClass.staticSomething()</kbd> as opposed to <kbd>(new MyClass).instanceSomething()</kbd>. Most of the time you will use just <b>protoProps</b>.</p>

          <p>In case of duplicated names subclass' values take precedence to overwrite values in its parent class (except when such names are listed in <a href="#cores-_mergeProps">_mergeProps</a>).</p>

          <pre class="language-javascript">
// First we extend base Sqimitive class with our own properties.
var MyBase = Sqimitive.Sqimitive.extend({
  _somethingBase: 123,
  _somethingNew: 'foo',

  el: {tag: 'nav', id: 'nav'},

  _opt: {
    baseOption: 'boo',
    baseMore: 'moo',
  },
})

// Now if we extend MyBase...
var MySubclass = MyBase.extend({
  _somethingSub: 'bar',
  _somethingBase: 987,

  el: {tag: 'footer'},

  _opt: {
    subOption: 'sub',
    baseMore: 'bus',
  },
})

/*
  ...we get the following class, after merging with its parent:

    MySubclass = {
      // Got new value - overriden in MySubclass.
      _somethingBase: 987,
      // Retained old value from MyBase.
      _somethingNew: 'foo',
      // New property - introduced in MySubclass.
      _somethingSub: 'bar',

      // Got new value in MySubclass.
      el: {tag: 'footer'},

      // Unlike el, _opt is listed in _mergeProps by default so its
      // properties are merged and not entirely replaced.
      _opt: {
        // Retained.
        baseOption: 'boo',
        // Introduced.
        subOption: 'sub',
        // Overriden.
        baseMore: 'bus',
      },
    }
*/
</pre>
        </dd>

        <dt id="cores-events">events</dt>
        <dd>
          <p>There is no such property per se but it can be passed to <a href="#cores-extend">extend()</a> to add new event handlers (it only exists inside <kbd>extend()</kbd> and does not become <kbd>this.events</kbd>). Since in Sqimitive <a href="#ov-evt">everything is an event</a> this is the way you do inheritance, override methods, etc. Such events are "fused" into the new class declaration so there is no overhead of applying them on each class instantination.</p>

          <p>Formally this is similar to calling <kbd>this.on({events})</kbd> so see <a href="#corei-on">on()</a> with an object argument for details. Also see <a href="#ov-evt">Events overview</a> for a good example</p>
        </dd>

        <dt id="cores-stub">stub ()</dt>
        <dd>
          <p>An empty function that returns <kbd>undefined</kbd>. Used in places where you don't want to supply any implementation – this lets Sqimitive optimize things when it knows that a function can simply be discarded. Technically if you are not a performance purist you can just use <kbd>function () {}</kbd> or <kbd>new Function</kbd> to achieve the same effect.</p>

          <pre class="language-javascript">
var MySqim = Sqimitive.Sqimitive.extend({
  events: {
    success: Sqimitive.Sqimitive.stub,
    // or success: function () { },
    error: Sqimitive.Sqimitive.stub,
  },
})

var my = new MySqim
// Replaces empty handler entirely.
my.on('success', function () { alert('Good!') })
</pre>
        </dd>

        <dt id="cores-unique">unique (prefix)</dt>
        <dd>
          <p>Generates and returns a number starting from <kbd>1</kbd> that is guaranteed to be unique among all calls to <kbd>unique()</kbd> with the same <b>prefix</b> during this page load. Used to assign <a href="#corei-_cid">_cid</a> (unique <em>sqimitive</em> instance identifier).</p>

          <pre class="language-javascript">
Sqimitive.Sqimitive.unique('foo')   // returns 1.
Sqimitive.Sqimitive.unique('foo')   // returns 2.
Sqimitive.Sqimitive.unique('bar')   // returns 1.
Sqimitive.Sqimitive.unique('foo')   // returns 3.
</pre>
        </dd>

        <dt id="cores-picker">picker (prop[, args])</dt>
        <dd>
          <p>Returns a function that expects one argument (an object) that, when called, checks if given object has <b>prop</b> property and if it does – returns its value (if it’s a method then it’s called with <b>args</b> (array) and the result returned), otherwise returns <kbd>undefined</kbd> (for non-objects or objects with no <b>prop</b>).</p>

          <p>Usually it’s given to some <a href="#sqimitivei-underscore">filtering</a> function (see <a href="#ov-child"><kbd>getIncomplete()</kbd> example</a>).</p>

          <pre class="language-javascript">
var obj = {
  one: 1,
  two: function () { return 2 },
  some: function (a, b) { return a + '--' + b },
}

var picker = Sqimitive.Sqimitive.picker;
alert( picker('one') )    // alerts "1".
alert( picker('two') )    // alerts "2".
alert( picker('some', ['A', 'B']) )   // alerts "A--B".
</pre>
        </dd>

        <dt id="cores-expandFunc">expandFunc (func[, obj])</dt>
        <dd>
          <p>Expands a function reference <b>func</b> of object <b>obj</b> (<b>this</b> if not given) into a real <kbd>Function</kbd>. Used in <a href="#sqimitivei-on">on()</a>, <a href="#sqimitivei-events">events</a> and others to short-reference instance's own methods.</p>
          <p>If <b>func</b> is a string and contains a dot or a dash (<kbd>. -</kbd>) - returns <a href="#cores-masker">masked</a> version of this method (<b>mask</b> starts with the first such character). If it's a string without them - returns a function calling method named <b>func</b> on <b>obj</b> (or <b>this</b> if omitted). In other cases returns <b>func</b> as is if <b>obj</b> is omitted or <kbd>_.bind(func, obj)</kbd> otherwise.</p>

          <pre class="language-javascript">
var func = Sqimitive.Sqimitive.expandFunc('meth')
  // returned function will call this.meth(arguments, ...).

var obj = {meth: function (s) { alert(s) }}
func.call(obj, 123)
  // alerts 123.

var func = Sqimitive.Sqimitive.expandFunc('meth-.', obj)
  // this function works in obj context, calling meth with just one
  // argument (2nd it was given) - see masker().

_.each({k1: 1, k2: 2}, func)
  // each() calls func(1, 'k1') and func(2, 'k2').
  // func calls obj.meth('k1') and obj.meth('k2').
  // alerts twice: 'k1' and 'k2'.

_.each({k1: 1, k2: 2}, _.bind(func, obj))
  // if we didn't give obj to expandFunc() previous example would
  // fail - func() would be called on window which has no 'meth' method.
</pre>
        </dd>

        <dt id="cores-masker">masker (func[, mask[, cx[, args]]])</dt>
        <dd>
          <p>Returns a version of <b>func</b> with re-routed arguments according to <b>mask</b>. If <b>mask</b> is a number - skips that number of leading arguments as in <kbd>_.rest()</kbd>, if omitted - assumed to be number <kbd>1</kbd> (skip first argument), otherwise it's a mask string - see below.</p>

          <p><b>func</b> is either a string (method name as in <a href="#cores-expandFunc">expandFunc()</a>) or a function - both called on <b>cx</b> or <b>this</b> if omitted or <kbd>null</kbd>. <b>args</b> is array of extra left-side arguments.</p>

          <p>In string <b>mask</b> each symbol maps arguments given to masked <b>func</b> (result of <b>masker()</b>) to original <b>func</b>. It consists of:</p>

          <ul>
            <li><b>Dots</b> - each is replaced by its index in the string (<kbd>-..-.</kbd> equals to <kbd>-23-5</kbd>).</li>
            <li><b>Dashes</b> - represent arguments that are to be ignored; trailing dashes are ignored (arguments past the end of <b>mask</b> are never given unless <b>mask</b> is a number)</li>
            <li><b>Numbers 1-9</b> - read arguments by index: <kbd>1</kbd> reads 1<sup>st</sup> masked argument, etc.</li>
          </ul>

          <p>For example, <b>mask</b> of <kbd>-.1</kbd> equals to <kbd>-21</kbd> and gives two arguments: <kbd>(arg2, arg1)</kbd>. <b>Empty mask</b> passes zero arguments (so do <kbd>-</kbd>, <kbd>--</kbd>, etc.)</p>

          <p><b>Note:</b> <b>mask</b> of <kbd>'3'</kbd> is different from <kbd>3</kbd> (number) - the first passes 3<sup>rd</sup> argument as the first while the second skips first 3 arguments and passes all others.</p>

          <p>Masking is a way to work around the "Danger of args__" described <a href="#corei-on">here</a> and avoid writing simple callback functions which reorder arguments. It is common to alias a shorted reference like <kbd>var m = Sqimitive.Sqimitive.masker</kbd> and use it in your code since its main point is to be easy to call.</p>

          <pre class="language-javascript">
$.ajax({
  url: 'api/route',
  dataType: 'json',
  context: sqim,

  // This is wrong: success' second argument is textStatus which gets pushed
  // to assignResp(data, options) breaking the latter (options must be an object).
  success: sqim.assignResp,

  // This is correct: we indicate that we are only interested in the first
  // argument which is passed through to assignResp().
  success: Sqimitive.Sqimitive.masker('assignResp', '.'),
})
</pre>

          <pre class="language-javascript">
var m = Sqimitive.Sqimitive.masker

var MyModel = Sqimitive.Sqimitive.extend({
  _opt: {
    caption: '',
  },

  // Unmasked, _.trim() takes two arguments (str, chars) but normalize_OPT()
  // are passed (value, options); the latter interfere with each other.
  normelize_caption: m(_.trim, '.'),
})
</pre>

          <pre class="language-javascript">
_.each(arrayOfSqims, m('nest', '21', col))
  // here we call col.nest() on each item in arrayOfSqim with swapped arguments,
  // effectively nesting each member into the col object. _.each() calls the
  // iterator as (value, key) while nest() takes (key, sqim).

m('nest', 1)
  // returns function that preserves all but the first argument:
  // function () { return this.nest.apply(this, _.rest(arguments)) }

m('nest')
  // the same - omitted mask defaults to number 1.

m('nest', 0, cx)
  // doesn't change arguments (_.rest(a, 0) == a) but binds function to cx.

m('nest', 0, null, ['left', 'left2'])
  // doesn't bind result but pushes 'left' and 'left2' arguments before
  // all given arguments.

m(function (a1, a2) { alert(a1 + ' ' + a2) }, '')
  //  so func
  // will always alert 'undefined undefined'.
</pre>
        </dd>

        <dt id="cores-deepClone">deepClone (obj)</dt>
        <dd>
          <p>Returns a recursive copy of the argument so that any modification to either <b>obj</b> or returned value (<b>obj</b> copy) won't affect its counterpart. Think of this as of recursively calling <kbd>_.clone()</kbd> or <kbd>$.extend()</kbd>.</p>
        </dd>

        <dt id="cores-parseEvent">parseEvent (str)</dt>
        <dd>
          <p>Extracts portions of the given event identifier as recognized by <a href="#corei-on">on()</a>. Returns an object with keys <kbd>prefix</kbd>, <kbd>name</kbd> and <kbd>args</kbd>, throwing an error if <b>str</b> doesn't look like a proper event reference.</p>
        </dd>

        <dt id="cores-fire">fire (funcs[, args])</dt>
        <dd>
          <p>Processes an event call chain. <b>funcs</b> is an array of event registration objects. Calls each handler in turn according to its type (expecting a fixed number of arguments, accepting current result value, affecting return value, etc. according to <b>prefix</b> in <a href="#corei-on">on()</a>) while giving it <b>args</b> (array). If a handler returns something but <kbd>undefined</kbd> and it’s eligible for changing return value (as it’s the case for <kbd>+event</kbd> and <kbd>=event</kbd>), then current result is replaced by that handler’s return value. Returns the ultimate return value after calling each handler. There is no way to skip remaining handlers (but if you really need – try <a href="#corei-fire">all</a> event for this).</p>

          <p><b>funcs</b> can be "falsy", in this case <kbd>undefined</kbd> is returned.</p>
          <p>See also instance method <a href="#corei-fire">fire()</a>.</p>
        </dd>

        <dt id="cores-toArray">toArray (value)</dt>
        <dd>
          <p>Attempts to cast <b>value</b> into a native <kbd>Array</kbd> object. In particular, function <kbd>arguments</kbd> become an array, arrays are returned as is while anything else is wrapped into an array to become its sole member and returned. This means that even <kbd>null</kbd> and <kbd>undefined</kbd> result in <kbd>[value]</kbd> – not <kbd>[]</kbd>.</p>

          <p>Does <b>not</b> clone result.</p>
        </dd>

        <dt id="cores-is$">is$ (obj)</dt>
        <dd>
          <p>Determines if <b>obj</b> is a $ collection (like jQuery or Zepto).</p>

          <pre class="language-javascript">
is$(document.rootElement)   //=> false
is$($('html'))    //=> true
is$($('&lt;p&gt;'))     //=> true
is$(null)         //=> false
</pre>
        </dd>
      </dl>

      <h4 id="corei">Instance properties and methods</h4>

      <dl>
        <dt id="corei-_cid">_cid</dt>
        <dd>
          <p>An identifier of this object instance unique to all <em>sqimitive</em>’s ever instantinated during this page load. Unique to all <kbd>Sqimitive.Core</kbd> instances regardless of subclass. Can be used to namespace DOM events as in <kbd>this.el.on('click.' + this._cid)</kbd>. Begins with "p" for "primitive" followed by a 1-based number.</p>

          <p>Historically expands to "<b>C</b>lient <b>Id</b>entifier" – a term originating from Backbone but probably not holding much meaning at this point.</p>
        </dd>

        <dt id="corei-_events">_events</dt>
        <dd>
          <p>An internal object holding all current event bindings. Note that it includes both "fused" and dynamic events (fused are produced by <a href="#cores-extend">extend</a>'ing a class so that subclass' event handlers cannot be removed on runtime). It’s not advised to deal with this object directly – use <a href="#corei-on">on()</a>, <a href="#corei-once">once()</a>, <a href="#corei-off">off()</a> and <a href="#corei-fire">fire()</a> instead.</p>

          <p><b>_events</b> keys are event names without any prefixes or suffixes (<kbd>render</kbd>, <kbd>remove</kbd> and so on), values – arrays of event registration objects of internal structure (study code comments for details). These value arrays are given to <a href="#cores-fire">fire()</a> when an event occurs.</p>
        </dd>

        <dt id="corei-_autoOff">_autoOff</dt>
        <dd>
          <p>When <a href="#corei-autoOff">autoOff(sqim)</a> is called to keep track of <b>sqim</b> object to which <b>this</b> object has attached an event listener, such <b>sqim</b> object is put into <b>_autoOff</b> array. You can then do <kbd>this.autoOff()</kbd> in <a href="#sqimitive-unnest">unnest()</a> or another place to sever all connections between an object that is about to go away and those still in the world of living.</p>
        </dd>

        <dt id="corei-fire">fire (event[, args])</dt>
        <dd>
          <p>Triggers an event giving <b>args</b> as parameters to all registered listeners. First fires a special <b>all</b> event and if its return value was anything but <kbd>undefined</kbd> – returns it bypassing handlers of <b>event</b> entirely. <b>all</b> gets <b>event</b> put in front of other <b>args</b> (e.g. <kbd>['eventName', 'arg1', 2, ...]</kbd>). It’s safe to add/remove new listeners during the event – they will be in effect starting with the next <b>fire()</b> call (even if it’s nested).</p>

          <p>Note that <b>all</b> event is only triggered for actual events so if, for example, <a href="#sqimitivei-render">render()</a> isn't overriden it will be called as a regular member function without triggering an event.</p>

          <p>See also static method <a href="#cores-fire">fire()</a>.</p>
        </dd>

        <dt id="corei-firer">firer (event[, prependArgs[, self]])</dt>
        <dd>
          <p>Returns a function that, once called, will call <a href="#corei-fire">fire(event, args)</a> in context of <b>self</b> (if not given context is unchanged). <b>args</b> can be used to push some parameters in front of that function’s <b>args</b>. Just a short way of writing:</p>
          <pre class="language-javascript">
_.bind(function () { return this.fire(event, prependArgs.concat(arguments)) }, self)
</pre>
        </dd>

        <dt id="corei-logEvents">logEvents ([enable])</dt>
        <dd>
          <p>A debug method that enables logging of all triggering events to the console. Pass <kbd>false</kbd> to disable. Will do nothing if browser doesn't provide <kbd>console.log()</kbd>. Acts as a handler for special <b>all</b> event (see <a href="#corei-fire">fire()</a>).</p>

          <p>Also acts as the logging handler itself if first argument is a string – this lets you override default behaviour as a regular event handler.</p>

          <p>Note that methods calls that are not events won't be logged. If this sounds trivial remember that in Sqimitive <a href="#ov-evt">methods only become events on demand</a>:</p>

          <pre class="language-javascript">
var MyBase = Sqimitive.Sqimitive.extend({
  // render() is essentially a function.
  render: function () {
    this.el.text('Hello!')
  },
})

// What we're doing is calling a function. It's not an event and won't be
// caught by logEvents().
(new MyBase).render()

var MyChild = MyBase.extend({
  events: {
    render: function () {
      this.el.append('...I extend...')
    },
  },
})

// Now we are in fact firing 'render' - it's an event with two listeners:
// one from MyBase (called first) and another from MyChild.
// This way logEvents() logs the call because 'all' event gets fired because
// 'render' is, in MyChild and descendants, an event that gets fired in the
// first place.
(new MyChild).render()

var MyChile = MyChild.extend({
  render: function () {
    alert('Boom!')
  },
})

// Now we're back to event-less render() - a mere function. Note that two
// former render() handlers are still present so if we attach a new listener
// to render() current render() ("Boom") will be put as a 3rd handler and
// MyChile.render() itself will be replaced by firer('render'). It's a bad
// practice to supersede an "evented" function like this and usually indicates
// an error (forgetting about method of the same name existing among the parents).
// Regardless of the morale, logEvents() here won't track anything.
(new MyChile).render()
</pre>

          <p>If you want to log some extra info or replace <b>logEvent</b>’s logging with your own – use regular Sqimitive inheritance:</p>

          <pre class="language-javascript">
var MyLoggee = Sqimitive.Sqimitive.extend({
 events: {
    logEvents: function (event) {
      // logEvents() calls itself when an event occurs and the first argument is
      // event name - a string. In other cases it's not the logger being called.
      if (typeof event == 'string') {
        console.log('el.' + this.el[0].className)
      }
      // Make sure you don't return any value because a non-undefined result
      // will override original event chain (before which 'all' is called).
    },
  },
})

// Logs both standard logEvents() info and our class name line.
(new MyLogger).logEvents().fire('something')
</pre>
        </dd>

        <dt id="corei-on">on (event[, func[, cx]])</dt>
        <dd>
          <p>The heart of Sqimitive’s <a href="#ov-evt">event system</a>. Lets you add new event listeners, both dynamic and "fused" (that cannot be unbound at a later time). It has several call forms. See also <a href="#corei-once">once()</a> that lets you attach one-shot listeners. Throws an exception if <b>event</b> can't be parsed.</p>

          <dl>
            <dt>on( {events} [, cx] )</dt>
            <dd>
              <p>Fuses <b>multiple event handlers</b> into current object state meaning that they cannot be unbound with <a href="corei-off">off()</a>. Returns <b>this</b>. Similar to <a href="#corei-fuse">fuse()</a> with added event comma notation.</p>

              <p><b>events</b> is an object with one or more event references as keys (e.g. <kbd>=over.ride__</kbd> – see below) and event handlers as values. Multiple references are separated with <kbd>, </kbd> (comma and a <b>space</b>; this is identical to registering them one-by-one). Handlers are either functions (closures) or strings (method names of the object to which listeners are added; resolved on call time so don't have to exist when binding the handler)</p>

              <p><b>cx</b> is optional context in which the handlers are called (defaults to <b>this</b>, the object on which <b>on()</b> is called).</p>

              <p>This is the form used when <a href="#cores-extend">extend</a>'ing an object with <kbd>events</kbd>. It does <b>not</b> apply to <a href="#sqimitivei-elEvents">elEvents</a>.</p>

              <pre class="language-javascript">
sqimitive.on({
  // Calls render() after 'name' option change and before 'birthday' change.
  'change:name, -change:birthday': 'render',

  // Calls the function when close() gets fired.
  close: function () {
    this.el.fadeOut(_.bind(this.remove, this))
  },
})
</pre>
            </dd>

            <dt>on( 'event', func [, cx] )</dt>
            <dd>
              <p>Adds <b>single event handler</b> that can be dynamically removed with <a href="#corei-off">off()</a>. Returns new event listener identifier that <kbd>off()</kbd> accepts (but the latter accepts other things too).</p>
              <p><b>event</b> is a single event reference (comma notation not accepted), <b>func</b> is the function or string method name (resolved when it gets called, optionally masked like <kbd>func-..1</kbd> - see <a href="#cores-expandFunc">expandFunc()</a>) being called when that event is fired, <b>cx</b> is the context in which it is called (defaults to <b>this</b>, the object on which <b>on()</b> is called).</p>
              <p>Because of their dynamic nature, such event handlers are slightly less efficient than fused so usually if your handler is meant to stay with the object for its lifetime – consider using <kbd>on({event: func}, cx)</kbd> or <a href="#corei-fuse">fuse()</a>.</p>
            </dd>
          </dl>

          <table id="evtref">
            <caption><b>Event reference</b> is a string with 3 parts: <kbd>[prefix]event[argcount]</kbd>.</caption>
            <tr>
              <th>prefix</th>
              <td>
                Optional; changes the way event handler is bound and called as explained in the following table.
              </td>
            </tr>
            <tr>
              <th>event</th>
              <td>
                Event name (alphanumeric symbols, dots and colons) – exactly what is given to <a href="#corei-fire">fire()</a> when triggering an event.
              </td>
            </tr>
            <tr>
              <th>args</th>
              <td>
                Zero or more underscores (<kbd>_</kbd>) – if present, the handler gets called only if event was given that number of arguments (it’s not possible to match zero arguments). For example, <kbd>eve__</kbd> registers a handler that is called for <kbd>fire('eve', [1, 2])</kbd> but is not for <kbd>fire('eve', [1])</kbd> or <kbd>fire('eve', [1, 2, 3])</kbd>. In case of <kbd>=event</kbd> (overriding handler), if argument count differs then all handlers superseded by this one get called while the superseding handler itself – does not (equivalent to doing <kbd>return sup(this, arguments)</kbd>).
                <p>Generally, usage of <b>args</b> is frowned upon because of its unintuitive nature – see the note below for details.</p>
              </td>
            </tr>
          </table>

          <table>
            <caption><b>Event prefixes</b></caption>
            <tr>
              <th>prefix</th>
              <th>arguments</th>
              <th>meaning</th>
            </tr>
            <tr>
              <th></th>
              <td>evArgs...</td>
              <td><b>No prefix</b> adds new handler after existing ones and neither gives event result to it nor changes it based on the handler’s return value (which is ignored). Used most often to do some extra computations after original code has executed, retaining original result.</td>
            </tr>
            <tr>
              <th><kbd>-</kbd></th>
              <td>evArgs...</td>
              <td>Adds new handler <b>before</b> existing handlers, otherwise identical to <em>no prefix</em></td>
            </tr>
            <tr>
              <th><kbd>+</kbd></th>
              <td><b>res</b>, evArgs...</td>
              <td>Adds it after existing handlers but is passed current event return value <b>res</b>, and if this handler returns anything but <kbd>undefined</kbd> – replaces event result with that value.</td>
            </tr>
            <tr>
              <th><kbd>=</kbd></th>
              <td><b>sup</b>, evArgs...</td>
              <td>
                <b>Wraps around</b> existing handlers by removing them and passing a single callable <b>sup</b> of form <kbd>function (this, args)</kbd> – first argument corresponds to the object which initiated the event, second is <em>array</em> of arguments that were passed with the event (can be modified to give underlying handlers different set of data). <b>args</b> can also be <kbd>arguments</kbd> that the handler received – in this case first parameter (<kbd>sup</kbd>) is removed and the rest is given to underlying handlers.

                <pre class="language-javascript">
'=someEvent': function (sup, a1, a2) {
  // Passes original context and arguments unchanged.
  return sup(this, arguments)
  // Identical to above but longer - sup() removes itself from the first argument.
  return sup(this, _.rest(arguments))
  // Not identical to above - if event was given 3+ arguments they will
  // be omitted here but passed through by above.
  return sup(this, [a1, a2])
  // Changes first argument and omits 3rd and other arguments (if given).
  return sup(this, [1, a2])
  // Gives no arguments to underlying handlers.
  return sup(this)
},
</pre>
              </td>
            </tr>
          </table>

          <p><b>The danger of args__</b></p>
          <p>In JavaScript, functions accept extra arguments with ease; often you would use some iterator and only care for one of its arguments. However, with <b>args__</b> you have to pass <em>exact</em> number of arguments to the function even if its declaration doesn't use the rest. Consider this example:</p>

          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend({
  accessor: function (prop, value) {
    if (arguments.length == 1) {
      return this._foo[prop]
    } else {
      this._foo[prop] = value
      return value
    }
  },
})

var sqim = new MySqimitive
// This handler should always occur when a property is being set... right?
sqim.on('accessor__', function (prop, value) {
  alert('Now ' + prop + ' is ' + value)
})

sqim.accessor('name', 'val')  // alerts "Now name is val".

var propsToSet = {prop: 'foo', bar: 123}
// Somewhat contrived example for the brevity sake. Properties are set correctly (map()
// calls accessor() for each item in propsToStr); however, no alerts appear.
// This is because map() passes 3 arguments to iterator: value, key and list itself.
// Therefore even if accessor() processes just 2 of them actual event fired is
// accessor___ (3 underscores).
_.map(_.invert(propsToSet), sqim.accessor, sqim)
</pre>
        </dd>

        <dt id="corei-once">once (event, func[, cx])</dt>
        <dd>
          <p>Adds a one-shot event listener that removes itself after being called exactly once. In all other aspects <kbd>once()</kbd> is identical to <a href="#corei-on">on(event, func, cx)</a> (obviously, can only be used for dynamic handlers). Returns event ID suitable for <a href="#corei-off">off()</a> so you can unregister it before it’s called (or after, nothing will happen). Doesn't accept multiple events.</p>
          <p><b>func</b> can be a string – method name of the object to which the handler is bound (resolved when handler gets called). It can be masked like <kbd>func-..1</kbd> (see <a href="#cores-expandFunc">expandFunc()</a>).</p>
        </dd>

        <dt id="corei-fuse">fuse (event, func[, cx])</dt>
        <dd>
          <p>Adds a permanent event listener that cannot be removed with <a href="#corei-off">off()</a>. <b>event</b> is single event reference (<kbd>+some:eveent__</kbd>, no comma notation), <b>func</b> is a function or a string (method name), optionally masked like <kbd>func-..1</kbd> (see <a href="#cores-expandFunc">expandFunc()</a>). <b>cx</b> is context in which func is to be called (defaults to <b>this</b>). See <a href="#corei-on">on()</a> for details. Returns internal event registration object that you should discard without tampering.</p>

          <pre class="language-javascript">
sqimitive.on({
  something: function () { ... },
  someone: function () { ... },
})

// Identical to the above.
sqimitive.fuse('something', function () { ... })
sqimitive.fuse('someone', function () { ... })

// Masked callback - receives (a1, a2, a3), passes (a3, a1, a1, a1) to
// sqim.meth().
sqimitive.fuse('somewhere', 'meth-3111', sqim)
</pre>
        </dd>

        <dt id="corei-off">off (key)</dt>
        <dd>
          <p>Undoes the effect of <a href="#corei-on">on()</a> – removes event listener(s) unless they were <a href="#corei-fuse">fuse</a>'d (permanent). <b>key</b> can be:</p>

          <ul>
            <li><b>Array</b> – members are anything accepted by <b>off()</b> including more arrays.</li>
            <li><b>Object</b> – context (that <b>cx</b>) to which handlers are bound; all with the identical context are removed.</li>
            <li><b>Event name</b> like <kbd>render</kbd> or other – all listeners are removed.</li>
            <li><b>Handler ID</b> – as returned by <b>on()</b>; removes that particular handler from that particular event.</li>
          </ul>

         <p>Returns <b>this</b>. Does nothing if no matching events/contexts/handlers were found. <b>off()</b> is safe to be called multiple times – it will do nothing if there are no registered handlers for given value. When unregistering a wrapping handler (<kbd>=event</kbd>) its underlying handlers are restored – put in place of the wrapper in the event chain.</p>

          <p><a href="#ov-evt">Event overview</a> has a nice example on this subject. See also <a href="#corei-once">once()</a> that lets you attach one-shot listeners.</p>
        </dd>

        <dt id="corei-autoOff">autoOff ( [sqim[, events[, cx]]] )</dt>
        <dd>
          <p>If any arguments are given, adds <b>sqim</b> (object) to this object’s list of tracked objects (<a href="#corei-_autoOff">_autoOff</a>). This list is not used by Sqimitive but your application can use it to unbind all listeners created by this object in the domain of other objects in one go. For example, you can do <kbd>this.autoOff()</kbd> when <b>this</b> is about to be destroyed so that events on other objects to which it had any connections won't trigger its old stale handlers. Returns <b>sqim</b>.</p>

          <p><b>events</b>, if given, is an object – event map where keys are event references (comma notation supported) and values are their handlers. <b>cx</b> is the context in which handlers will be called (defaults to <b>this</b>, the object on which <b>autoOff()</b> was called). <b>cx</b> can be explicitly set to <b>null</b> to keep <b>sqim</b>’s context. Similar to manually calling <a href="#corei-on">on({events}, cx)</a>, see its documentation for details.</p>

          <p>If <b>events</b> is not given only tracks the object without binding any events. One object can be added to the list several times without problems.</p>

          <p>If <b>no arguments</b> are given, uses <a href="#corei-off">off(this)</a> to remove listeners of <b>this</b> from all previously listed objects and clears the list. Similar to doing <kbd>_.invoke(this._autoOff, 'off', this)</kbd>. Returns <b>this</b>.</p>

          <pre class="language-javascript">
var MyNotifyBar = Sqimitive.Sqimitive.extend({
  events: {
    owned: function () {
      this.autoOff(new View.LoginForm, {
        loggedIn: function () { alert('Hi there!') },
        '-multiple, events': ...,
      })
    },

    // This would be an unsafe way - if unnest() was called with any arguments
    // (for whatever the reason) autoOff()'s behaviour would change. See the
    // note on args__ danger in on().
    //'-unnest': 'autoOff',

    '-unnest': function () {
      this.autoOff()
    },
  },
})
</pre>
        </dd>
      </dl>

      <h3 id="api-sqimitive">Sqimitive class</h3>

      <p>While <a href="#core">Core</a> implements the fundamental <a href="#ov-evt">event framework</a>, this class implements what makes Sqimitive <em>the</em> Sqimitive – <a href="#ov-opt">options</a>, <a href="#ov-el">el</a> and <a href="#sqimitive-elEvents">elEvents</a>, <a href="#ov-child">children</a> and <a href="#sqimitivei-underscore">filtering</a> and a bit extra.</p>

      <p><kbd>Sqimitive</kbd> has no static fields. The class is accessible globally as <kbd>Sqimitive.Sqimitive</kbd> but since it’s usually the only class you need (and you probably want a shorter name too) – start your project with something like this:</p>

      <pre class="language-javascript">
var MyApp = {...}
// ...
MyApp.Sqimitive = Sqimitive.Sqimitive.extend()
// Now refer to MyApp.Sqimitive everywhere throughout your code.
</pre>

      <h4 id="sqimitivei">Instance properties and methods</h4>

      <dl>
        <dt id="sqimitivei-_opt">_opt</dt>
        <dd>
          <p>Defines initial object <a href="#ov-opt">options</a> – similar to <kbd>attributes</kbd> in <kbd>Backbone.Model</kbd>. When any option value is changed <kbd>change:OPTION</kbd> and <kbd>change</kbd> events occur but before that occurs <kbd>normalize_OPTION</kbd>. This object can be initially set with <a href="#cores-extend">extend()</a> but it’s not advised to access it directly – use <a href="#sqimitivei-get">get()</a> and <a href="#sqimitivei-set">set()</a> instead or you will bypass normalization and event triggering.</p>

          <p><b>_opt</b> is an object where keys are option names and values are anything, of arbitrary type. <b>_opt</b> is listed in <a href="#cores-_mergeProps">_mergeProps</a> so subclasses defining it will add to their parents' options instead of overwriting them entirely.</p>

          <p>There is currently one (two) built-in option:</p>

          <dl>
            <dt>attachPath</dt>
            <dd>
              <p>Specifies where this object’s <a href="#sqimitivei-el">el</a> will get appended to when its <a href="#sqimitivei-_parent">_parent</a> is rendered or <a href="#sqimitivei-attach">attach()</a> is called with no arguments. Value can be anything accepted by parent’s <a href="#sqimitivei-$">$()</a>, like a string (selector (<kbd>.list > :last-child</kbd>) or <kbd>.</kbd> (period) to specify the parent’s element) or a DOM node.</p>
              <p><b>If a string this will have no effect on non-nested (non-<a href="#sqimitivei-_owning">_owning</a>) sqimitives</b> since access to the parent’s <kbd>$()</kbd> is required – even if a global selector such as <kbd>'body'</kbd> is used; if so you can set <b>attachPath</b> to <kbd>document.bodyElement</kbd> or <kbd>$('body')</kbd> even on non-owned sqimitives.</p>
            </dd>
            <dt>el</dt>
            <dd>
              <p>There is no such option but if <b>el</b> is given to the <a href="#sqimitivei-constructor">constructor</a> as part of the option object it replaces default value of the <a href="#sqimitivei-el">el</a> property (but it cannot be an object of attributes, only a DOM node, selector or <kbd>false</kbd>).</p>
            </dd>
          </dl>
        </dd>

        <dt id="sqimitivei-_parent">_parent</dt>
        <dd>
          <p>References a sqimitive that owns this object. If there’s none is set to <kbd>null</kbd>. You can read this property but writing is discouraged because it may very well break integrity – use <a href="#sqimitivei-nest">nest()</a>, <a href="#sqimitivei-unnest">unnest()</a> and others.</p>
          <p>Non-owning sqimitives (see <a href="#sqimitivei-_owning">_owning</a>) never change their children' <b>_parent</b>.</p>
        </dd>

        <dt id="sqimitivei-_parentKey">_parentKey</dt>
        <dd>
          <p>When this object is <a href="#sqimitivei-_owning">owned</a> by another sqimitive this property is set to the key under which it’s listed in its parent’s <a href="#sqimitivei-_children">_children</a> and which can be given to <a href="#sqimitivei-nested">nested()</a> and others. This is always a string or, for non-owned sqimitives – <kbd>null</kbd> along with their <a href="#sqimitivei-_parent">_parent</a>.</p>
        </dd>

        <dt id="sqimitivei-_children">_children</dt>
        <dd>
          <p>An object with keys being nested children' <a href="#sqimitivei-_parentKey">_parentKey</a>s (always strings) and values being the children themselves. Note that this is a purely formal nesting and doesn't dictate any DOM structure (children can have their <a href="#sqimitivei-el">el</a>’s outside of the parent’s node).</p>
          <p>It’s recommended to access children using <a href="#sqimitivei-nested">nested()</a> and other methods instead of manipulating <b>_children</b> directly. Both <a href="#sqimitivei-_owning">_owning</a> sqimitives and not list their children here.</p>
          <p>See the <a href="#ov-child">children overview</a> for examples.</p>
        </dd>

        <dt id="sqimitivei-_owning">_owning</dt>
        <dd>
          <p>Specifies if sqimitive manages its children or not (by default it does). Managed (owning) parent means that all of its children know who owns them, under which key (see <a href="#sqimitivei-_parentKey">_parentKey</a>) and makes sure they only have one parent – itself. Unmanaged (<b>false</b>) parent simply acts as a collection of children still providing <a href="#sqimitivei-underscore">filtering</a> and other Sqimitive features but not imposing any structure onto its children, which do not even know that they are listed here. More details are found in the <a href="#ov-child">children overview</a>.</p>
          <p>Many properties and methods including <a href="#sqimitivei-_childEvents">_childEvents</a> can be used in both modes.</p>
        </dd>

        <dt id="sqimitivei-_childClass">_childClass</dt>
        <dd>
          <p>Ensures <a href="#sqimitivei-_children">_children</a> contains instances of the specified class as long as children are only added via <a href="#sqimitivei-nest">nest()</a> is used and this property isn't changed on runtime. Is meant to be a sub/class of <kbd>Sqimitive</kbd> (this is not checked though). Defaults to <kbd>Sqimitive</kbd>.</p>

          <pre class="language-javascript">
var MyToDoItem = Sqimitive.Sqimitive.extend()

var MyToDoList = Sqimitive.Sqimitive.extend({
  _childClass: MyToDoItem,
})

(MyToDoList).nest({})   // throws an exception.
</pre>
        </dd>

        <dt id="sqimitivei-_childEvents">_childEvents</dt>
        <dd>
          <p>Can be overriden in subclasses to automatically <a href="#sqimitivei-forward">forward()</a> events occurring in any of <a href="#sqimitivei-_children">_children</a> to this instance, with event name prefixed with a dot (e.g. <kbd>render</kbd> → <kbd>.render</kbd>). Identical to manually calling <a href="#sqimitivei-on">on()</a> and <a href="#sqimitivei-off">off()</a> so can even specify methods that will be <a href="#ov-evt">turned into</a> events. Event handlers receive the child instance as first argument.</p>

          <p>Don't list <a href="#sqimitivei-unnest">unnest()</a> here – <a href="#sqimitivei-_parent">_parent</a> will <a href="#sqimitivei-off">off()</a> itself before that and never receive the notification. Use <a href="#sqimitivei-unnested">unnested()</a> instead or <kbd>-unnest</kbd> (but in this case if an exception occurs during unnesting your handler won't know this and will be called before the view is removed).</p>

          <p>See <a href="#ov-child">Children overview</a> for a comprehensive example.</p>

          <pre class="language-javascript">
var MyList = Sqimitive.Sqimitive.extend()
  _childEvents: ['-change'],

  events: {
    '.change': function (sqim, name) {
      alert('Option ' + name + ' is about to change on ' + sqim._cid)
    },
  },
})
</pre>

          <p>With multi-level nesting you can forward already forwarded <kbd>_childEvents</kbd> just like that:</p>

          <pre class="language-javascript">
var MyListGroup = Sqimitive.Sqimitive.extend({
  // Indicate this object nests MyList instances.
  _childClass: MyList,

  // MyList forwards '-change' on its children as '.-change' on itself so
  // we can foward that event too on this grouping instance. There's no
  // limit - '....-change' is perfectly fine and works on 4th nesting level.
  // Each forward gets originating object pushed in front so '..-change' gets
  // MyList as first argument. '...-change' would get (MyListGroup, MyList).
  _childEvents: ['.-change'],
})

// Listening to '-change' that occurred on a MyList child, with MyList being
// nested into MyListGroup.
(new MyListGroup).on('..-change', function (listGroup) { ... })
</pre>
        </dd>

        <dt id="sqimitivei-_respToOpt">_respToOpt</dt>
        <dd>
          <p>Specifies the way external input object (e.g. API response) is transformed into options when <a href="#sqimitivei-assignResp">assignResp()</a> is called. <a href="#sqimitivei-set">set()</a> is used to assign new values so normalization and change events take place as usual. <b>_respToOpt</b> is an object where keys are input keys and values are one of the following:</p>

          <dl>
            <dt>false</dt>
            <dd>Input item is skipped regardless of <a href="#sqimitivei-assignResp">options.onlyDefined</a>.</dd>
            <dt>true</dt>
            <dd>Input item becomes value for the option by the same name.</dd>
            <dt>string</dt>
            <dd>Same as <b>true</b> but changes the option’s name.</dd>
            <dt>function (respValue, key, resp, options)</dt>
            <dd>Flexible transformation – is called in this object’s context and must return <kbd>['optToSet', value]</kbd>. <b>_respToOpt</b>’s key only determines <b>respValue</b> given to this function; the latter can access entire <b>resp</b> for other data (<b>key</b> argument holds the original <b>_respToOpt</b>’s key), <b>options</b> is the object given to <a href="#sqimitivei-assignResp">assignResp()</a>. If <b>optToStr</b> is returned as <kbd>false</kbd> – the input item is skipped, otherwise it’s option name to set <b>value</b> to.</dd>
          </dl>

          <p>Missing keys may or may not be passed through to <kbd>this._opt</kbd> unchanged – this depends on the <b>options.onlyDefined</b> flag of <a href="#sqimitivei-assignResp">assignResp()</a>.</p>
        </dd>

        <dt id="sqimitivei-el">el</dt>
        <dd>
          <p>After <a href="#sqimitivei-init">init()</a> has ran is either a DOM node wrapped in <kbd>$()</kbd> or <kbd>null</kbd> if node creation was disabled. Not advised to change directly, treat as read-only.</p>

          <p>When <a href="#cores-extend">extend</a>'ing this can be set to <kbd>false</kbd> (no element is created, <b>this.el</b> will be <kbd>null</kbd> – useful for data structures aka Models), a string (DOM selector) or an object of HTML attributes plus the following special keys:</p>

          <dl>
            <dt>tag</dt>
            <dd>String – tag name like <kbd>li</kbd>. Defaults to <kbd>div</kbd>.</dd>
            <dt>className</dt>
            <dd>The same as <kbd>class</kbd> (CSS class) to work around the reserved word.</dd>
          </dl>

          <p>See <a href="#ov-el">Views overview</a> for the high-level idea.</p>
        </dd>

        <dt id="sqimitivei-elEvents">elEvents</dt>
        <dd>
          <p>Lists automatically bound DOM event listeners for <a href="#sqimitivei-el">el</a>. Format is inherited from Backbone and is an object with keys of <kbd>click[ .sel .ector]</kbd> form and values being functions (closures) or strings (method names, resolved when event occurs so they can be defined later, optionally masked like <kbd>func-..1</kbd> - see <a href="#cores-expandFunc">expandFunc()</a>). In the latter case be aware of the "Danger of args__" described <a href="#corei-on">here</a> – it’s called as <kbd>function (eventObject)</kbd>.</p>
          <p>Listeners are automatically rebound by <a href="#sqimitivei-attach">attach()</a>. See also <a href="#sqimitive-_opt">attachPath</a>.</p>
          <p><b>elEvents</b> is listed in <a href="#cores-_mergeProps">_mergeProps</a> so subclasses defining it add to their parents' events instead of overwriting them entirely.</p>

          <pre class="language-javascript">
var MyView = Sqimitive.Sqimitive.extend()
  el: {tag: 'form'},

  elEvents: {
    // Attach listener to this object's el.
    submit: function (e) {
      e.preventDefault()
      // ...
    },

    // React on change originating from an element with specific name attribute.
    'change [name=login]': function () {
      this.$('[name=password]').val('')
    },

    // Call render() whenever value of an element with name attribute changes.
    'change [name]': 'render',

    // Masked callback - only gives first argument to _linkClicked().
    'click a': '_linkClicked.',
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-length">length</dt>
        <dd>
          <p>An integer specifying how many nested <a href="#sqimitivei-_children">_children</a> this object contains. Just like <kbd>$(...).length</kbd> or <kbd>(new Backbone.Collection).length</kbd>.</p>
        </dd>

        <dt id="sqimitivei-constructor">constructor ([opt])</dt>
        <dd>
          <p>Triggers <a href="#core">Core</a>’s <a href="#corei-constructor">constructor</a> which assigns <a href="#corei-_cid">_cid</a>, clones all but <a href="#corei-_shareProps">_shareProps</a>, <a href="#corei-fire">fires</a> <kbd>init</kbd> which creates <a href="#sqimitivei-el">this.el</a>, assigns jQuery <kbd>el.data('sqimitive', this)</kbd> (so you can reverse-lookup a Sqimitive instance from its DOM node – a deplorable practice) and calls <a href="#sqimitivei-set">set()</a> to replace default values of <a href="#sqimitivei-_opt">this._opt</a> according to <b>opt</b> (object, if given). Finally fires <kbd>postInit</kbd> which you should override instead of <b>constructor</b> to put your object initialization logic into. Both events receive the same arguments as the constructor was given, which in turn gets them from <b>new</b>.</p>
          <p><b>opt</b> can contain <b>el</b> to override default <a href="#sqimitivei-el">this.el</a> (a DOM node or a selector but not an object of attributes). Note that <b>el</b> is not automatically attached anywhere after it’s created, nor are its <a href="#sqimitivei-elEvents">elEvents</a> bound – call <a href="#sqimitivei-attach">attach()</a> for this.</p>
        </dd>

        <dt id="sqimitivei-init">init ([opt])</dt>
        <dd>
          <p>Creates <a href="#sqimitivei-el">this.el</a>, if necessary. Sets <a href="#sqimitivei-_opt">this._opt</a> from object passed to the constructor, if any. See <a href="#sqimitivei-constructor">constructor</a> description for details.</p>
        </dd>

        <dt id="sqimitivei-postInit">postInit ([opt])</dt>
        <dd>
          <p>An event called after <a href="#sqimitivei-init">init()</a> has done its job. Useful to add bindings to nodes and objects that have been created during <kbd>init()</kbd>. Is called once in each object’s life.</p>

          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend({
  _button: null,

  events: {
    postInit: function () {
      this._button = this.nest(new Button)
    },
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-render">render ()</dt>
        <dd>
          <p>Placeholder for populating <a href="#sqimitivei-el">el</a> with the actual contents of this instance (aka <a href="#ov-view">View</a>). Default implementation re-inserts all nested Sqimitive under their corresponding <a href="#sqimitivei-_opt">attachPath</a>’s under <kbd>this.el</kbd> with <a href="#sqimitivei-attach">attach()</a>. It doesn't render them. Returns <b>this</b>.</p>
        </dd>

        <dt id="sqimitivei-attach">attach ([parent])</dt>
        <dd>
          <p>Appends <a href="#sqimitivei-el">el</a> to <b>parent</b> (DOM selector or node). If no argument is given uses <a href="#sqimitivei-_opt">attachPath</a> option (if present) to determine the parent (use this option to keep element always attached to a point in the DOM). If parent was changed recursively calls <b>attach()</b> on all children of self to rebind their DOM listeners (doesn't happen if no parent was found or <kbd>this.el</kbd> is already direct child of the found parent node so performance penalty of subsequent <b>attach()</b> calls is small).</p>
          <p>Ultimately, clears existing event listeners and binds those defined in <a href="#sqimitivei-elEvents">elEvents</a> under <kbd>.sqim-CID</kbd> namespace.</p>

          <pre class="language-javascript">
sqim.attach('#nav')   //= sqim.el.appendTo('#nav')
sqim.attach('&lt;div&gt;')  //= sqim.el.appendTo($('&lt;div&gt;')) or just appendTo('&lt;div&gt;')
sqim.attach('#nothinghereever!')      // does nothing
sqim.attach()         // uses sqim._opt.attachPath, if available
sqim.attach(sqim.get('attachPath'))   // the same
</pre>
        </dd>

        <dt id="sqimitivei-get">get ([opt])</dt>
        <dd>
          <p>Reads one option named <b>opt</b> or, if there are no arguments – shallow-copies and returns all options (<a href="#sqimitivei-_opt">_opt</a>) – it’s safe to change the object itself (add/remove properties) but changing its values will indirectly change these options inside the sqimitive.</p>
          <p>Don't access <kbd>hits._opt</kbd> directly because you will lose ability to change the "getter" behaviour – e.g. you can read non-existing options or transform them like this:</p>

          <pre class="language-javascript">
var MySetter = Sqimitive.Sqimitive.extend(
  _opt: {
    foo: 'Foo!',
  },

  events: {
    // Now any option can be read as option:up to turn its value into upper case.
    '+get': function (res, opt) {
      if (opt = opt.match(/^([^:]+):up$/)) {
        return this.get(opt[1]).toUpperCase()
      }
    },
  },
})

// Popup: FOO!
alert((new MySetter).get('foo:up'))
</pre>
        </dd>

        <dt id="sqimitivei-set">set (opt, value[, options])</dt>
        <dd>
          <p>Same as <a href="#sqimitivei-ifSet">ifSet()</a> but returns <b>this</b> instead of <kbd>true</kbd>/<kbd>false</kbd> indicating if the new value was different from the old one or if <b>options.forceFire</b> was set (and so <a href="#sqimitivei-change_OPT">change</a> events were fired).</p>
          <p>Note: if you are overriding a "setter" you should override <kbd>ifSet</kbd> instead of <b>set()</b> which calls the foremer.</p>
          <p>See <a href="#sqimitivei-ifSet">ifSet()</a> for details.</p>
          <p>There’s no standard <b>set()</b> version that writes multiple options at once. You might be looking for <a href="#sqimitivei-assignResp">assignResp</a> (useful when assigning a backend response) or <kbd>$.each(opts, _.bind(model.set, model))</kbd>.</p>
        </dd>

        <dt id="sqimitivei-ifSet">ifSet (opt, value[, options])</dt>
        <dd>
          <p>Writes one option (<a href="#sqimitivei-_opt">this._opt</a>). First calls <a href="#sqimitivei-normalize_OPT">normalize_OPT</a> on <b>value</b>, then fires <a href="#sqimitivei-change">change</a> and <a href="#sqimitivei-change_OPT">change_OPT</a> events if the normalized value was different (not <kbd>_.isEqual()</kbd>) or if <b>options.forceFire</b> was set. Returns <kbd>true</kbd> if events were fired (value differs or <b>options.forceFire</b> given).</p>
          <p><b>options</b> can be used to propagate custom data to event listeners on <a href="#sqimitivei-normalize_OPT">normalize_OPT()</a>, <a href="#sqimitivei-change_OPT">change_OPT()</a> and <a href="#sqimitivei-change">change()</a>.</p>
          <p>It is safe to write more options from within <b>ifSet()</b>, normalize or change handlers – they are written immediately but consequent normalize/change events are deferred in FIFO fashion (first set – first fired).</p>
          <p>See also <a href="#sqimitivei-ifSet">set()</a> and <a href="#ov-opt">Options overview</a>.</p>

          <pre class="language-javascript">
var MySetter = Sqimitive.Sqimitive.extend({
  _opt: {
    readOnly: 'foo',
  },

  events: {
    // Our handler will be called before inherited ifSet() which will prevent
    // modification of this._opt.readOnly when they are done via set/ifSet -
    // the recommended way.
    //
    // Make sure not to use '-set' though because set() calls ifSet() and it
    // would be still possible to change readOnly with ifSet('readOnly', 'bar').
    '-ifSet': function (opt) {
      if (opt == 'readOnly') {
        throw 'You shouldn\'t really change what is called readOnly, you know?'
      }
    },
  },
})
</pre>

          <p>You can take advantage of <b>ifSet()</b>’s return value to perform interlocking operations (not necessary concurrently-safe but at least saving a call to <a href="#sqimitivei-get">get()</a>):</p>
          <pre class="language-javascript">
if (sqim.ifSet('eventsBound', true)) {
  // eventsBound was previous false (not === true) and it was now changed to
  // true so we can do what we need, once.
}
</pre>

          <p>…as a short form of:</p>
          <pre class="language-javascript">
if (!sqim.get('eventsBound')) {
  sqim.set('eventsBound', true)
  // ...
}
</pre>
        </dd>

        <dt id="sqimitivei-normalize_OPT">normalize_OPT (value, options)</dt>
        <dd>
          <p>When setting any <a href="#sqimitivei-_opt">_opt</a>, new value first gets normalized by calling function/event named this way, if it is defined. It’s a good place to throw an error on wrong format too. <b>options</b> is an object with contents originally given to <a href="#sqimitivei-set">set()</a> or  <a href="#sqimitivei-ifSet">ifSet()</a>. There is no global normalization function but you can override <a href="#sqimitivei-ifSet">ifSet()</a> for this purpose.</p>

          <pre class="language-javascript">
var MyNorm = Sqimitive.Sqimitive.extend({
  _opt: {
    stringie: '',
  },

  // Now stringie is guaranteed to have no surrounding whitespace and be
  // lower case - as long as it's not written directly as this._opt.stringie.
  normalize_stringie: function (value) {
    return _.trim(value).toLowerCase()
  },
})

// Popup: foo
alert( (new MyNorm).set('stringie', '  Foo\n').get('stringie') )
</pre>
        </dd>

        <dt id="sqimitivei-change_OPT">change_OPT (value, old, options)</dt>
        <dd>
          <p>When new <a href="#sqimitivei-normalize_OPT">normalized</a> option value is different from current one (given as <b>old</b>), an event named this way gets called after writing the value to <a href="#sqimitivei-_opt">_opt</a>. <b>options</b> is an object with contents originally given to <a href="#sqimitivei-set">set()</a> or  <a href="#sqimitivei-ifSet">ifSet()</a>. See also <a href="#sqimitivei-change">change()</a> that gets called after any change (after corresponding <kbd>change_OPT</kbd>).</p>
          <p>If you refer to the handler by its string name as in the example below – be aware of the "Danger of args__" described <a href="#corei-on">here</a>.</p>

          <pre class="language-javascript">
var MyNorm = Sqimitive.Sqimitive.extend({
  _opt: {
    caption: '',
  },

  events: {
    // When caption is changed - calls render() to update the interface.
    change_caption: 'render',
  },
})
</pre>

          <p>Here is how you can propagate custom <b>options</b>:</p>
          <pre class="language-javascript">
sqim.on('change_foo', function (value, old, options) {
  if (!options || !options.noSync) {
    $.ajax({
      url: 'update',
      type: 'POST',
      data: this.get(),
    })
  }
})

// The handler above performs an AJAX request:
sqim.set('foo', 123)

// But not now:
sqim.set('foo', 123, {noSync: true})

// assignResp() passes options given to it through to set() so the handler
// doesn't perform the request:
sqim.assignResp({foo: 123}, {noSync: true})
</pre>
        </dd>

        <dt id="sqimitivei-change">change (opt, value, old, options)</dt>
        <dd>
          <p>Gets called after each <a href="#sqimitivei-change_OPT">change_OPT</a> with the same parameters as it and the changed option name put in front. See its description for details.</p>
        </dd>

        <dt id="sqimitivei-nest">nest ([key,] sqim[, options])</dt>
        <dd>
          <p>Adds new contained Sqimitive instance <b>sqim</b> to self. Unless <a href="#sqimitivei-_owning">this._owning</a> is <kbd>false</kbd>, one Sqimitive can only have one parent or none thus forming a bi-directional tree (more details <a href="#ov-child">here</a>). If <b>key</b> is omitted <a href="#sqimitivei-_defaultKey">_defaultKey()</a> is called to determine it, which by default returns <a href="#corei-_cid">sqim._cid</a> (unique instance identifier). Updates <a href="#sqimitivei-_parent">sqim._parent</a> and <a href="#sqimitivei-_parentKey">_parentKey</a>. <b>options</b> are currently unused but can be used to propagate custom data to event listeners (it’s also passed through by <a href="#sqimitivei-assignChildren">assignChildren()</a>).</p>

          <p>Errors if trying to nest object of wrong class (not <a href="#sqimitivei-_childClass">this._childClass</a>). Unnests <b>sqim</b> from its former parent, if any. <a href="#sqimitivei-_forward">Forwards</a> its events according to <a href="#sqimitivei-_childEvents">this._childEvents</a>. Finally, calls <a href="#sqimitivei-owned">sqim.owned()</a> to notify new child of the parent change.</p>

          <p>Errors if <b>key</b> is <kbd>undefined</kbd>, <kbd>null</kbd> or object (as given or returned by <a href="#sqimitivei-_defaultKey">_defaultKey()</a>). Converts <b>key</b> to string.</p>

          <p>Returns <b>sqim</b>. Does nothing if it’s already contained in this instance under the same key (if key differs removes and nests <b>sqim</b> again).</p>

          <p>There’s no standard <b>nest()</b> version that adds multiple child objects at once. You might be looking for <a href="#sqimitivei-assignChildren">assignChildren()</a> (useful when assigning a backend response).</p>

          <pre class="language-javascript">
sqim.nest(new Sqimitive)          // _parentKey = 'p123'
sqim.nest('key', new Sqimitive)   // _parentKey = 'key'
sqim.nest('key', null)
  // If sqim._owning is false - removes and returns the child under 'key', if any.
  // For _owning sqim this call form will produce an exception.
</pre>

          <p><b>When listening to nest as an event</b> and if you need to retrieve the nested object – use <kbd>+nest</kbd> or <kbd>=nest</kbd> <a href="#corei-on">event forms</a>. This will pass result returned by <b>nest()</b> – the child – as the callback’s first argument. With <kbd>nest</kbd> or <kbd>-nest</kbd> first argument will be whatever was given to <b>nest()</b> – which might be <b>sqim</b> but might also be <b>key</b>.

          <pre class="language-javascript">
sqim.on('+nest', function (nested) {
  alert(nested._cid)
})

sqim.on('=nest', function (sup, nested) {
  var nested = sup(this, arguments)
  alert(nested._cid)
  return nested
})

// In contrast...
sqim.on('nest', function (nested) {
  console.dir(nested)
})

// Everything's okay.
sqim.nest(new MySqimitive)
// But not now - 'nested' above is string "key".
sqim.nest('key', new MySqimitive)
</pre>
        </dd>

        <dt id="sqimitivei-_defaultKey">_defaultKey (sqim)</dt>
        <dd>
          <p>Is called when <a href="#sqimitivei-nest">nest()</a> wasn't given an explicit key to determine one. <b>sqim</b> is the sqimitive that is about to be nested into this instance. Similar to Backbone’s <kbd>idAttribute</kbd>.</p>

          <p>If you're trying to index children by some "ID" attribute (like Backbone’s Collection) note that <a href="sqimitivei-_parentKey">_parentKey</a> will <b>not</b> be auto updated if that attribute changes. You should react to the change yourself, for example:</p>

          <pre class="language-javascript">
var MyCollection = Sqimitive.Sqimitive.extend({
  _childEvents: ['.change_id'],

  events: {
    // '.change_id' will only occur for models which _parent is this.
    // They will be re-nested with nest() expanding to
    // nest(this._defaultKey(sqim), sqim) which is like nest(newID, sqim).
    // This will cause sqim to be unnest()'ed and then nested with the new key.
    '.change_id': function (sqim) { this.nest(sqim) },
  },

  _defaultKey: function (sqim) {
    return sqim.get('id')
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-owned">owned ()</dt>
        <dd>
          <p>Is called after this instance has been <a href="#sqimitivei-nest">nest()</a>'ed into an <a href="#sqimitivei-_owning">_owning</a> sqimitive (changed parents/got a first parent). <a href="#sqimitivei-_parent">this._parent</a> and <a href="#sqimitivei-_parentKey">_parentKey</a> are already set. Takes no arguments, can return anything. Not to be called directly.</p>
          <p>See also <a href="#sqimitivei-unnest">unnest()</a> that gets called before parent is changed/removed.</p>

          <pre class="language-javascript">
var MyChild = Sqimitive.Sqimitive.extend({
  events: {
    // Will append this.el to parent's .some-point node as soon as this
    // instance gets a new parent.
    owned: function () {
      this.attach(this._parent.$('.some-point'))
    },
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-_forward">_forward (prefix, events, sqim)</dt>
        <dd>
          <p>Forwards each of events to <b>sqim</b> instance by firing <b>prefix</b> + <b>event_name</b> on this instance (the one <kbd>_forward</kbd> is called on) with <b>sqim</b> pushed in front of original event arguments. This is used to forward <a href="#sqimitivei-_childEvents">_childEvents</a>, with <b>prefix</b> = <kbd>.</kbd>.</p>

          <p>For example, <kbd>origin._forward('dlg-', ['change', 'render'], destination)</kbd> will fire <kbd>dlg-change</kbd> and <kbd>dlg-render</kbd> events on <b>destination</b> (a Sqimitive) whenever <kbd>change</kbd> and <kbd>render</kbd> are fired on <b>origin</b>.</p>
        </dd>

        <dt id="sqimitivei-unlist">unlist (key)</dt>
        <dd>
          <p>If <a href="#sqimitivei-_owning">this._owning</a> is unset, unnests a child by its key or instance (does nothing if this key/child is not contained). If <kbd>_owning</kbd> is set (it is by default) checks if <b>key</b> is nested and if it is calls <a href="#sqimitivei-remove">remove()</a>.</p>
          <p>Returns the unnested sqimitive or <kbd>undefined</kbd>.</p>
          <p>In contrast to <a href="#sqimitivei-unnest">unnest()</a> this method is called on the parent object because there’s no reverse child → parent relationship in non-owning mode.</p>

          <pre class="language-javascript">
collection.unlist('foo')    //=> Sqimitive or undefined
collection.unlist(collection.nested('foo'))   // identical to above
collection.unlist(child)    //=> Sqimitive (child) or undefined
</pre>
        </dd>

        <dt id="sqimitivei-unnest">unnest ()</dt>
        <dd>
          <p>Removes this instance from its parent object, if any. This effectively creates new detached tree (if this has nested objects) or leaf (if not) – see more about the <a href="#ov-child">Children concept</a>. It may be called even if <a href="#sqimitivei-_parent">this._parent</a> was already <kbd>null</kbd>. Calls <a href="#sqimitivei-unnested">unnested(this)</a> on former parent.</p>
          <p>Note that it doesn't remove <a href="#sqimitivei-el">this.el</a> from its parent node – use <a href="#sqimitivei-remove">remove()</a> for this.</p>

          <pre class="language-javascript">
var MyChild = Sqimitive.Sqimitive.extend({
  events: {
    '-unnest': function () {
      // this._parent and _parentKey are still set if this instance was
      // attached to any parent, otherwise they are null.
      this._parent && alert("I am about to be... unnested! :'(")
    },

    unnest: function () {
      // At this point _parent and _parentKey are certainly null but there's
      // no telling if they were so - or if this instance had any parent before
      // unnest() was called.
      alert('I am now as free as the wind!')
    },

    // In contrast to the above, here we can reliably determine if this
    // sqimitive was previously nested and if it was - do something after
    // it was unnested by calling standard handler.
    '=unnest': function (sup) {
      var hadParent = this._parent
      sup(this, arguments)
      hadParent && alert('I was abducted but you saved me!')
      return res
    },
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-remove">remove ()</dt>
        <dd>
          <p>Similar to <a href="#sqimitivei-unnest">unnest()</a> but before unnesting removes <a href="#sqimitivei-el">this.el</a> from its parent DOM node. Note that this doesn't recursively remove all nested <a href="#sqimitivei-_children">_children</a> as it might not be desired and slow; if they need to do some on-removal actions like removing event handlers – you can do <a href="#sqimitivei-sink">this.sink('remove')</a> (recursive).</p>

          <pre class="language-javascript">
var child = new Sqimitive.Sqimitive({el: '&lt;p&gt;Some text.&lt;/p&gt;'})
var parent = new Sqimitive.Sqimitive({el: '&lt;article&gt;'})
parent.nest(child).attach(parent.el)
// Now we have &lt;article&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;/article&gt;.

child.unnest()
// Now we still have &lt;article&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;/article&gt; even though
// child is no more listed under parent._children.
// But should we have done this...

child.remove()
/// ...as we would have &lt;article&gt;&lt;/article&gt; with child removed both
// from parent's children list and its el.
</pre>
        </dd>

        <dt id="sqimitivei-unnested">unnested (sqim)</dt>
        <dd>
          <p>Is called right after a child <b>sqim</b> was detached from its parent (<b>this</b>). Default implementation <a href="#sqimitivei-off">unregisters</a> all event handlers that might have been previously attached to <b>sqim</b> by this object (provided they were not hardwired with <a href="#sqimitivei-fuse">fuse()</a> and used <kbd>cx === this</kbd>). At this point <a href="#sqimitivei-_parent">sqim._parent</a> and <a href="#sqimitivei-_parentKey">sqim._parentKey</a> are already <kbd>null</kbd>.</p>

          <p>If <a href="#sqimitivei-_owning">this._owning</a> is <kbd>false</kbd> this is called when unnesting a child via <a href="#sqimitivei-nest">nest('key', null)</a>.</p>

          <p>Can return anything. Not to be called directly.</p>

          <pre class="language-javascript">
var MyParent = Sqimitive.Sqimitive.extend({
  events: {
    unnested: function (sqim) {
      alert('Where thou go, my ' + sqim._cid + '...')
    },
  },
})
</pre>
        </dd>

        <dt id="sqimitivei-nested">nested ([key])</dt>
        <dd>
          <p>Returns all nested sqimitives if <b>key</b> is not given, or a child by its key (<a href="#sqimitivei-_parentKey">_parentKey</a>, case-sensitive) or its object instance. Returns <kbd>undefined</kbd> if given key/object <b>key</b> isn't nested in this instance or <b>key</b> is <kbd>null</kbd> or <kbd>undefined</kbd>.</p>

          <pre class="language-javascript">
sqim.nested()   //=> {childKey1: Sqimitive, ...}
sqim.nested('childKey1')    //=> Sqimitive
sqim.nested('foobarbaz!')   //=> undefined

var child = sqim.nested('childKey1')
sqim.nested(child)          //=> child
sqim.nested(new Sqimitive)  //=> undefined - argument not listed in sqim._children
</pre>
        </dd>

        <dt id="sqimitivei-slice">slice (start[, length])</dt>
        <dd>
          <p>Regular <kbd>Array.slice()</kbd>, treats this instance’s children as an ordered array instead of <kbd>{key: Sqimitive}</kbd> object.</p>

          <pre class="language-javascript">
sqim.slice(1, 1)   // get 2nd child as an array
sqim.slice(0, -1)  // get last child as an array; last() is more convenient
sqim.slice(5, 3)   // get 6th, 7th and 8th children as an array
sqim.slice(0, 0)   //=> [] - empty array
</pre>
        </dd>

        <dt id="sqimitivei-at">at (index)</dt>
        <dd>
          <p>Similar to <a href="#sqimitivei-slice">slice()</a> but returns individual children, not an array.</p>

          <pre class="language-javascript">
sqim.at(0)         //=> Sqimitive
sqim.at(999)       //=> undefined
sqim.at(-1)        //=> Sqimitive - identical to last()
</pre>
        </dd>

        <dt id="sqimitivei-assignChildren">assignChildren (resp[, options])</dt>
        <dd>
          <p>Merges external "response" object/array <b>resp</b> into <a href="#sqimitivei-_children">_children</a> by updating existing nested sqimitives, adding new and removing unlisted ones. New sqimitives are created as <a href="#sqimitivei-_childClass">_childClass</a>.</p>

          <p>If <b>resp</b> is an object with <kbd>data</kbd> key – uses its value (Python’s Flask wraps array response into an object to prevent a JS attack). If <b>resp</b> (or <b>resp.data</b>) were not arrays uses <kbd>_.values()</kbd> to turn it into one (ignoring keys).</p>

          <p>If <b>options.eqFunc</b> is <kbd>null</kbd> or omitted removes all children thus resetting the list. <b>options.eqFunc</b> can be a string (option name) given to <a href="#sqimitivei-get">get()</a>, or a <kbd>function (existingSqim, {opt})</kbd> returning <kbd>true</kbd> if <b>existingSqim</b> is the "same" as given <b>opt</b> object (a <b>resp</b> item) so the former should be retained and updated with <a href="#sqimitivei-assignResp">assignResp()</a>. Children that have never matched <b>options.eqFunc</b> considered not listed in given resp and removed unless <b>options.keepMissing</b> is set (if so they are just left unchanged).</p>

          <p>If <b>options.keepMissing</b> is set while <b>options.eqFunc</b> is not – existing children are preserved and for each item in <b>resp</b> a new child is nested. Be aware that on duplicate keys (see <b>options.keyFunc</b>) only the last child will be kept, all others will be removed.</p>

          <p><b>options.keyFunc</b> is a <kbd>function (sqim)</kbd> that should return a <a href="#sqimitivei-_parentKey">_parentKey</a> for given sqimitive that is about to be <a href="#sqimitivei-nest">nest()</a>'ed. If not present defaults to <a href="#sqimitivei-_defaultKey">_defaultKey</a> (returns <a href="#corei-_cid">_cid</a> by default).</p>

          <p><b>options</b> as a whole is passed through to <a href="#sqimitivei-assignResp">assignResp()</a> and <a href="#sqimitivei-nest">nest()</a> so you can use it to set their options and to pass custom data along to your event listeners as they are eventually passed through to <a href="#sqimitivei-set()">set()</a>, <a href="#sqimitivei-change_OPT">change_OPT()</a> and others.</p>

          <p>There’s no standard <b>assignChildren()</b> version that takes ready-made objects (like Backbone’s <kbd>Collection.set()</kbd>) because many questions arise: do you need to keep old duplicate children or replace them with supplied objects and what to do with event listeners on the old children if you do, or with listeners on the new if you don't, what to consider "duplicate" (some ID attribute? exact same object?), do you want to keep old attributes, etc. Instead of making Sqimitive figure them you should just do exactly what you need.</p>

          <p>To demonstrate most common cases:</p>

          <pre class="language-javascript">
assignChildren({data: [ {key: 'foo'}, {key: 'bar'} ]}, {eqFunc: 'key'})
  // inputs 2 children with _opt = {key: foo} and {key: bar};
  // "same" sqimitives are those having the same 'key' option.

assignChildren({data: [ {key: 'foo'}, {key: 'bar'} ]},
               {eqFunc: function (sqim, opt) { return sqim._opt.key == opt.key }})
  // identical to the above.

assignChildren([ {key: 'foo'}, {key: 'bar'} ], {eqFunc: 'key'})
  // identical to the above (resp not wrapped in 'data').

assignChildren({ foosh: {key: 'foo'}, barrsh: {key: 'bar'} }, {eqFunc: 'key'})
  // identical to the above (resp turned to array, keys ignored).

assignChildren({ foosh: {key: 'foo'}, barrsh: {key: 'bar'} }, {eqFunc: 'key', keepMissing: true})
  // identical to the above but keeps old children.

assignChildren([ {key: 'foo'}, {key: 'bar'} ])
  // similar but removes all nested sqimitives and adds 2 new ones.

assignChildren(..., {onlyDefined: true, forceFire: true})
  // passes onlyDefined to assignResp() and forceFire - to set()
</pre>

          <p>A complete example:</p>

          <pre class="language-javascript">
var MyList = Sqimitive.Sqimitive.extend({)

var MyItem = Sqimitive.Sqimitive.extend({
  _opt: {
    foo: '',
  },
})

var list = new MyList
var item1 = new MyItem({foo: 'first'})
list.nest(item1)
var resp = [{foo: 'incoming#1'}, {foo: 'first'}]

list.assignChildren(resp)
  // item1 was removed from list, which in turn got two new items:
  // 'incoming#1' and 'first' (the latter having identical _opt with the
  // removed item but being a newly created and nested object still).

// Let's restore the list.
list.invoke('remove').nest(item1)

list.assignChildren(resp, {eqFunc: function (sqim, opt) { return sqim.get('foo') == opt.foo }})
  // Now item1 wasn't removed because the function we passed compared its foo
  // option with resp's foo value and got a match. In addition to item1, list
  // got one new item - 'incoming#1'.

// But we could have used this short form too if we're simply matching some
// option with the same member in resp:
list.assignChildren(resp, {eqFunc: 'foo'})

list.assignChildren([])
  // The list was cleared as there were no items in resp.
</pre>

          <p>This method is named "assign" to emphasize that data may undergo transformations before being assigned by the sqimitive.</p>
        </dd>

        <dt id="sqimitivei-assignResp">assignResp (resp[, options])</dt>
        <dd>
          <p>Filters and/or transforms external input (e.g. API response) into <a href="#sqimitivei-_opt">this._opt</a> using defined rules (see <a href="#sqimitivei-_respToOpt">_respToOpt</a>). Calls <a href="#sqimitivei-set">set()</a> to assign resulting values one by one, <a href="#sqimitivei-normalize_OPT">normalizing</a> them and firing corresponding <a href="#sqimitivei-change_OPT">change</a> events.</p>

          <p>If <b>options.onlyDefined</b> is set then keys in <b>resp</b> that are missing from <a href="#sqimitivei-_respToOpt">_respToOpt</a> are ignored, if it’s unset they are passed through as if they were all <kbd>true</kbd>.</p>

          <p><b>options</b> as a whole is passed through to <a href="#sqimitivei-set">set()</a> so you can use it to pass custom data along to your event listeners on <a href="#sqimitivei-normalize_OPT">normalize_OPT()</a>, <a href="#sqimitivei-change_OPT">change_OPT()</a> and <a href="#sqimitivei-change">change()</a>.</p>

          <p>Subclass can override this method to force certain value of <b>options.onlyDefined</b> like this:</p>
          <pre class="language-javascript">
var MySqimitive = Sqimitive.Sqimitive.extend({
   events: {
     // With this override any call to assignResp() will omit resp keys
     // that are not present in this._respToOpt.
     '=assignResp': function (sup, resp, options) {
        return sup(this, resp, _.extend({}, options, {onlyDefined: true}))
      },
  },
})
</pre>

          <p>Here is how this method in conjunction with <kbd>_respToOpt</kbd> can be used to blend some JSON backend response into the sqimitive:</p>
          <pre class="language-javascript">
var MyModel = Sqimitive.Sqimitive.extend({
  _opt: {
    date: new Date(0),
    id_key: 0,
  },

  _respToOpt: {
    // This will transform incoming value into a Date object.
    date: function (value, key) {
      return [key, new Date(value)]
    },

    // Pass through the value as it is.
    id_key: true,
  },

  events: {
    change_id_key: function () { ... },

    normalize_id_key: function (value) {
      value = parseInt(value)
      if (isNaN(value)) { throw 'What kind of ID is that?' }
      return value
    },
  },
})


var sqim = new MyModel

// Since regular set() is used to assign new values both normalize_id_key
// and then change_id_key are called. As a result we get clean _opt.
sqim.assignResp({date: '2000-01-01', id_key: '123', bazzz: 'Ouch!'})

sqim.get() == {date: Date('2000-01-01'), id_key: '123'}
// date was turned to Date with the transformation function in _respToOpt.
// id_key was turned to number thanks to normalize function we defined.
// bazzz was ignored because onlyDefined wasn't set.
</pre>

          <p>This method is named "assign" to emphasize that data may undergo transformations before being assigned by the sqimitive.</p>
        </dd>

        <dt id="sqimitivei-bubble">bubble (event, args, fireSelf)</dt>
        <dd>
          <p>Sends <b>event</b> with arguments <b>args</b> upstream – triggers it on <a href="#sqimitivei-_parent">this._parent</a>, then on that parent’s parent and so on. If <b>fireSelf</b> is <kbd>true</kbd> fires <b>event</b> on <b>this</b> beforehand (by default it isn't). Since it calls methods, not necessary events, you you "recursively" call methods as well. This is very much like DOM’s event bubbling except that it happens on sqimitives, not their <a href="#sqimitivei-el">el</a>’s. Returns <b>this</b>. See also <a href="#sqimitivei-sink">sink()</a> that works the opposite direction.</p>

          <pre class="language-javascript">
// Causes self and all parent sqimitives to be rendered:
sqim.bubble('render', [], true)

// Recursively call invoke('render') on all parents.
sqim.bubble('invoke', ['render'])

// We can use it to obtain data from owning sqimities too:
var out = {}
sqim.bubble('giveMeData', [out])
alert(out.data)
// The above will work if any parent has a handler like this:
parent.on('giveMeData', function (out) { out.data = 'here goes' })
</pre>
        </dd>

        <dt id="sqimitivei-sink">sink (event, args, fireSelf)</dt>
        <dd>
          <p>Propagates <b>event</b> with arguments <b>args</b> to all nested sqimitives, to all nested sqimitives of those sqimitives, to their children and so on. If <b>fireSelf</b> is true also fires <b>event</b> on <b>this</b> beforehand. Note that it might get quite intense with heavy nesting. Returns <b>this</b>. Since it calls methods, not necessary events, you you "recursively"  See also <a href="#sqimitivei-bubble">bubble()</a> that works the opposite direction.</p>

          <pre class="language-javascript">
// Recursively causes all nested views and self to be rendered.
sqim.sink('render', []. true)

// Recursively call remove() on self, all children and their children, removing
// every single sqimitive from its parent (not necessary practical, just an
// illustration).
sqim.sink('invoke', ['remove'], true)

var serialized = [];
sqim.sink('saveTo', serialized)
// Now if children implement something like this serialized will contain
// a portable representation of the current hierarchy:
child.saveTo = function (ser) { ser.push(this.get()) }
</pre>
        </dd>

        <dt id="sqimitivei-$">$ (path)</dt>
        <dd>
          <p>Similar to <kbd>this.el.find(path)</kbd> but returns <a href="#sqimitivei-el">el</a> if <b>path</b> is empty or is a dot (<kbd>.</kbd>). If <kbd>this.el</kbd> is <kbd>null</kbd> always returns an empty jQuery collection. If <b>path</b> is a jQuery object or a DOM node – returns <kbd>$(path)</kbd> (note that it may be outside of <kbd>this.el</kbd> or have <kbd>length == 0</kbd>).</p>

          <pre class="language-javascript">
sqim.$()                //=> $(this.el)
sqim.$('.')             //=> $(this.el)
sqim.$('a[href]')       //=> $([A, A, ...])
sqim.$(document.body)   //=> $('body')

sqim.el = null
sqim.$('')              //=> $()
</pre>
        </dd>
      </dl>

      <h4 id="sqimitivei-underscore">Underscore.js functions</h4>

      <p>Each <kbd>Sqimitive.Sqimitive</kbd> instance inherits a bunch of <a href="http://underscorejs.org">Underscore.js</a> functions – those used to sort, filter, transform, count, locate, cook, boil, slice up and serve <a href="#sqimitivei-nest">nested</a> children into an object or array: <kbd>sqim.invoke('render')</kbd>.</p>

      <p>The following methods are available (links will take you to Underscore.js docs in a new tab):</p>

      <ul>
        <li><a target="_blank" href="http://underscorejs.org/#chain">chain()</a> – wrap list of children into an Underscore object on which you can call other Underscore methods that will modify that list, which you can then retrieve with <kbd>sqim.chain()....().value()</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#contains">contains(sqim)</a> – return <kbd>true</kbd> if there’s a nested <b>sqim</b> instance</li>
        <li><a target="_blank" href="http://underscorejs.org/#countBy">countBy(iterator[, cx])</a> – same as <b>groupBy()</b> but returns count of children instead of lists: <kbd>{gr1: 3, seco: 1, ...}</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#difference">difference([sqim, sqim, ...])</a> – same as <b>without()</b> but accepts one or more arrays</li>
        <li><a target="_blank" href="http://underscorejs.org/#each">each(iterator[, cx])</a> – call <kbd>iterator(sqim, parentKey)</kbd> on each children</li>
        <li><a target="_blank" href="http://underscorejs.org/#every">every(predicate[, cx])</a> – return <kbd>true</kbd> if for every child <kbd>predicate(sqim, parentKey)</kbd> was positive</li>
        <li><a target="_blank" href="http://underscorejs.org/#filter">filter(predicate[, cx])</a> – return an array of all children for which <kbd>predicate(sqim, parentKey)</kbd> was positive (similar to <kbd>pick()</kbd> that returns an object)</li>
        <li><a target="_blank" href="http://underscorejs.org/#find">find(predicate[, cx])</a> – return the first child for which <kbd>predicate(sqim, parentKey)</kbd> was positive or <kbd>undefined</kbd> if none matched</li>
        <li><a target="_blank" href="http://underscorejs.org/#findWhere">findWhere(props)</a> – return the first child that have equal properties; don't use this to compare <a href="#sqimitivei-_opt">_opt</a> for the same reason as with <b>pluck()</b> above</li>
        <li><a target="_blank" href="http://underscorejs.org/#first">first()</a> – first nested child or <kbd>undefined</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#groupBy">groupBy(iterator[, cx])</a> – put each child under the object’s key named after <kbd>iterator(sqim, parentKey)</kbd> (<b>iterator</b> can be a string – property name) and return that object: <kbd>{gr1: [Sqimitive], seco: [...]}</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#indexBy">indexBy(iterator[, cx])</a> – same as <b>groupBy()</b> but for unique groups; returns <kbd>{gr1: Sqimitive, seco: Sqimitive, ...}</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#indexOf">indexOf(sqim)</a> – determine the ordinal number of <b>sqim</b> or -1 if it’s not nested</li>
        <li><a target="_blank" href="http://underscorejs.org/#initial">initial([n])</a> – all but last <b>n</b> (1) children</li>
        <li><a target="_blank" href="http://underscorejs.org/#invoke">invoke(method[, arg1, arg2, ...])</a> – call <b>method</b> on each child, giving it passed arguments, put each result into an array and return it (similar to <b>map()</b>)</li>
        <li><a target="_blank" href="http://underscorejs.org/#keys">keys()</a> – array of all childrens' <a href="#sqimitivei-_parentKey">_parentKey</a>’s</li>
        <li><a target="_blank" href="http://underscorejs.org/#last">last()</a> – last nested child or <kbd>undefined</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#lastIndexOf">lastIndexOf(sqim)</a> – same as <b>indexOf()</b> but counts from the end</li>
        <li><a target="_blank" href="http://underscorejs.org/#map">map(iterator[, cx])</a> – call <kbd>iterator(sqim, parentKey)</kbd> on each children, push result onto an array and return them</li>
        <li><a target="_blank" href="http://underscorejs.org/#max">max(iterator[, cx])</a> – rank all children by calling <kbd>iterator(sqim, parentKey)</kbd> and return the "highest" one</li>
        <li><a target="_blank" href="http://underscorejs.org/#min">min(iterator[, cx])</a> – same as <b>max()</b> but returns the "lowest" child</li>
        <li><a target="_blank" href="http://underscorejs.org/#omit">omit(key[, key, ...])</a> – the opposite of <kbd>pick()</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#pairs">pairs()</a> – array of <kbd>[parentKey, sqim]</kbd> items for all children</li>
        <li><a target="_blank" href="http://underscorejs.org/#partition">partition(predicate)</a> – split all children into two groups (first matching <b>predicate</b>, second – not); return both as an array</li>
        <li><a target="_blank" href="http://underscorejs.org/#pick">pick(key[, key, ...])</a> – all children with <a href="#sqimitivei-_parentKey">_parentKey</a>’s matching any given argument; <b>key</b> can also be a single array of keys or a <kbd>function (sqim, parentKey)</kbd> returning <b>true</b> for items to be put into result (this form is similar to <kbd>filter()</kbd> that returns an array). <b>Attention:</b> parent keys are always string; doing <kbd>sqim.pick(1)</kbd> will never return results – do <kbd>sqim.pick('1')</kbd> instead</li>
        <li><a target="_blank" href="http://underscorejs.org/#pluck">pluck(prop)</a> – picks <b>prop</b> property out of every child, push it onto an array and return them. You shouldn't use this to get <a href="#sqimitivei-_opt">_opt</a> – use <a href="#cores-picker">picker('get', 'opt')</a> and <b>map()</b>, or <a href="#sqimitivei-get">get('opt')</a> and <b>invoke()</b> instead</li>
        <li><a target="_blank" href="http://underscorejs.org/#reduce">reduce(iterator, memo[, cx])</a> – reduce the list of children to a single value by calling <kbd>iterator(memo, sqim, parentKey)</kbd></li>
        <li><a target="_blank" href="http://underscorejs.org/#reduceRight">reduceRight(iterator, memo[, cx])</a> – same as <b>reduceRight()</b> but goes from the end</li>
        <li><a target="_blank" href="http://underscorejs.org/#reject">reject(predicate[, cx])</a> – the opposite of <b>filter()</b></li>
        <li><a target="_blank" href="http://underscorejs.org/#rest">rest([n])</a> – all but first <b>n</b> (1) children</li>
        <li><a target="_blank" href="http://underscorejs.org/#sample">sample([n])</a> – return random <b>n</b> children as an array or just one as it is if <b>n</b> isn't given</li>
        <li><a target="_blank" href="http://underscorejs.org/#shuffle">shuffle()</a> – get shuffled array of children instances</li>
        <li><a target="_blank" href="http://underscorejs.org/#some">some(predicate[, cx])</a> – return <kbd>true</kbd> if for any child <kbd>predicate(sqim, parentKey)</kbd> was positive</li>
        <li><a target="_blank" href="http://underscorejs.org/#sortBy">sortBy(iterator[, cx])</a> – sort and return all children by ranking them with <kbd>iterator(sqim, parentKey)</kbd> from lowest to highest</li>
        <li><a target="_blank" href="http://underscorejs.org/#sortedIndex">sortedIndex(sqim[, iterator[, cx]])</a> – determine index for item insertion that will maintain certain list sorting</li>
        <li><a target="_blank" href="http://underscorejs.org/#toArray">toArray()</a> – return all children as an array copy – similar to <a href="#sqimitivei-nested">nested()</a> with no arguments but without keys</li>
        <li><a target="_blank" href="http://underscorejs.org/#where">where(props)</a> – return only children that have equal properties; don't use this to compare <a href="#sqimitivei-_opt">_opt</a> for the same reason as with <b>pluck()</b> above</li>
        <li><a target="_blank" href="http://underscorejs.org/#without">without(sqim[, sqim, ...])</a> – all children except those given as arguments</li>
      </ul>
    </article>

    <footer>
      <p>
        This marks the end of documentation. Now it’s time to develop the awesome!
        <a href="#">Back to top</a> ↑
      </p>
    </footer>

    <script src="jquery.js"></script>
    <script src="prism.js"></script>
    <!--script src="underscore.js"></script>
    <script src="jquery.js"></script>
    <script src="sqimitive.js"></script-->

    <script>
      $('pre[class^="language-"]').wrapInner('<code>')

      $('[id]').filter('h1,h2,h3,h4,h5,h6,dt,dd').each(function () {
        var id = $(this).attr('id')
        $('<a class="a" href="#' + id + '">¤</a>').attr('title', '#' + id).appendTo(this)
      })
    </script>
  </body>
</html>