<!DOCTYPE html>
<html data-root="../" data-entity='{"type":"class","id":909,"name":"Sqimitive.Core","start":{"line":93,"column":2,"offset":3147},"end":{"line":4257,"column":2,"offset":167299},"forced":true,"modifiers":[],"file":"main.js"}'>
  <head>
    <meta charset="utf-8">
    <title>Core (in Sqimitive) – Sqimitive</title>
    <link rel="stylesheet" href="../styles.css">
  </head>
  <body>
    <script>orphus = {action: 'https://proger.me/orphus.php'}</script>
    <script src="https://proger.me/orphus.js"></script>

    
<nav class="qnbar">
  <a href="#" class="qnbar__locate" title="Hotkey: Alt+E">&larr; Locate</a>
  <a href="#">Top</a> of Sqimitive.Core  (<a href="?noframe" target="_blank">no frame</a>)
          <a class="qnbar__section"
       title=""
       href="#Sqimitive-Core--iv">
      Properties</a>
          <a class="qnbar__section"
       title=""
       href="#Sqimitive-Core--if">
      Methods</a>
  </nav>

  <div class="cp">
    <h1 class="entity-header">
      <span class="entity-header__type">
        Class
      </span>
              <span class="entity-header__ns">
          in
          <a href="../ns_Sqimitive.html">Sqimitive</a>        </span>
            <span class="entity-header__name">
        Core      </span>
    </h1>

    <code class="code_block">class Sqimitive.Core</code>

    <div class="entity-info">
      <div class="entity-info__synopsis fmt">
        Implements inheritance and event system without any other Sqimitive
(<a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a>) functionality<span class="chemdoc__ellipsis">…</span>      </div>

      <p class="entity-info__file">
        Defined in:
        main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L94-L94" target="_blank">line 94</a>      </p>

          </div>

          <fieldset class="cp-desc fmt">
        <legend>
          Description
          (<a href="#Sqimitive-Core--de">skip</a>)
        </legend>
        <p>Implements inheritance and event system without any other Sqimitive
(<a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a>) functionality.</p><p>In a typical scenario you don’t need to use <a href="../Sqimitive/c_Core.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">Core</a> directly – use
<code>Sqimitive.Base</code> instead.</p><p>In special cases, since <code class="chemdoc__id">Core</code> lacks any specialized functionality it can
be used as a base class for your classes that need better inheritance
and/or events (like a more elaborate alternative to
<a href="https://github.com/primus/eventemitter3" class="chemdoc__custom-link chemdoc__proto-https" target="_blank">https://github.com/primus/eventemitter3</a>)…
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyEventAwareClass = Sqimitive.Core.extend({
  doFoo: function () {
    this.fire('beforeFoo', ['arg', 'arg'])
    // ...
    this.fire('afterFoo', ['...'])
  }
})

// Now clients can subscribe to its events:
myEventAwareObject.on('beforeFoo', function () {
  alert('Boo!')
})

// ...

myEventAwareObject.doFoo()    //=&gt; Boo!</code></pre></p><p>…Or as an instance object held in an internal property if you want to
avoid exposing any Sqimitive functionality at all:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyEventAwareClass = function () {
  var _events = new Sqimitive.Core

  this.on   = function() { _events.on.apply(_events, arguments) }
  this.off  = function() { _events.off.apply(_events, arguments) }
  this.fire = function() { _events.fire.apply(_events, arguments) }

  // Just like in the above example:
  this.doFoo = function () { ... }
}

myEventAwareObject.on('beforeFoo', ...)
myEventAwareObject.doFoo()</code></pre></p>      </fieldset>
      <a id="Sqimitive-Core--de"></a>
    
            <h2 id="Sqimitive-Core--iv"
            class="cp-member__group-header">
          Properties        </h2>
        <dl>
                      <dt id="Sqimitive-Core--sv_mergeProps"
                data-entity='{"type":"var","id":916,"name":"_mergeProps","start":{"line":429,"column":4,"offset":15651},"end":null,"forced":null,"modifiers":["static","protected"],"file":"main.js"}'
                class="cp-member__header">
              <b>_mergeProps</b>
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  protected, static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Extension" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Extension</a></p><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-setOnDeclViaPush" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">setOnDeclViaPush</a></span></p><p><b>May only be set after <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">Core::extend()</a> using <code>MyClass.prop.push(...)</code>.</b></p><p>Specifies which instance properties are to be merged rather than
overwritten when redefined in a subclass.</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Value Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>array of string </td><td rowspan="1" colspan="1"> Property names.</td></tr></table><p>Properties must be of these types:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Members</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">array</th><td rowspan="1" colspan="2"> Merged using <code>Array.concat(baseClass[prop],
childClass[prop])</code>. Subclass’ values are added after parents’ values:
<code>['a', 'b'] + ['c'] = ['a', 'b', 'c']</code>.</td></tr><tr class="chemdoc__first"><th rowspan="1">object</th><td rowspan="1" colspan="2"> Merged using <code>_.extend(baseClass[prop], childClass[prop])</code>.
Keys defined in parents are kept unless also defined in a subclass:
<code>{a: 1, b: 2} + {a: 3, c: 4} = {a: 3, b: 2, c: 4}</code>.</td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var MyParent = Sqimitive.Base.extend({
  _objectProperty: {key1: 'value1', key2: 'value2'},
  _arrayProperty: ['item1', 'item2'],
})

MyParent._mergeProps.push('_objectProperty', '_arrayProperty')

var MyChild = MyParent.extend({
  _objectProperty: {key2: 'CHILD1', key3: 'CHILD2'},
  _arrayProperty: ['item3', 'item4'],
})

// MyChild._objectProperty is now
// {key1: 'value1', key2: 'CHILD1', key3: 'CHILD2'}

// MyChild._arrayProperty is now ['item1', 'item2', 'item3', 'item4']</code></pre></fieldset><p><a id="-mergePropsExtend" class="chemdoc__anchor chemdoc__anchor_token" href="#-mergePropsExtend">mergePropsExtend</a><b>Warning:</b> when passing <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> or <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a> inside
<code class="chemdoc__id">staticProps</code> (second argument of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) all inherited items will be
removed. The correct way to add your properties while keeping those in
the base classes is this:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqimitive = Sqimitive.Base.extend({
  // Define instance fields...
}, {
  // Define static fields if you need, else don't pass this parameter.
})

// extend() has copied the inherited _mergeProps list which we can now
// append to or modify using regular Array functions.
MySqimitive._mergeProps.push('prop1', 'prop2', ...)
// Same with _shareProps.
MySqimitive._shareProps.push('prop1', 'prop2', ...)</code></pre></p><p>These are <b>wrong</b> ways to append to these properties:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqimitive = Sqimitive.Base.extend({
  // WRONG: _mergeProps is static so it won't be read from here.
  _mergeProps: ['prop'],
}, {
  // WRONG: technically fine but will entirely replace base class'
  // merge list.
  _mergeProps: ['prop'],
})

// WRONG: works but once again will replace all the inherited items.
MySqimitive._mergeProps = ['prop']

// CORRECT:
MySqimitive._mergeProps.push('prop')</code></pre></p><p>Other notes:</p><ul><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> always clones <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a>.</li><li>By default, <a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a> class adds <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_opt" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">Base._opt</a>, <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a> and
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_respToOpt" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_respToOpt</a> to this list.</li><li>See instance <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.mixIn()</a> for the implementation.</li><li>Removing a parent-of-parent’s property from <code class="chemdoc__id">_mergeProps</code> doesn’t
“un-merge” it since merging happens in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a>) so after
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> the new class already has merged properties of all of its
ancestors. However, removal does affect new subclasses: <pre><code class="chemdoc__block prism language-javascript match-braces">var ClassA = Sqimitive.Base.extend({array: ['in A']})
ClassA._mergeProps.push('array')
  // (new ClassA).array is ['in A']

var ClassB = ClassA.extend({array: ['in B']})
  // (new ClassB).array is ['in A', 'in B']

var ClassC = ClassB.extend({array: ['in C']})
ClassC._mergeProps = []
  // (new ClassC).array is ['in A', 'in B', 'in C']

var ClassD = ClassC.extend({array: ['in D']})
  // (new ClassD).array is ['in D'] - not merged!</code></pre></li></ul><h3 id="A347eefa230" class="chemdoc__h1">Complex inherited value modification</h3><p><code class="chemdoc__id">_mergeProps</code> doesn’t allow deleting members or otherwise changing the
value. However, in some contexts <code class="chemdoc__id">null</code> or <code class="chemdoc__id">undefined</code> does the job for
objects (in contrast with <code class="chemdoc__id">delete</code> such properties still appear when
using <code>for..in</code>, etc.):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyParent = Sqimitive.Base.extend({
  _objectProperty: {key1: 'value1', key2: 'value2'},
})

MyParent._mergeProps.push('_objectProperty')

var MyChild = MyParent.extend({
  _objectProperty: {key1: null},
})

// MyChild._objectProperty is now {key1: null, key2: 'value2'}

for (var key in new MyChild) { alert(key) }
  //=&gt; key1
  //=&gt; key2</code></pre></p><p>Use <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifinit" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.init()</a> or <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifpostInit" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">postInit()</a> to modify inherited values in other
ways:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyParent = Sqimitive.Base.extend({
  _objectProperty: {key1: 'value1', key2: 'value2'},
})

var MyChild = MyParent.extend({
  events: {
    init: function () {
      // MyParent's _objectProperty is unaffected, see _shareProps.
      delete this._objectProperty.key1
      this._objectProperty.key2 += 'foo'
    },
  },
})

// MyChild._objectProperty is now {key2: 'value2foo'}

for (var key in new MyChild) { alert(key) }
  //=&gt; key2</code></pre></p><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-inBB" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">inBB</a></span></p><h3 id="A3afe424096" class="chemdoc__h0">In Backbone…</h3><p>In Backbone, when you extend a parent class with a property that it
already has you end up with a completely new property. This doesn’t
always make sense – for example, if a class has its own
<a href="https://backbonejs.org/#View-events" class="chemdoc__custom-link chemdoc__proto-bb" target="_blank">bb:View-events</a> then what you really need is merge its own (base)
events with the events of new subclass. Same thing with
<a href="https://backbonejs.org/#Model-attributes" class="chemdoc__custom-link chemdoc__proto-bb" target="_blank">bb:Model-attributes</a> and <a href="https://backbonejs.org/#Model-defaults" class="chemdoc__custom-link chemdoc__proto-bb" target="_blank">bb:Model-defaults</a>, <a href="https://backbonejs.org/#Router-routes" class="chemdoc__custom-link chemdoc__proto-bb" target="_blank">bb:Router-routes</a>
and others. Example (<a href="http://jsfiddle.net/Proger/u2n3e6ex/" class="chemdoc__custom-link chemdoc__proto-http" target="_blank">http://jsfiddle.net/Proger/u2n3e6ex/</a>):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyView = Backbone.View.extend({
  events: {
    'click .me': function () { alert('You clicked it!') },
  },
})

var MyOtherView = MyView.extend({
  // This object entirely replaces MyView's event map.
  events: {
    'keypress .me': function () {
      alert('Oh noes, we broke the button :(')
    },
  },
})</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sv_mergeProps---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L430-L430" target="_blank">line 430</a>                                  &bull; <a href="#Sqimitive-Core--sv_mergeProps---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">_mergeProps: [],</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sv_shareProps"
                data-entity='{"type":"var","id":917,"name":"_shareProps","start":{"line":504,"column":4,"offset":18435},"end":null,"forced":null,"modifiers":["static","protected"],"file":"main.js"}'
                class="cp-member__header">
              <b>_shareProps</b>
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  protected, static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Extension" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Extension</a></p><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-setOnDeclViaPush" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">setOnDeclViaPush</a></span></p><p><b>May only be set after <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">Core::extend()</a> using <code>MyClass.prop.push(...)</code>.</b></p><p>Specifies which instance properties are not to be cloned upon
construction. They will be shared by all instances of a class (where the
property was defined, i.e. where given to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>).</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Value Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>array of string </td><td rowspan="1" colspan="1"> Property names.</td></tr></table><p>Unlisted instance properties are cloned (using <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a>) upon new
object instantiation (in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor</a>). If using a complex object
(<code class="chemdoc__id">Date</code>, <code class="chemdoc__id">Node</code>, etc. – not just <code>{}</code>) then assign it in
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifinit" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.init()</a> or <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifpostInit" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">postInit()</a>. If using an instance property as if it
were static, either list it in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a> or move to <code class="chemdoc__id">staticProps</code>
(<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) and access as <code>this.constructor.foo</code> (yes, JavaScript
makes it pretty inconvenient).</p><fieldset class="chemdoc__example"><legend>Example</legend>One particular case when the default cloning causes problem is when you
are assigning “classes” to properties – recursive copying of such a
value not just breaks it (<code>MyClass === myObj._model</code> no longer works)
but is also very heavy.<p>Either use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a>…
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyView = Sqimitive.Base.extend({
  _model: MyApp.MyModel,
})

// _shareProps is a static property.
MyView._shareProps.push('_model')</code></pre></p><p>…Or assign the value after instantiation, which is less declarative:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyView = Sqimitive.Base.extend({
  _model: null,   // MyApp.MyModel¹

  events: {
    init: function () {
      this._model = MyApp.MyModel
    },
  },
})</code></pre></p><div class="chemdoc__indent"><p>¹ It’s customary in Sqimitive to leave a comment with the type’s
name next to such property.</p></div></fieldset><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-mergePropsExtend" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">mergePropsExtend</a></span></p><p><b>Warning:</b> when passing <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> or <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a> inside
<code class="chemdoc__id">staticProps</code> (second argument of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) all inherited items will be
removed. The correct way to add your properties while keeping those in
the base classes is this:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqimitive = Sqimitive.Base.extend({
  // Define instance fields...
}, {
  // Define static fields if you need, else don't pass this parameter.
})

// extend() has copied the inherited _mergeProps list which we can now
// append to or modify using regular Array functions.
MySqimitive._mergeProps.push('prop1', 'prop2', ...)
// Same with _shareProps.
MySqimitive._shareProps.push('prop1', 'prop2', ...)</code></pre></p><p>These are <b>wrong</b> ways to append to these properties:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqimitive = Sqimitive.Base.extend({
  // WRONG: _mergeProps is static so it won't be read from here.
  _mergeProps: ['prop'],
}, {
  // WRONG: technically fine but will entirely replace base class'
  // merge list.
  _mergeProps: ['prop'],
})

// WRONG: works but once again will replace all the inherited items.
MySqimitive._mergeProps = ['prop']

// CORRECT:
MySqimitive._mergeProps.push('prop')</code></pre></p><p>Other notes:</p><ul><li>By default, <a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a> class adds <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> to this list.</li><li>See instance <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.mixIn()</a> for the implementation.</li></ul><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-inBB" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">inBB</a></span></p><h3 id="A3afe424096" class="chemdoc__h0">In Backbone…</h3><p>In Backbone, values of all properties inherited by a subclass are shared
among all instances of the base class where they are defined. Just like
in Python, if you have <code>...extend( {array: []} )</code> then doing
<code>this.array.push(123)</code> will affect all instances where <code class="chemdoc__id">array</code> wasn’t
overwritten with a new object. This poses a typical problem in day-to-day
development.</p><p>Example (<a href="http://jsfiddle.net/Proger/vwqk67h8/" class="chemdoc__custom-link chemdoc__proto-http" target="_blank">http://jsfiddle.net/Proger/vwqk67h8/</a>):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyView = Backbone.View.extend({foo: {}})
var x = new MyView
var y = new MyView
x.foo.bar = 123
alert(y.foo.bar)</code></pre></p><p>Can you guess the alert message? It’s <code class="chemdoc__id">123</code>!</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sv_shareProps---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L505-L505" target="_blank">line 505</a>                                  &bull; <a href="#Sqimitive-Core--sv_shareProps---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">_shareProps: [],</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--svlastFired"
                data-entity='{"type":"var","id":915,"name":"lastFired","start":{"line":252,"column":4,"offset":9134},"end":null,"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>lastFired</b>
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Holds recently <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a>’d event hooks (cloned <code class="chemdoc__id">eobj</code>-s with <code class="chemdoc__id">self</code> set to
call context) if <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a> is on.</p><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-trc" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">trc</a></span></p><p>Sometimes you find yourself wondering why a hook was called or who caused
a property to be updated. Given that hooks often point to generic
functions or that <code class="chemdoc__id">_opt</code> changes are <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed, finding initiators can
be a tricky business.</p><p>Effects of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a>:</p><ul><li>Every sqimitive stores <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor()</a>-time stack trace in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.trace</a></li><li>Last bunch of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a>’d event hooks is recorded under <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svlastFired" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">lastFired</a> (in
form of their <code class="chemdoc__id">eobj</code>, cloned, with <code class="chemdoc__id">self</code> set to call context)</li><li>Objects of <code class="chemdoc__id">_events</code> (<code class="chemdoc__id">eobj</code>) hold stack trace of their registration
(<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) under <code class="chemdoc__id">trace</code></li><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed events receive new <code class="chemdoc__id">trace</code> field in <code class="chemdoc__id">options</code>, along with
<code class="chemdoc__id">batchID</code> and others</li><li>Various wrapper functions (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a>, etc.) store
their arguments under <code class="chemdoc__id">trace</code></li></ul><p>All added properties are meant for inspection in debugger.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var sq1 = new Sqimitive.Core
alert(sq1.trace)      //=&gt; undefined
Sqimitive.Core.trace = true
var sq2 = new Sqimitive.Core
alert(sq2.trace)      //=&gt; 'Error\n  at ...'</code></pre></fieldset><p>Note: setting <code class="chemdoc__id">trace</code> on subclasses of <code class="chemdoc__id">Core</code> will have no effect.</p><p>By default, Chrome limits trace depth to 10 which usually prevents you
from seeing actually important frames. One way to increase it is:
<pre><code class="chemdoc__block prism language-javascript match-braces">Error.stackTraceLimit = 100</code></pre></p><p>Other ways: <a href="https://stackoverflow.com/questions/9931444" class="chemdoc__custom-link chemdoc__proto-https" target="_blank">https://stackoverflow.com/questions/9931444</a>.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--svlastFired---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L253-L253" target="_blank">line 253</a>                                  &bull; <a href="#Sqimitive-Core--svlastFired---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">lastFired: [],</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--svtrace"
                data-entity='{"type":"var","id":914,"name":"trace","start":{"line":246,"column":4,"offset":8974},"end":null,"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>trace</b>
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Enables tracing of certain events to aid in debugging. Can be changed on
run-time.</p><p><a id="-trc" class="chemdoc__anchor chemdoc__anchor_token" href="#-trc">trc</a>Sometimes you find yourself wondering why a hook was called or who caused
a property to be updated. Given that hooks often point to generic
functions or that <code class="chemdoc__id">_opt</code> changes are <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed, finding initiators can
be a tricky business.</p><p>Effects of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a>:</p><ul><li>Every sqimitive stores <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor()</a>-time stack trace in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.trace</a></li><li>Last bunch of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a>’d event hooks is recorded under <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svlastFired" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">lastFired</a> (in
form of their <code class="chemdoc__id">eobj</code>, cloned, with <code class="chemdoc__id">self</code> set to call context)</li><li>Objects of <code class="chemdoc__id">_events</code> (<code class="chemdoc__id">eobj</code>) hold stack trace of their registration
(<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) under <code class="chemdoc__id">trace</code></li><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed events receive new <code class="chemdoc__id">trace</code> field in <code class="chemdoc__id">options</code>, along with
<code class="chemdoc__id">batchID</code> and others</li><li>Various wrapper functions (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a>, etc.) store
their arguments under <code class="chemdoc__id">trace</code></li></ul><p>All added properties are meant for inspection in debugger.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var sq1 = new Sqimitive.Core
alert(sq1.trace)      //=&gt; undefined
Sqimitive.Core.trace = true
var sq2 = new Sqimitive.Core
alert(sq2.trace)      //=&gt; 'Error\n  at ...'</code></pre></fieldset><p>Note: setting <code class="chemdoc__id">trace</code> on subclasses of <code class="chemdoc__id">Core</code> will have no effect.</p><p>By default, Chrome limits trace depth to 10 which usually prevents you
from seeing actually important frames. One way to increase it is:
<pre><code class="chemdoc__block prism language-javascript match-braces">Error.stackTraceLimit = 100</code></pre></p><p>Other ways: <a href="https://stackoverflow.com/questions/9931444" class="chemdoc__custom-link chemdoc__proto-https" target="_blank">https://stackoverflow.com/questions/9931444</a>.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--svtrace---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L247-L247" target="_blank">line 247</a>                                  &bull; <a href="#Sqimitive-Core--svtrace---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">trace: false,</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--iv_cid"
                data-entity='{"type":"var","id":945,"name":"_cid","start":{"line":1671,"column":4,"offset":62603},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"}'
                class="cp-member__header">
              <b>_cid</b>
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  protected                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-readOnly" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">readOnly</a></span></p><p><b>May only be read, not changed.</b></p><p>An identifier of this object. Unique among all instances of
<code>Sqimitive.Core</code> or its subclasses created during this session (page
load).</p><p>Currently begins with “p” for “primitive” followed by a positive number
as generated by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique()</a>. This is unlikely to change but in any case
it’s guaranteed to remain a valid identifier of only Latin symbols, i.e.
begin with a letter followed by zero or more letters, digits and
underscores.</p><p>Can be used to namespace DOM events as in <code>this.el.on('click.' +
this._cid)</code> (<a href="../Sqimitive/c_jQuery.html#Sqimitive-jQuery--ifattach" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="882 chemdoc__link-entity-cur">jQuery.attach()</a> does this).</p><p>Historically “cid” stands for “<code>c</code>lient <code>id</code>entifier” – a term
originating from Backbone (<a href="https://backbonejs.org/#Model-cid" class="chemdoc__custom-link chemdoc__proto-bb" target="_blank">bb:Model-cid</a>) but probably not holding
much meaning at this point.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">;(new Sqimitive.Core)._cid      //=&gt; 'p1'
;(new Sqimitive.Base)._cid      //=&gt; 'p2'
;(new Sqimitive.Core)._cid      //=&gt; 'p3'
;(new Sqimitive.jQuery)._cid    //=&gt; 'p4'</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--iv_cid---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1672-L1672" target="_blank">line 1672</a>                                  &bull; <a href="#Sqimitive-Core--iv_cid---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">_cid: '',</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ivevents"
                data-entity='{"type":"var","id":946,"name":"events","start":{"line":1675,"column":4,"offset":62643},"end":{"line":1697,"column":4,"offset":63478},"forced":true,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>events</b>
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>There is no such property per se but this key can be passed to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>
and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> to set up new event handlers of a “subclass”.</p><p>Giving <code class="chemdoc__id">events</code> is the same as calling <code>this.on({events})</code> after
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>/<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> so see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> (with an object argument) for details.</p><p>Since in Sqimitive everything is an event (<a href="../p_ov.html#-evt" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">evt</a>) this is the way you do
inheritance, override methods, etc. Such events are “fused” into the new
class declaration so there is no overhead of applying them on each class
instantiation.</p><p>See the Events overview (<a href="../p_ov.html#-evt" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">evt</a>) for examples.</p><p class="chemdoc__anchor-inclusion"><span>from <a href="../p__7ibvkbid.html#-es6thiswarn" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">es6thiswarn</a></span></p><p>Warning: avoid using ES6 arrow functions as handlers due to their fixed <code class="chemdoc__id">this</code> (<a href="../Sqimitive/c_Core.html#-es6this" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">es6this</a>).</p><p>P.S: again, <code class="chemdoc__id">events</code> is private to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>/<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> and does not
become <code>this.events</code>.</p></div>
                                          <p class="cp-member__file "
                 id="Sqimitive-Core--ivevents---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1676-L1676" target="_blank">line 1676</a>                              </p>
                          </dd>
                      <dt id="Sqimitive-Core--ivtrace"
                data-entity='{"type":"var","id":911,"name":"trace","start":{"line":153,"column":19,"offset":5277},"end":null,"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>trace</b>
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p>Stores the stack trace at the time this instance was <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor</a>’ed, if
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a> was on.</p><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-trc" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">trc</a></span></p><p>Sometimes you find yourself wondering why a hook was called or who caused
a property to be updated. Given that hooks often point to generic
functions or that <code class="chemdoc__id">_opt</code> changes are <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed, finding initiators can
be a tricky business.</p><p>Effects of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a>:</p><ul><li>Every sqimitive stores <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor()</a>-time stack trace in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.trace</a></li><li>Last bunch of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a>’d event hooks is recorded under <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svlastFired" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">lastFired</a> (in
form of their <code class="chemdoc__id">eobj</code>, cloned, with <code class="chemdoc__id">self</code> set to call context)</li><li>Objects of <code class="chemdoc__id">_events</code> (<code class="chemdoc__id">eobj</code>) hold stack trace of their registration
(<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) under <code class="chemdoc__id">trace</code></li><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed events receive new <code class="chemdoc__id">trace</code> field in <code class="chemdoc__id">options</code>, along with
<code class="chemdoc__id">batchID</code> and others</li><li>Various wrapper functions (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a>, etc.) store
their arguments under <code class="chemdoc__id">trace</code></li></ul><p>All added properties are meant for inspection in debugger.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var sq1 = new Sqimitive.Core
alert(sq1.trace)      //=&gt; undefined
Sqimitive.Core.trace = true
var sq2 = new Sqimitive.Core
alert(sq2.trace)      //=&gt; 'Error\n  at ...'</code></pre></fieldset><p>Note: setting <code class="chemdoc__id">trace</code> on subclasses of <code class="chemdoc__id">Core</code> will have no effect.</p><p>By default, Chrome limits trace depth to 10 which usually prevents you
from seeing actually important frames. One way to increase it is:
<pre><code class="chemdoc__block prism language-javascript match-braces">Error.stackTraceLimit = 100</code></pre></p><p>Other ways: <a href="https://stackoverflow.com/questions/9931444" class="chemdoc__custom-link chemdoc__proto-https" target="_blank">https://stackoverflow.com/questions/9931444</a>.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ivtrace---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L154-L154" target="_blank">line 154</a>                                  &bull; <a href="#Sqimitive-Core--ivtrace---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">Core.trace && (this.trace = (new Error).stack)</code></pre>
                          </dd>
                  </dl>
            <h2 id="Sqimitive-Core--if"
            class="cp-member__group-header">
          Methods        </h2>
        <dl>
                      <dt id="Sqimitive-Core--sfbatchGuard"
                data-entity='{"type":"func","id":943,"name":"batchGuard","start":{"line":1559,"column":4,"offset":58942},"end":{"line":1603,"column":4,"offset":60302},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>batchGuard</b>
                              (
                  index, func [, options]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Options" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Options</a></p><p>Returns a function for use as a <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> or compatible hook that calls
<code class="chemdoc__id">func</code> only once per <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a> (<code class="chemdoc__id">batchID</code>).</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>function returning <code class="chemdoc__id">undefined</code> if skipping <code class="chemdoc__id">func</code> due to <code class="chemdoc__id">batchID</code></td><td rowspan="1" colspan="1"></td></tr></table><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="2">index</th><td>int index in returned function’s arguments of the <code class="chemdoc__id">options</code> object
with <code class="chemdoc__id">batchID</code> key (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_batchOptions" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_batchOptions()</a>)</td><td rowspan="2" colspan="1"></td></tr><tr><td> str calculate by pattern: <code class="chemdoc__id">c</code>
(for <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a>) or <code class="chemdoc__id">c_</code> (for <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange_OPT" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change_OPT</a>) preceded by any number of
<code>. + =</code> (event prefixes <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a> that prepend extra arguments)</td></tr><tr class="chemdoc__first"><th rowspan="1">func</th><td rowspan="1" colspan="2"> Subject to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a></td></tr><tr class="chemdoc__first"><th rowspan="2">options</th><td>missing</td><td rowspan="2" colspan="1"></td></tr><tr><td> object</td></tr></table><p>Possible <code class="chemdoc__id">options</code> keys (all optional):</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">seen</th><td>Set </td><td rowspan="1" colspan="1"> Give the same value in <code class="chemdoc__id">seen</code> (or the same <code class="chemdoc__id">options</code> object)
to link several <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard</a>-s together (to call <code class="chemdoc__id">func</code> once across all
guards, not once per guard). you can set <code class="chemdoc__id">seen</code> to a <code class="chemdoc__id">Set</code> or give <code>{}</code>
to the first <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> and then read the value it has written to
this key. Treat <code class="chemdoc__id">Set</code> as a blackbox (it conceals multiple nuances
explained in <a href="../Sqimitive/c_Core.html#-skb" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">skb</a>).</td></tr><tr class="chemdoc__first"><th rowspan="1">cx</th><td>object </td><td rowspan="1" colspan="1"> If not given then context is unchanged.</td></tr><tr class="chemdoc__first"><th rowspan="1">skip</th><td>function </td><td rowspan="1" colspan="1"> Called when skipping a <code class="chemdoc__id">seen</code> batch. Useful when
figuring why <code class="chemdoc__id">func</code> isn’t getting called when it should be.</td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">function titleChanged(task, now) {
  console.log('New title of ' + task._cid + ' is ' + now)
}

tasks.on('.change_title', Sqimitive.Core.batchGuard('.c_', titleChanged))
tasks.on('.change_title', Sqimitive.Core.batchGuard(3, titleChanged))</code></pre></fieldset><p>Do not use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> in class declaration (functions given to
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) unless you want all instances of the class to share the same
guard:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Class = Sqimitive.Core.extend({
  events: {
    change: batchGuard(0, () =&gt; alert('Called')),
  },
})
var o1 = new Class
var o2 = new Class
o1.batch([o2], function () {
  o1.set('foo', 123)    // alerts
  o2.set('foo', 123)    // doesn't
})</code></pre></p><p>Instead, assign such a property or hook in <code class="chemdoc__id">init</code>:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Class = Sqimitive.Core.extend({
  events: {
    init: function () {
      this.fuse('change', batchGuard(...))
    },
  },
})</code></pre></p><p>Remember that <code class="chemdoc__id">func</code> is called once per batch, not per batch per object.
This matters if using <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> to handle events originating from
different objects:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Collection = Sqimitive.Base.extend({
  _childEvents: ['change'],
})
var col = new Collection
col.on('.change', batchGuard('.c', function ...))
var child1 = col.nested(1)
var child2 = col.nested(2)
child1.batch([child2], function () {
  child1.set('foo', 1)
  child2.set('bar', 2)
})</code></pre></p><p>In the above example, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> calls <code class="chemdoc__id">func</code> just once and <code class="chemdoc__id">options</code>
that <code class="chemdoc__id">func</code> receives may come from either of the batched sqimitives which
means <code>options.batch</code> is arbitrary and does not list all queued events
(it has either <code class="chemdoc__id">change_foo</code> or <code class="chemdoc__id">change_bar</code>). In case multiple origins
are possible, instead of <code class="chemdoc__id">batch</code> read <code>options.batched[i][1]</code> – but
only process objects (<code>...[0]</code>) that you expect:
<pre><code class="chemdoc__block prism language-javascript match-braces">col.on('.change', batchGuard('.c', function (child, name, now, old, options) {
  // WRONG:
  options.batch.forEach(...)
}))
col.on('.change', batchGuard(4, function (child, name, now, old, options) {
  // WRONG:
  options.batched.forEach(function ([child, batch]) {
    batch.forEach(...)
  })
}))
col.on('.change', batchGuard('.c', function (child, name, now, old, options) {
  // CORRECT:
  options.batched.forEach(function ([child, batch]) {
    if (col.nested(child)) {    // or: child instanceof ..., etc.
      batch.forEach(...)
    }
  })
}))</code></pre></p><p>Checking objects is important because a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a> may include unrelated
sqimitives:
<pre><code class="chemdoc__block prism language-javascript match-braces">child1.batch([child2, unrelated], function () {
  child1.set('foo', 1)
  child2.set('bar', 2)
  unrelated.set('quux', 3)  // not part of col, must ignore in our guard
})</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfbatchGuard---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1560-L1604" target="_blank">lines 1560-1604</a> (45 lines)                                  &bull; <a href="#Sqimitive-Core--sfbatchGuard---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">batchGuard: function (index, func, options) {
  if (typeof index == 'string') {
    if (!index.match(/^[.+=]*c_?$/)) {
      throw new Error('batchGuard: Invalid index: ' + index)
    }
    // function ([...] [name,] now, old, options)
    index = index.length + (_.last(index) == '_' ? 0 : 2)
  }

  options || (options = {})
  func = Core.expandFunc(func, options.cx)
  var seen = options.seen || (options.seen = new Set)
  var unique = Core.unique('bg') + 'bg'

  function batchGuard_() {
    var eventOptions = arguments[index]
    var id = eventOptions.batchID

    if (!id) {
      throw new Error('batchGuard: No batchID in ' + index)
    }

    if (seen.size == seen.add(id).size) {
      options.skip && options.skip.apply(options.cx || this, arguments)
    } else {
      var event = unique + id
      var remaining = 0

      _.forEach(eventOptions.batched, function (item) {
        if (item[1].length) {
          remaining++
          item[1].push([event])
          item[0].once(event, function () {
            --remaining || seen.delete(id)
          })
        }
      })

      return func.apply(this, arguments)
    }
  }

  Core.trace && (batchGuard_.trace = arguments)
  return batchGuard_
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfdeepClone"
                data-entity='{"type":"func","id":926,"name":"deepClone","start":{"line":1173,"column":4,"offset":44203},"end":{"line":1186,"column":4,"offset":44539},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>deepClone</b>
                              (
                  obj                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Returns a version of the argument with recursively-copied arrays and <code>{}</code>
objects so that any modification to either <code class="chemdoc__id">obj</code> or the returned value
(<code class="chemdoc__id">obj</code>’s copy) won’t affect its counterpart.</p><p><a id="-deepclonebase" class="chemdoc__anchor chemdoc__anchor_token" href="#-deepclonebase">deepclonebase</a><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a> is used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">Core.constructor</a> to copy non-shared
properties (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a>). Think of it as of recursively calling
<a href="https://underscorejs.org/#clone" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:clone</a>() or <a href="https://api.jquery.com/?s=extend" class="chemdoc__custom-link chemdoc__proto-jq" target="_blank">jq:extend</a>() or using LoDash’s <code>cloneDeep()</code>. It’s
deliberately dumb to remain simple and will attempt to copy everything,
even classes like <code class="chemdoc__id">Date</code>, <code class="chemdoc__id">RegExp</code>, DOM nodes, etc. (resulting in invalid
objects).</p><p>Use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a> when need to clone an object just once or twice. Use
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepCloner" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepCloner()</a> when doing this often (such as upon new object
instantiation) – it’s faster by 8-9 times and produces code close to what
you’d have written by hand.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var obj = {array: [{sub: 'prop'}]}
var obj2 = obj
var obj3 = Sqimitive.Base.deepClone(obj)

obj2.array.push('new')
  // obj.array is now [{sub: 'prop'}, 'new']
  // obj3.array is still [{sub: 'prop'}]

delete obj3.array[0].sub
  // obj3.array is now [{}]
  // obj.array is still [{sub: 'prop'}, 'new']

var cloner = Sqimitive.Base.deepCloner(obj)
cloner.toString()   //=&gt; return {"array":[{"sub":"prop",},],}
var objClone = cloner()</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfdeepClone---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1174-L1187" target="_blank">lines 1174-1187</a> (14 lines)                                  &bull; <a href="#Sqimitive-Core--sfdeepClone---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">deepClone: function (obj) {
  if (typeof obj == 'object' && obj != null) {
    if (_.isArray(obj)) {
      obj = obj.map(Core.deepClone)
    } else {
      obj = _.assign({}, obj)
      for (var prop in obj) {
        obj[prop] = Core.deepClone(obj[prop])
      }
    }
  }

  return obj
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfdeepCloner"
                data-entity='{"type":"func","id":927,"name":"deepCloner","start":{"line":1205,"column":4,"offset":45183},"end":{"line":1254,"column":4,"offset":46568},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>deepCloner</b>
                              (
                  [obj [, options]]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Returns a function constructing <code class="chemdoc__id">obj</code> with recursively-copied arrays and
<code>{}</code> objects – compiled version of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">obj</th><td>mixed</td><td rowspan="1" colspan="1"></td></tr><tr class="chemdoc__first"><th rowspan="2">options</th><td>missing create new cloner</td><td rowspan="2" colspan="1">
non-scalar values are held in <code class="chemdoc__id">shared</code> array, passed to the returned
function via <code class="chemdoc__id">s</code> variable.</td></tr><tr><td> object merge multiple cloners </td></tr></table><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>function returning <code class="chemdoc__id">obj</code> copy</td><td rowspan="2" colspan="1"></td></tr><tr><td> object if no arguments or if <code class="chemdoc__id">options</code>
given, call its <code>compile()</code> to get the function</td></tr></table><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-deepclonebase" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">deepclonebase</a></span></p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a> is used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">Core.constructor</a> to copy non-shared
properties (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a>). Think of it as of recursively calling
<a href="https://underscorejs.org/#clone" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:clone</a>() or <a href="https://api.jquery.com/?s=extend" class="chemdoc__custom-link chemdoc__proto-jq" target="_blank">jq:extend</a>() or using LoDash’s <code>cloneDeep()</code>. It’s
deliberately dumb to remain simple and will attempt to copy everything,
even classes like <code class="chemdoc__id">Date</code>, <code class="chemdoc__id">RegExp</code>, DOM nodes, etc. (resulting in invalid
objects).</p><p>Use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone()</a> when need to clone an object just once or twice. Use
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepCloner" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepCloner()</a> when doing this often (such as upon new object
instantiation) – it’s faster by 8-9 times and produces code close to what
you’d have written by hand.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var obj = {array: [{sub: 'prop'}]}
var obj2 = obj
var obj3 = Sqimitive.Base.deepClone(obj)

obj2.array.push('new')
  // obj.array is now [{sub: 'prop'}, 'new']
  // obj3.array is still [{sub: 'prop'}]

delete obj3.array[0].sub
  // obj3.array is now [{}]
  // obj.array is still [{sub: 'prop'}, 'new']

var cloner = Sqimitive.Base.deepCloner(obj)
cloner.toString()   //=&gt; return {"array":[{"sub":"prop",},],}
var objClone = cloner()</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfdeepCloner---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1206-L1255" target="_blank">lines 1206-1255</a> (50 lines)                                  &bull; <a href="#Sqimitive-Core--sfdeepCloner---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">deepCloner: function (obj, o) {
  o = o || {
    func: ['return '],
    shared: [],
    compile: function () {
      // Clearing o.func to free old members which may be quite numerous.
      return _.partial(new Function('s', o.func.splice(0).join('')), o.shared)
    },
  }

  if (!arguments.length) { return o }

  switch (typeof obj) {
    case 'string':
      if (obj.length < 50) {
        o.func.push(JSON.stringify(obj))
        break
      }
    default:
      o.func.push('s[' + (o.shared.push(obj) - 1) + ']')
      break
    case 'object':
      if (obj == null) {
        // Fall through.
      } else if (_.isArray(obj)) {
        o.func.push('[')
        for (var i = 0; i < obj.length; i++) {
          Core.deepCloner(obj[i], o)
          o.func.push(',')
        }
        o.func.push(']')
        break
      } else {
        o.func.push('{')
        for (var prop in obj) {
          o.func.push(JSON.stringify(prop) + ':')
          Core.deepCloner(obj[prop], o)
          o.func.push(',')
        }
        o.func.push('}')
        break
      }
    case 'undefined':
    case 'boolean':
    case 'number':
      o.func.push(obj + '')
  }

  return arguments[1] ? o : o.compile()
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfexpandFunc"
                data-entity='{"type":"func","id":924,"name":"expandFunc","start":{"line":953,"column":4,"offset":35450},"end":{"line":969,"column":4,"offset":35983},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>expandFunc</b>
                              (
                  func [, obj]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Expands a function reference <code class="chemdoc__id">func</code> of object <code class="chemdoc__id">obj</code> (<code class="chemdoc__id">this</code> if not given)
into a real <code class="chemdoc__id">Function</code>.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a> is used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> and others to
short-reference the instance’s own methods.</p><p>If <code class="chemdoc__id">func</code> is a string and contains a dot or a dash (<code>.-</code>) – returns
masked (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmasker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">masker()</a>) version of this method (<code class="chemdoc__id">mask</code> starts with the first
such character). If it’s a string without them – returns a function that
calls the method named <code class="chemdoc__id">func</code> on <code class="chemdoc__id">obj</code> (or <code class="chemdoc__id">this</code> if omitted). In other
cases returns <code class="chemdoc__id">func</code> as is (if <code class="chemdoc__id">obj</code> is omitted) or <code>_.bind(func, obj)</code>
(if <code class="chemdoc__id">obj</code> is given).</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var func = Sqimitive.Base.expandFunc('meth')
  // returned function will call this.meth(arguments, ...)

var obj = {meth: function (s) { alert(s) }}
func.call(obj, 123)
  // alerts 123

var func = Sqimitive.Base.expandFunc('meth-.', obj)
  // this function works in obj context, calling meth with just one
  // argument (2nd it was given) - see masker()

_.each({k1: 1, k2: 2}, func)
  // each() calls func(1, 'k1') and func(2, 'k2')
  // func calls obj.meth('k1') and obj.meth('k2')
  // alerts twice: 'k1' and 'k2'

_.each({k1: 1, k2: 2}, _.bind(func, obj))
  // if we didn't give obj to expandFunc() previous example would
  // fail - func() would be called on window which has no 'meth'
  // method</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfexpandFunc---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L954-L970" target="_blank">lines 954-970</a> (17 lines)                                  &bull; <a href="#Sqimitive-Core--sfexpandFunc---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">expandFunc: function (func, obj) {
  if (typeof func == 'string') {
    var parts = func.split(/([.-][\d.-]*)$/)
    if (parts.length > 1) {
      return Core.masker(parts[0], parts[1], obj)
    } else {
      function expandFunc_() {
        var callCx = obj || this
        return callCx[func].apply(callCx, arguments)
      }
      Core.trace && (expandFunc_.trace = arguments)
      return expandFunc_
    }
  } else {
    return obj ? _.bind(func, obj) : func
  }
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfextend"
                data-entity='{"type":"func","id":918,"name":"extend","start":{"line":637,"column":4,"offset":23410},"end":{"line":683,"column":4,"offset":25467},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>extend</b>
                              (
                  [name, ] [protoProps [, staticProps]]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Extension" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Extension</a></p><p>Creates a subclass of the class on which <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> is called.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">name</th><td>string </td><td rowspan="1" colspan="1"> Optional convenience string displayed in the debugger (as
the function/constructor – “class” name). Defaults to name of base
class.
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend('My.Class')
MyClass.name                      //=&gt; 'My.Class'
;(new MyClass).constructor.name   //=&gt; 'My.Class'</code></pre></td></tr><tr class="chemdoc__first"><th rowspan="1">protoProps</th><td>object </td><td rowspan="1" colspan="1"> New instance fields (properties or methods). May
contain special non-field keys (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a>).</td></tr><tr class="chemdoc__first"><th rowspan="1">staticProps</th><td>object </td><td rowspan="1" colspan="1"> New static fields.</td></tr></table><p><code class="chemdoc__id">protoProps</code> fields become accessible as <code>(new MyClass).instanceSomething()</code>
while <code class="chemdoc__id">staticProps</code> – as <code>MyClass.staticSomething()</code>.</p><p>Any argument may be <code class="chemdoc__id">null</code> or omitted. If all are such then you get a
copy of the base class (and yet <code>BaseClass !== SubClass</code>).</p><p>Other notes:</p><ul><li>In Sqimitive, subclassing is a special case of mix-ins (multi-parent
inheritance in OOP). <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> simply creates a new “blank” class and
mixes the base class into it. Therefore most of the job is performed by
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> (which also allows changing particular object’s prototype
after class construction on run-time).</li><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> creates a new prototype, sets its parent, assigns <code class="chemdoc__id">__super__</code>
(a static property pointing to the base class), calls <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::mixIn()</a> and
resolves <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> if it’s a string (since it can’t be done before
the prototype is created).</li></ul><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-mixInDoes" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">mixInDoes</a></span></p><ul><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> applies “sub mix-ins” (calls <code>mixIn()</code> if <code class="chemdoc__id">newClass</code> contains
the <code class="chemdoc__id">mixIns</code> key; this is recursive), overwrites fields of <code class="chemdoc__id">this</code> with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone</a>-s of those in <code class="chemdoc__id">newClass</code> (or merges according to
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a>), adds <code class="chemdoc__id">staticProps</code>, hardwires events into class
definition (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) and calls <code>finishMixIn()</code>.</li><li>If <code class="chemdoc__id">staticProps</code> argument is given, it replaces
<code>protoProps.staticProps</code>. As expected, this key (or argument) is
applied by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> after applying <code class="chemdoc__id">staticProps</code> of <code class="chemdoc__id">mixIns</code>.
<pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  staticProps: {sp: 'm'}
}
var Class = Sqimitive.Base.extend({
  mixIns: [MixIn]
}, {
  sp: 'c'
})
// Equivalent:
var Class = Sqimitive.Base.extend({
  staticProps: {sp: 'c'},
  mixIns: [MixIn]
})
// Above, Class.sp is 'c'. However, if mixing-in later, it'd be 'm':
Class.mixIn(MixIn)</code></pre></li></ul><fieldset class="chemdoc__example"><legend>Example</legend>In case of duplicated field names, subclass’ fields take precedence and
overwrite fields in the parent class except for fields listed in
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a>: <pre><code class="chemdoc__block prism language-javascript match-braces">// First we extend a base Sqimitive class with our own properties.
var MyBase = Sqimitive.jQuery.extend({
  _somethingBase: 123,
  _somethingNew: 'foo',

  el: {tag: 'nav', id: 'nav'},

  _opt: {
    baseOption: 'boo',
    baseMore: 'moo',
  },
})

// Now if we extend MyBase...
var MySubclass = MyBase.extend({
  _somethingSub: 'bar',
  _somethingBase: 987,

  el: {tag: 'footer'},

  _opt: {
    subOption: 'sub',
    baseMore: 'bus',
  },
})

/*
  ...we get the following class, after merging with its parent:

    MySubclass = {
      // Got new value - overridden in MySubclass.
      _somethingBase: 987,
      // Retained old value from MyBase.
      _somethingNew: 'foo',
      // New property - introduced in MySubclass.
      _somethingSub: 'bar',

      // Got new value in MySubclass.
      el: {tag: 'footer'},

      // Unlike el, _opt is listed in _mergeProps by default so its
      // keys are merged and not entirely replaced.
      _opt: {
        // Retained.
        baseOption: 'boo',
        // Introduced.
        subOption: 'sub',
        // Overridden.
        baseMore: 'bus',
      },
    }
*/</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfextend---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L638-L684" target="_blank">lines 638-684</a> (47 lines)                                  &bull; <a href="#Sqimitive-Core--sfextend---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">extend: function (name, protoProps, staticProps) {
  // this = base class.
  // Only works in strict mode which disconnects parameter vars from members
  // of arguments.
  name = typeof arguments[0] == 'string' ? ap.shift.call(arguments) : this.name

  var child = extend(name, this, arguments[0])
  //! +ig
  // Since base class has its own __super__, make sure child's (set up by
  // extend() above) isn't overwritten.
  _.assign(child, this, {__super__: child.__super__})

  // Ensure changing these in a subclass doesn't affect the parent:
  //   var Sub = Sqimitive.Base.extend()
  //   Sqimitive.Base._mergeProps.length  //=> 3
  //   Sub._mergeProps.push('new')
  //   Sqimitive.Base._mergeProps.length  //=> 4
  child._mergeProps = (child._mergeProps || this._mergeProps).concat()
  child._shareProps = (child._shareProps || this._shareProps).concat()

  //! +ig
  // Function.prototype.length confuses "isArrayLike" functions.
  // Just `[delete Core.length`] doesn't work.
  Object.defineProperty(child, 'length', {value: 'NotAnArray'})

  name && Object.defineProperty(child, 'name', {value: name})

  if (arguments[1]) {
    (arguments[0] = arguments[0] || {}).staticProps = arguments[1]
  }
  arguments[0] && child.mixIn(arguments[0])

  // _childClass is technically part of Base, not Core but doing it here for
  // simplicity.
  //
  // String class path is relative to the base class; instead of searching
  // all prototypes to find where this property was introduced (without this
  // all children will reference to them as the base class), we "fixate" it
  // when declaring the class. Done here, not in mixIn(), to avoid questions
  // like "is the string, if given by a mix-in, relative to the mix-in or
  // the target class?".
  if (typeof child.prototype._childClass == 'string') {
    child.prototype._childClass = [child, child.prototype._childClass]
  }

  return child
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sffire"
                data-entity='{"type":"func","id":940,"name":"fire","start":{"line":1330,"column":4,"offset":50211},"end":{"line":1386,"column":4,"offset":52413},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>fire</b>
                              (
                  funcs [, args [, inBatch]]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Invokes event handlers in response to firing an event (see instance
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.fire()</a>).</p><p><code class="chemdoc__id">funcs</code> is an array of event registration objects of an internal format.
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::fire()</a> calls each handler in order according to its type (such as
expecting a fixed number of arguments, accepting current result value,
affecting return value, etc. according to <code class="chemdoc__id">prefix</code> in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>, see
<a href="../Sqimitive/c_Core.html#-evtref" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtref</a>) while giving it <code class="chemdoc__id">args</code> (array or <code class="chemdoc__id">Arguments</code>).</p><p>If a handler returns something other than <code class="chemdoc__id">undefined</code> and it’s eligible
for changing return value (as it’s the case for <code>+event</code> and <code>=event</code>,
see <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>), then current result is replaced by that handler’s return
value. Returns the ultimate return value after calling every handler,
unless stopped by any <code class="chemdoc__id">eobj</code>.<a href="../Sqimitive/c_Core.html#-post" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">post</a> callback setting <code>eobj.stop</code> to
<code class="chemdoc__id">true</code> (see the example in <a href="../Sqimitive/c_Core.html#-post" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">post</a>).</p><p>Other notes:</p><ul><li>This is an internal method and there is no reason to call it directly.</li><li>Hook order (priority; <a href="../Sqimitive/c_Core.html#-evtref" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtref</a>) is maintained by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>, not <code>fire()</code>.</li><li><code class="chemdoc__id">funcs</code> can be non-<code class="chemdoc__id">isArray</code>, in this case <code class="chemdoc__id">undefined</code> is returned.</li><li><code class="chemdoc__id">funcs</code> is cloned; members added or removed while <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::fire()</a> is running
are ignored; changes to a member (<code class="chemdoc__id">eobj</code>) affect the call only if that
member wasn’t yet called.</li><li>In <a href="../Sqimitive/c_Core.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">Core</a>, a removed hook that was not yet called still isn’t called
(because <code>_unregHandler()</code> clears <code>eobj.func</code>). See the second example
below.</li></ul><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var funcs = [
  // The event object (eobj) stored within sqim._events:
  {func: function () { ... }, cx: window, res: true}
]
var res = Sqimitive.Core.fire(funcs, [5, 'foo'])
  // same as: var res = func.call(window, 5, 'foo')</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Removing hooks from within <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::fire()</a>:
<pre><code class="chemdoc__block prism language-javascript match-braces">var sqim = new Sqimitive.Core
var ev1 = sqim.on('evt', () =&gt; console.log(1))    // to be called first
sqim.on('evt', () =&gt; sqim.off(ev1).off(ev2))      // to be called second
var ev2 = sqim.on('evt', () =&gt; console.log(2))    // to be called last
sqim.fire('evt')
  // console logs 1 but not 2</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sffire---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1331-L1387" target="_blank">lines 1331-1387</a> (57 lines)                                  &bull; <a href="#Sqimitive-Core--sffire---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">fire: function (funcs, args, inBatch) {
  var res
  args = args || []

  // funcs can be undefined, e.g. when firing change_OPT.
  // It may be non-array if non-own property was read (_events.toString).
  //
  // Cloning function list to ignore the outside changes (e.g. when a
  // handler is removed from the same event as it's being fired; may happen
  // when once() is used).
  _.isArray(funcs) && funcs.concat().some(function fire_(eobj) {
    if (inBatch != null && eobj.batch !== inBatch) { return }

    Core.trace &&
      Core.lastFired.push(_.assign({self: this}, eobj)) > 50 &&
      Core.lastFired.shift()

    // func is null if off() was called on a wrapped handler.
    // Non-null eobj.args is implementing "ev__" (#argDanger).
    var call = eobj.func && (eobj.args == null || eobj.args == args.length)

    if (!call) {
      // If the handler is not to be called, pretend it's not there and call
      // the handlers it wraps (supList),
      var thisRes = eobj.sup ? eobj.sup(eobj.cx || this, args) : undefined
    } else {
      if (!eobj.sup && !eobj.res) {
        var thisArgs = args
      } else {
        var thisArgs = ap.slice.call(args)
        eobj.sup && thisArgs.unshift(eobj.sup)
        eobj.res && thisArgs.unshift(res)
      }

      // A benchmark avoiding Function's apply() was done on Chrome
      // using a direct call construct from EventEmitter3:
      // switch (args.len) { case 0: f(); case 1: f(args[0]); ... }
      // It made no differences at all in performance.
      var thisRes = eobj.func.apply(eobj.cx || this, thisArgs)
    }

    if (eobj.ret && thisRes !== undefined) {
      res = thisRes
    }

    if (eobj.post && call) {
      eobj.stop = false
      // Attention: args may be an array-like object (often an Arguments),
      // not a real array.
      res = eobj.post.call(eobj.cx || this, eobj, res, args)
      // eobj could be modified by post, including unsetting post.
      if (eobj.stop) { return true }
    }
  }, this)

  return res
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sffirer"
                data-entity='{"type":"func","id":942,"name":"firer","start":{"line":1429,"column":4,"offset":53936},"end":{"line":1442,"column":4,"offset":54360},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>firer</b>
                              (
                  event [, args [, cx]]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Returns a function that <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a>-s an <code class="chemdoc__id">event</code> with arguments of its call.</p><p>The returned function calls <code>fire(event, ...firerArgs, ...givenArgs)</code>
in context of <code class="chemdoc__id">cx</code>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">event</th><td>string </td><td rowspan="1" colspan="1"> Like <code>change_caption</code></td></tr><tr class="chemdoc__first"><th rowspan="1">args</th><td>array </td><td rowspan="1" colspan="1"> Push some parameters in front of the function’s arguments
(<code class="chemdoc__id">firerArgs</code>).</td></tr><tr class="chemdoc__first"><th rowspan="1">cx</th><td>object </td><td rowspan="1" colspan="1"> If not given then context is unchanged.</td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a> is used by <code>on()</code> to “convert” method calls into events making
it unnecessary to directly call <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> in most cases (see <a href="../p_ov.html#-evt" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">evt</a>): <pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend({
  upper: function (s) { return s.toUpperCase() },
})

var obj = new MyClass
  // obj.upper is the function given to extend(), not an event
var res = obj.upper('booh!')
  //=&gt; 'BOOH!'

obj.on('+upper', () =&gt; 'baah!')
  // now obj.upper is the result of firer() and yet it's called as if
  // it was a regular method
var res = obj.upper('booh!')
  //=&gt; 'baah!'
// Same as writing:
var res = obj.fire('upper', ['booh!'])
  //=&gt; 'baah!'</code></pre></fieldset><p>Essentially, using <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a> is just a short way of writing:
<pre><code class="chemdoc__block prism language-javascript match-braces">(function () { return this.fire(event, args.concat(arguments)) }).bind(cx)</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sffirer---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1430-L1443" target="_blank">lines 1430-1443</a> (14 lines)                                  &bull; <a href="#Sqimitive-Core--sffirer---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">firer: function (event, args, cx) {
  if (arguments.length > 1) {
    args = Core.toArray(args)
    var firer_ = function () {
      return (cx || this).fire(event, args.concat( ap.slice.call(arguments) ))
    }
  } else {
    var firer_ = function () {
      return (cx || this).fire(event, arguments)
    }
  }
  Core.trace && (firer_.trace = arguments)
  return firer_
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfmasker"
                data-entity='{"type":"func","id":925,"name":"masker","start":{"line":1107,"column":4,"offset":41795},"end":{"line":1133,"column":4,"offset":42618},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>masker</b>
                              (
                  func[, mask[, cx[, args]]]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Returns a version of <code class="chemdoc__id">func</code> with arguments reordered according to <code class="chemdoc__id">mask</code>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="3">mask</th><td>number to skip that many leading arguments alike to <a href="https://squizzle.me/js/nodash/map.html#NoDash--ifrest" class="chemdoc__custom-link chemdoc__link-extchem chemdoc__link-extchem-no" target="_blank">no:rest</a>()</td><td rowspan="3" colspan="1"></td></tr><tr><td>
null/omitted to assume the number <code class="chemdoc__id">1</code> (skip first argument)</td></tr><tr><td> string
pattern <a href="../Sqimitive/c_Core.html#-maskerPattern" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">maskerPattern</a></td></tr><tr class="chemdoc__first"><th rowspan="2">func</th><td>string method name</td><td rowspan="2" colspan="1"> Called on <code class="chemdoc__id">cx</code></td></tr><tr><td> function </td></tr><tr class="chemdoc__first"><th rowspan="2">cx</th><td>object</td><td rowspan="2" colspan="1"> The context for <code class="chemdoc__id">func</code></td></tr><tr><td> null/omitted use <code class="chemdoc__id">this</code> </td></tr><tr class="chemdoc__first"><th rowspan="1">args</th><td>array </td><td rowspan="1" colspan="1"> Extra left-side arguments to <code class="chemdoc__id">func</code></td></tr></table><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmasker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">masker()</a> is similar to LoDash’s <code>rearg()</code>.</p><p>Masking is a way to work around <a href="../Sqimitive/c_Core.html#-argDanger" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">argDanger</a> and avoid writing callback
function wrappers that only ignore or reorder arguments. It’s implicitly
used in string <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> values since they are passed to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a>.</p><fieldset class="chemdoc__example"><legend>Example</legend><a id="-es6this" class="chemdoc__anchor chemdoc__anchor_token" href="#-es6this">es6this</a>ES6 arrow functions could be useful for this but they are ill-suited for
use as handlers when <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ing because of their permanent <code class="chemdoc__id">this</code>.<p><pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend({
  events: {
    // WRONG: will pass res as s, value as chars and break clean():
    '+normalize_caption': 'clean',
    // WRONG: this is window/self, not an instance of MyClass:
    '+normalize_caption': (res, value) =&gt; this.clean(value),
    // CORRECT:
    '+normalize_caption': function (res, value) { return this.clean(value) },
    // CORRECT: skip first argument, give second:
    '+normalize_caption': 'clean-.',
  },

  clean: function (s, chars) {
    chars = chars || ' \t\r\n'
    while (s.length &amp;&amp; chars.indexOf(s[0]) != -1) {
      s = s.substr(1)
    }
    while (s.length &amp;&amp; chars.indexOf(s[s.length - 1]) != -1) {
      s = s.replace(/.$/, '')
    }
    return s
  },
})</code></pre></p></fieldset><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">$.ajax({
  url: 'api/route',
  dataType: 'json',
  context: sqim,

  // WRONG: success' second argument is textStatus which gets assigned
  // as assignResp(data, options) breaking the latter (textStatus is
  // not options):
  success: sqim.assignResp,

  // CORRECT: we indicate that we are only interested in the first
  // argument which is passed through to assignResp():
  success: Sqimitive.Base.masker('assignResp', '.'),
})</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>It is customary to alias <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmasker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">masker()</a> with a shorter name and use the
alias in the code:
<pre><code class="chemdoc__block prism language-javascript match-braces">var m = Sqimitive.Base.masker

var MyModel = Sqimitive.Base.extend({
  // Note that it's different from the first example: normalize_OPT
  // is a method, not an event handler, so no need for '+...' - but
  // no automatic masking too (string value can be used only in
  // events, in properties it must be a function).
  //
  // Unmasked, _.trim() takes two arguments: (str, chars).
  // normalize_OPT() is passed: (value, options).
  // As we see, options is given as chars which is incorrect.
  normalize_caption: m(_.trim, '.'),
})</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">// Giving an explicit cx, the context object (col):
_.each(arrayOfSqims, m('nest', '21', col))
  // here we call col.nest() on each item in arrayOfSqim with swapped
  // arguments, effectively nesting each member into the col object.
  // _.each() calls the iterator as (value, key) while nest() takes
  // (key, sqim)

m('nest', 1)
  // returns a function that preserves all but the first argument:
  // function () { return this.nest.apply(this, _.rest(arguments)) }

m('nest')
  // the same - omitted mask defaults to number 1

m('nest', 0, cx)
  // doesn't change arguments at all (_.rest(a, 0) == a) but binds
  // function to cx

m('nest', 0, null, ['left', 'left2'])
  // doesn't bind result but pushes 'left' and 'left2' arguments
  // before all given arguments: nest('left', 'left2', other args...)

m(function (a1, a2) { alert(a1 + ' ' + a2) }, '')
  //=&gt; always 'undefined undefined'</code></pre></fieldset><h3 id="-maskerPattern" class="chemdoc__h1 chemdoc__anchored">Mask pattern<a class="chemdoc__anchor chemdoc__header-anchor" href="#-maskerPattern">maskerPattern</a></h3><p>In a string <code class="chemdoc__id">mask</code>, each symbol maps arguments given to the masked
function (returned by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmasker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">masker</a>) to arguments for the original <code class="chemdoc__id">func</code> (the
argument to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmasker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">masker</a>). Each symbol represents a particular argument and
can be one of these:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">dot</th><td><code>.</code> </td><td rowspan="1" colspan="1"> Gets argument at index of this dot in the <code class="chemdoc__id">mask</code> string
(<code>-..-.</code> equals to <code>-23-5</code>).</td></tr><tr class="chemdoc__first"><th rowspan="1">dash</th><td><code>-</code> </td><td rowspan="1" colspan="1"> Ignores argument (doesn’t give to <code class="chemdoc__id">func</code>); trailing dashes
are meaningless (arguments past the end of <code class="chemdoc__id">mask</code> are never given unless
<code class="chemdoc__id">mask</code> is a number).</td></tr><tr class="chemdoc__first"><th rowspan="1">number</th><td><code>1-9</code> </td><td rowspan="1" colspan="1"> Gets argument by index: <code class="chemdoc__id">1</code> gets the first masked
argument, etc.</td></tr></table><p>For example, if the wrapped function received arguments <code>arg1, arg2,
arg3</code> then the <code class="chemdoc__id">mask</code> of <code>-.1</code> (same as <code>-21</code>) gives the original
<code class="chemdoc__id">func</code> arguments <code>arg2, arg1</code>.</p><p>Empty <code class="chemdoc__id">mask</code> passes zero arguments (as do <code>-</code>, <code>--</code>, etc.).</p><p>Note: the <code class="chemdoc__id">mask</code> of <code>'3'</code> (string) is different from <code>3</code> (number) -
<code>'3'</code> passes 3<sup>rd</sup> wrapper’s argument as the first <code class="chemdoc__id">func</code>’s argument
while <code>3</code> skips first 3 arguments and passes all others.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfmasker---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1108-L1134" target="_blank">lines 1108-1134</a> (27 lines)                                  &bull; <a href="#Sqimitive-Core--sfmasker---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">masker: function (func, mask, cx, args) {
  mask == null && (mask = 1)
  var isMethod = typeof func == 'string'
  var isSkipFirst = typeof mask == 'number'
  args || (args = [])

  if (!isSkipFirst) {
    mask = mask
      .replace(/\./g, function (ch, i) { return i > 8 ? '-' : i + 1 })
      .replace(/[^1-9.\-]+/g, '-')
      .replace(/-+$/, '')
  }

  function masker_() {
    var callCx = cx || this
    var callArgs = isSkipFirst ? args.concat(_.rest(arguments, mask)) : args.concat()

    for (var i = 0; i < mask.length; i++) {
      mask[i] != '-' && callArgs.push(arguments[mask[i] - 1])
    }

    return (isMethod ? callCx[func] : func).apply(callCx, callArgs)
  }

  Core.trace && (masker_.trace = arguments)
  return masker_
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfmixIn"
                data-entity='{"type":"func","id":920,"name":"mixIn","start":{"line":695,"column":4,"offset":25791},"end":{"line":697,"column":4,"offset":25886},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>mixIn</b>
                              (
                  newClass, options                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Extension" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Extension</a></p><p>Extends this class with a behaviour of another “class” (a “mix-in”).</p><p>The instance <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.mixIn()</a> works the same way but allows extending a
particular object instance on run-time. Its description follows.</p><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-mixInDesc" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">mixInDesc</a></span></p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">this</th><td rowspan="1" colspan="2"> The object receiving new “mixed-in” fields (for static
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::mixIn()</a> <code class="chemdoc__id">this</code> is the “child” class).</td></tr><tr class="chemdoc__first"><th rowspan="1">newClass</th><td>object </td><td rowspan="1" colspan="1"> The mix-in, the object “mixed into” <code class="chemdoc__id">this</code>.</td></tr><tr class="chemdoc__first"><th rowspan="1">options</th><td rowspan="1" colspan="2"> An arbitrary value (usually an object) given to
<code class="chemdoc__id">newClass</code>.<code>finishMixIn()</code>, allowing creation of parametrized mix-ins
(basically, generics).</td></tr></table><p>Possible <code class="chemdoc__id">newClass</code> keys:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">staticProps</th><td>object </td><td rowspan="1" colspan="1"> Static fields made available as
<code>newClass.something</code></td></tr><tr class="chemdoc__first"><th rowspan="1">events</th><td>object </td><td rowspan="1" colspan="1"> Event listeners (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a>).<p>Because this is not a real field, keys in <code>newClass.events</code> do not
override keys in <code>this.events</code>. If both <code class="chemdoc__id">this</code> and <code class="chemdoc__id">newClass</code> have the
<code class="chemdoc__id">foo</code> event key (i.e. if both listen to this event) then two listeners
are set up, not one. Compare with <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a> overriding
(<a href="../Sqimitive/c_Core.html#-elEventsMixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">elEventsMixIn</a>).</p></td></tr><tr class="chemdoc__first"><th rowspan="1">finishMixIn</th><td>function </td><td rowspan="1" colspan="1"> Called before returning.<p><code class="chemdoc__id">this</code> = <code class="chemdoc__id">newClass</code>. arguments = <code>child, options</code> where <code class="chemdoc__id">child</code> is the
prototype of the updated class</p></td></tr><tr class="chemdoc__first"><th rowspan="1">mixIns</th><td>array </td><td rowspan="1" colspan="1"> Each item is either a mixed-in class or an array:
<code>[class, options]</code></td></tr><tr class="chemdoc__first"><th rowspan="1">*</th><td rowspan="1" colspan="2"> Other keys represent instance fields (the <code class="chemdoc__id">protoProps</code> argument of
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>).<p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> is respected, but of <code class="chemdoc__id">this</code> (not of <code class="chemdoc__id">newClass</code>).</p><p>A string form of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> is only allowed in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>, not here;
other forms (array, object) are allowed in both places.</p></td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  staticProps: {
    staticMethod: function () { ... },
  },
  events: {
    '-init': function () {
      // (1) Define a property only if it's not defined yet.
      this._someProp = this._someProp || 'buzz'
    },
  },
  finishMixIn: function (targetProto) {
    alert("I'm now mixed into " + targetProto.toString())

    // (2) Or could do it here, more performance-efficient since ran
    // only once for each mixed-in class, not once for each such class
    // instantiation:
    //targetProto._someProp = targetProto._someProp || 'buzz'
    //targetProto.constructor.someStatic = 123
  },
  _opt: {
    correctly: 'merged',
  },
  instanceMethod: function () { ... },
}

var Base1 = Sqimitive.Base.extend({})

var Base2 = Sqimitive.Base.extend({
  _opt: {
   a: 'base',
 },
  // Not overridden by MixIn.
  _someProp: 123,
})

Base1.mixIn(MixIn)   // alerts
  //=&gt; _someProp = 'buzz'
  //=&gt; opt = {correctly: 'merged'}

Base2.mixIn(MixIn)   // alerts again
  //=&gt; _someProp = 123
  //=&gt; opt = {a: 'base', correctly: 'merged'}</code></pre></fieldset><p><b>Warning:</b> <code class="chemdoc__id">this</code> is modified in-place; no new class is created
(<code>mixIn()</code> returns no value). If you want a base class without a given
mix-in and a subclass with that mix-in – first <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> the base class
and then mix into the new sub-class:
<pre><code class="chemdoc__block prism language-javascript match-braces">// CORRECT:
var Base = Sqimitive.Base.extend()
var Sub = Base.extend({mixIns: [SomeMixIn]})

// WRONG: will modify Base, not return a new subclass:
var Base = Sqimitive.Base.extend()
var Sub = Base.mixIn(SomeMixIn)</code></pre></p><fieldset class="chemdoc__example"><legend>Example</legend>There is no way to determine if a class or object has some <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn</a> or
not. For example, listing a mix-in in <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> is useless because
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifnestEx" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.nestEx()</a> is using <code class="chemdoc__id">instanceof</code> and it works on real classes
only. You can add a field to work around this – static (only for mix-ins
applied to declarations) or instance (for mix-ins applied on run-time):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyMixIn = {staticProps: {myMixInIsMixedIn: true}}
var instanceofMyMixIn = 'myMixInIsMixedIn' in myObj.constructor

var sqim1 = new Sqimitive.Core
var sqim2 = new Sqimitive.Core
sqim1.mixIn(MyMixIn)
sqim2.constructor.myMixInIsMixedIn    //=&gt; true (!)

var MyMixIn = {myMixInIsMixedIn: true}
var sqim3 = new Sqimitive.Core
var sqim4 = new Sqimitive.Core
sqim3.mixIn(MyMixIn)
sqim4.myMixInIsMixedIn                //=&gt; false</code></pre></fieldset><p>Other notes:</p><ul><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> is doing most of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’s job, which is just creating a
special form of a mix-in.</li><li>Hooking <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifinit" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">init</a> and similar events for a mix-in applied on run-time is
useless since they will be never invoked.</li><li><a id="-mixInDoes" class="chemdoc__anchor chemdoc__anchor_token" href="#-mixInDoes">mixInDoes</a><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> applies “sub mix-ins” (calls <code>mixIn()</code> if <code class="chemdoc__id">newClass</code> contains
the <code class="chemdoc__id">mixIns</code> key; this is recursive), overwrites fields of <code class="chemdoc__id">this</code> with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone</a>-s of those in <code class="chemdoc__id">newClass</code> (or merges according to
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a>), adds <code class="chemdoc__id">staticProps</code>, hardwires events into class
definition (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) and calls <code>finishMixIn()</code>.</li><li>Not to be confused with Underscore’s <a href="https://underscorejs.org/#mixin%28%29" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:mixin()</a>. However, LoDash’s
<code>mixin()</code> is of a similar purpose.</li></ul><h3 id="-elEventsMixIn" class="chemdoc__h0 chemdoc__anchored">Merging of <code class="chemdoc__id">elEvents</code><a class="chemdoc__anchor chemdoc__header-anchor" href="#-elEventsMixIn">elEventsMixIn</a></h3><p><a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a> lists <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a> in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> so the former are
merged but unlike with <code>newClass.events</code> keys (which can never have a
conflict and be dropped), keys in <code class="chemdoc__id">elEvents</code> get overridden on name
collisions. This is sometimes desirable (to override the parent’s
handler), sometimes not (then use a unique <code>.ns</code> suffix):
<pre><code class="chemdoc__block prism language-javascript match-braces">var Base = Sqimitive.Base.extend({
  elEvents: {
    click: function () { alert("Click-click-click!') },
  },
})

var ChildA = Base.extend({
  elEvents: {
    click: function () { alert("Overridden!') },
  },
})

var ChildB = Base.extend({
  elEvents: {
    'click.new-in-child-B': function () { alert("Combined!') },
  },
})

// in ChildA, 'click' has 1 listener (Base's dropped)
// in ChildB, 'click' has 2 listeners (Base's and ChildB's)</code></pre></p><h3 id="A04fa545a8e" class="chemdoc__h0">Mix-in inheritance</h3><p><code class="chemdoc__id">mixIns</code> is applied before setting other properties which allows
extending mix-ins themselves (later mix-ins override preceding just like
with normal inheritance on classes). For example:
<pre><code class="chemdoc__block prism language-javascript match-braces">var ParentMixIn = {
  someEvent: function () { /* parent */ },
]

var ChildMixIn = {
  mixIns: [ParentMixIn],
  events: {
    someEvent: function () { /* child */ },
  },
}

var myClass = Sqimitive.Base.extend({
  mixIns: [ChildMixIn],
})

// myClass had ParentMixIn added, then ChildMixIn, and now has two
// listeners on someEvent</code></pre></p><p><code class="chemdoc__id">ParentMixIn</code> could also have the <code class="chemdoc__id">mixIns</code> property to specify its own
parent.</p><p>In the above example, the mix-in specified its parent, which is usually
intuitive. Still, it could be specified in the final class’ <code class="chemdoc__id">mixIns</code>
alone:
<pre><code class="chemdoc__block prism language-javascript match-braces">var ParentMixIn = {
  someEvent: function () { /* parent */ },
]

var ChildMixIn = {
  // mixIns property is missing.
  events: {
    someEvent: function () { /* child */ },
  },
}

var myClass = Sqimitive.Base.extend({
  // Added ParentMixIn in front of ChildMixIn.
  mixIns: [ParentMixIn, ChildMixIn],
})

// or (equivalent, no mixIns property, mixIn() calls instead):
var myClass = Sqimitive.Base.extend()
myClass.mixIn(ParentMixIn)
myClass.mixIn(ChildMixIn)

// or (equivalent for a particular object instance):
var myClass = Sqimitive.Base.extend()
var obj = new myClass
obj.mixIn(ParentMixIn)
obj.mixIn(ChildMixIn)

// in any case, MyClass (or obj) has 'someEvent' firer() with
// 2 listeners: of ParentMixIn and of ChildMixIn</code></pre></p><p><b>Warning:</b> calling <code>mixIn()</code> in <code>finishMixIn()</code> would have a
different effect. If <code class="chemdoc__id">ChildMixIn</code> were defined as follows then <code class="chemdoc__id">MyClass</code>
or <code class="chemdoc__id">obj</code> would have <code class="chemdoc__id">someEvent</code> not as a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a> but as the
<code class="chemdoc__id">ParentMixIn</code>’s function (because it was mixed-in after <code class="chemdoc__id">ChildMixIn</code> and
overrode its <code class="chemdoc__id">events</code> handler):
<pre><code class="chemdoc__block prism language-javascript match-braces">var ChildMixIn = {
  finishMixIn: function (newClass) {
    newClass.mixIn(ParentMixIn)
  },
  events: {
    someEvent: function () { /* child */ },
  },
}</code></pre></p><p>This will override the handler introduced in the declaration of <code class="chemdoc__id">Class</code>
for the same reason – <code class="chemdoc__id">MixIn</code> is added to <code class="chemdoc__id">Class</code> after <code class="chemdoc__id">Class</code>’ own
fields:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  some: function () { ... },
}

var Class = Sqimitive.Base.extend({
  events: {
    some: function () { ... },
  }
})

Class.mixIn(MixIn)</code></pre></p><p>This is the correct way (using <code class="chemdoc__id">mixIns</code> property when <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ing
<code class="chemdoc__id">Class</code>):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  some: function () { ... },
}

var Class = Sqimitive.Base.extend({
  mixIns: [MixIn],
  events: {
    some: function () { ... },
  }
})</code></pre></p><h3 id="A6cc2566c0e" class="chemdoc__h0">Edge cases</h3><p>See the source code for details.</p><ul><li>Given a base class <code class="chemdoc__id">B</code> and subclass <code class="chemdoc__id">C</code>, adding mix-ins to <code class="chemdoc__id">B</code> after <code class="chemdoc__id">C</code>
has been <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ed from <code class="chemdoc__id">B</code> when <code class="chemdoc__id">C</code> declares <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> will lead to
<code class="chemdoc__id">C</code> not having <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> of the newly mixed-in objects of <code class="chemdoc__id">B</code>.</li><li>Declaration-time <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> of <code class="chemdoc__id">B</code> are <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>’d and their <code class="chemdoc__id">eobj</code>-s are
shared among all subclasses of <code class="chemdoc__id">B</code> and should not be changed (list of
events may change, just not properties of inherited handlers): <pre><code class="chemdoc__block prism language-javascript match-braces">var ClassB = Sqimitive.Core.extend({
  events: {change: 'render'},
})

ClassB.prototype._events.change[0].post    //=&gt; undefined

var ClassC = ClassB.extend()
ClassC.prototype._events.change[0].post = function () { ... }
ClassB.prototype._events.change[0].post    //=&gt; Function

// In this version instances' _events are deepClone()'d so changing it
// (not the prototype) doesn't affect other classes/objects:
var obj = new ClassC
obj._events.change[0].post = 'foo'
ClassB.prototype._events.change[0].post    //=&gt; still Function</code></pre></li></ul></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfmixIn---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L696-L698" target="_blank">lines 696-698</a> (3 lines)                                  &bull; <a href="#Sqimitive-Core--sfmixIn---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">mixIn: function (newClass, options) {
  return this.prototype.mixIn(newClass, options)
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfparseEvent"
                data-entity='{"type":"func","id":933,"name":"parseEvent","start":{"line":1272,"column":4,"offset":47320},"end":{"line":1281,"column":4,"offset":47862},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>parseEvent</b>
                              (
                  str                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Extracts portions of the given event identifier as recognized by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>.</p><p>Returns an object with keys: <code class="chemdoc__id">batch</code> (leading <code>^</code>), <code class="chemdoc__id">priority</code> (number
before <code>^</code>), <code class="chemdoc__id">prefix</code> (like <code>+</code>, see <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>), <code class="chemdoc__id">args</code> (number of
trailing <code>_</code> or null), <code class="chemdoc__id">event</code> (event name, everything else) and
<code class="chemdoc__id">trace</code> (<code class="chemdoc__id">null</code> if <a href="../Sqimitive/c_Core.html#Sqimitive-Core--svtrace" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::trace</a> is off).</p><p>Errors if <code class="chemdoc__id">str</code> doesn’t look like a proper event reference.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">Sqimitive.Core.parseEvent('foo.bar')
  //=&gt; {batch: true, priority: 0, prefix: '', event: 'foo.bar', args: null}

Sqimitive.Core.parseEvent('^-3^+foo.bar___')
  //=&gt; {batch: false, priority: -3, prefix: '+', event: 'foo.bar', args: 3}</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfparseEvent---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1273-L1282" target="_blank">lines 1273-1282</a> (10 lines)                                  &bull; <a href="#Sqimitive-Core--sfparseEvent---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">parseEvent: function (str) {
  // Dots are used in _forward'ed event names, and we need prefix symbols
  // (+-=) and ^ in the middle of event name for the same reason:
  // '.2^-change'.
  var match = str.match(/^(\^?)(-?\d+\^)?([+\-=]?)(.+?)(_*)$/)
  if (!match) { throw new SyntaxError('Bad event name: ' + str) }
  return {batch: !match[1], priority: parseInt(match[2]) || 0,
          prefix: match[3], event: match[4], args: match[5].length || null,
          trace: Core.trace && (new Error).stack}
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfpicker"
                data-entity='{"type":"func","id":923,"name":"picker","start":{"line":883,"column":4,"offset":33098},"end":{"line":914,"column":4,"offset":33811},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>picker</b>
                              (
                  prop [, args]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Returns a function accepting an object and returning value of the
property at <code class="chemdoc__id">prop</code>, accessible via that object.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="3">prop</th><td>string dotted property path</td><td rowspan="3" colspan="1"></td></tr><tr><td> array already split path, empty array
to return the <code class="chemdoc__id">a</code>’rgument itself (or result of calling it)</td></tr><tr><td> other
stringified and split</td></tr><tr class="chemdoc__first"><th rowspan="3">args</th><td>array</td><td rowspan="3" colspan="1"> List of argument
lists for <code class="chemdoc__id">function</code>-type properties.</td></tr><tr><td> mixed = <code>[[args]]</code></td></tr><tr><td> omitted = <code>[]</code> </td></tr></table><p>The returned function (<code class="chemdoc__id">f</code>) expects one argument (<code class="chemdoc__id">a</code>). When called, <code class="chemdoc__id">f</code>
walks <code class="chemdoc__id">prop</code>, treating each item as a key (“own” or not) in the “current”
object (which starts as <code class="chemdoc__id">a</code>) and returns the last “current” object.</p><p>If there is a <code class="chemdoc__id">function</code> at that key (or <code class="chemdoc__id">a</code> itself is one) and its
<code class="chemdoc__id">name</code> is not a string starting with a capital letter (i.e. not a class
constructor), <code class="chemdoc__id">f</code> calls it in previous “current” object’s context
(<code class="chemdoc__id">undefined</code> if calling <code class="chemdoc__id">a</code>) with the next unused member of <code class="chemdoc__id">args</code> (<code>[]</code>
if none) and stores the result as the new “current” object.</p><p><code class="chemdoc__id">f</code> returns <code class="chemdoc__id">undefined</code> when trying to descend into <code class="chemdoc__id">undefined</code>/<code class="chemdoc__id">null</code>
“current” value.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a> is similar to <a href="https://underscorejs.org/#result" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:result</a>() in Underscore and LoDash.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var obj = {
  one: 1,
  two: function () { return 2 },
  some: function (a, b) { return a + '--' + b },
}

var picker = Sqimitive.Base.picker
picker('one')(obj)                  //=&gt; 1
picker('two')(obj)                  //=&gt; 2
picker('some', [['A', 'B']])(obj)   //=&gt; 'A--B'

var collection = ['foo', null, ['bar'], obj]
_.map(collection, picker('one'))
  //=&gt; [undefined, undefined, undefined, 1]

'toString' in obj           //=&gt; true
_.has(obj, 'toString')      //=&gt; false
picker('toString')(obj)     //=&gt; '[object Object]'

picker([])(obj)             //=&gt; obj
picker([])('foo')           //=&gt; 'foo'
picker([])(() =&gt; 123)       //=&gt; 123
// typeof Date is 'function' but Date.name[0] is upper-case.
picker([])(Date)            //=&gt; Date
picker(0)('foo')            //=&gt; 'f'
picker('0.0.0')('foo')      //=&gt; 'f'
picker([])(null)            //=&gt; null
picker(0)(null)             //=&gt; undefined</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Usually <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a>’s result is given to some filtering function
(<a href="../p_util.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_page mmods-fg " data-if-entity="799 chemdoc__link-entity-cur">util</a>). Example from <a href="../p_ov.html#-chld" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">chld</a>: <pre><code class="chemdoc__block prism language-javascript match-braces">getIncomplete: function () {
  return this.reject(MyToDoList.picker('get', 'isCompleted'))
},</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend><code class="chemdoc__id">args</code> is a list of multiple argument lists, not a single argument list.
This enables <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfpicker" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">picker()</a> to call methods of objects returned by other
methods. However, <code class="chemdoc__id">prop</code> often references just one property which is
either not a method or a method taking nothing (so you can omit <code class="chemdoc__id">args</code>),
or a method taking one scalar argument (so you can pass that value
directly):
<pre><code class="chemdoc__block prism language-javascript match-braces">picker('remove')(sqim)        //= sqim.remove()
picker('get')(sqim)           //= sqim.get()
picker('get', 'opt')(sqim)    //= sqim.get('opt')

picker('nested.get', [['ch1'], ['opt']])(sqim)
// Same as:
sqim.nested('ch1').get('opt')

picker('nested.get', [['ch1']])(sqim)
// Same as:
picker('nested.get', 'ch1')(sqim)
// Same as:
sqim.nested('ch1').get()

// WRONG, will fail:
picker('nested.get', ['ch1', 'opt'])(sqim)
picker('nested.get', ['ch1'])(sqim)</code></pre></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfpicker---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L884-L915" target="_blank">lines 884-915</a> (32 lines)                                  &bull; <a href="#Sqimitive-Core--sfpicker---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">picker: function (prop, args) {
  _.isArray(prop) || (prop = (prop + '').split('.'))

  if (arguments.length > 1 && !_.isArray(args)) {
    args = [[args]]
  }

  function picker_(obj) {
    var cx
    var ai = 0

    function picker_call() {
      if (typeof obj == 'function' && !/^[A-Z]/.test(obj.name)) {
        obj = obj.apply(cx, args && args[ai++])
      }
    }

    picker_call()

    for (var i = 0; i < prop.length; i++) {
      if (obj == null) { return }
      cx = obj
      obj = obj[prop[i]]
      picker_call()
    }

    return obj
  }

  Core.trace && (picker_.trace = arguments)
  return picker_
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfstub"
                data-entity='{"type":"func","id":921,"name":"stub","start":{"line":756,"column":4,"offset":28081},"end":{"line":756,"column":38,"offset":28115},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>stub</b>
                              (
                                  )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p>Simply an empty function that returns <code class="chemdoc__id">undefined</code>.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfstub" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">stub()</a> is similar to <a href="https://underscorejs.org/#noop" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:noop</a>() in Underscore and LoDash.</p><fieldset class="chemdoc__example"><legend>Example</legend>Use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfstub" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">stub()</a> or <code class="chemdoc__id">undefined</code> in places where you don’t want to supply any
implementation – this lets Sqimitive optimize things when it knows that
a function (acting as a method or an event handler) can be simply
discarded or overridden.
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqim = Sqimitive.Base.extend({
  success: Sqimitive.Base.stub,
  error: Sqimitive.Base.stub,
  // Equivalent:
  success: undefined,
  error: undefined,
})

var my = new MySqim
// Replaces the empty handler entirely.
my.on('success', function () { alert('Good!') })
  //=&gt; my._events.success.length is 1</code></pre></fieldset><p>Otherwise, if you are not a performance purist you can just use
<code>function () {}</code> or <code>new Function</code>:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqim = Sqimitive.Base.extend({
  success: function () { },
})

var my = new MySqim
my.on('success', function () { alert('Good!') })
  //=&gt; my._events.success.length is 2</code></pre></p><p>Special values <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfstub" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">stub()</a> and <code class="chemdoc__id">undefined</code> are only recognized in
properties, not <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a>:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqim = Sqimitive.Base.extend({
  events: {
    // Registers new hook that is called but has no effect on anything.
    success: Sqimitive.Base.stub,
    // Itself does nothing but previously registered hooks are removed.
    '=success': Sqimitive.Base.stub,
    // Simply wrong, undefined is not callable.
    success: undefined,
  },
})

var my = new MySqim
my.on('success', function () { alert('Good!') })
  //=&gt; my._events.success.length is 2 (existing stub handler kept)
my.on('success', Sqimitive.Base.stub)
  //=&gt; my._events.success.length is 3 (new stub handler added)
my.on('success', undefined)
  // simply wrong, undefined is not callable</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfstub---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L757-L757" target="_blank">line 757</a>                                  &bull; <a href="#Sqimitive-Core--sfstub---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">stub: function Sqimitive_stub() { },</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sftoArray"
                data-entity='{"type":"func","id":944,"name":"toArray","start":{"line":1632,"column":4,"offset":61224},"end":{"line":1640,"column":4,"offset":61431},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>toArray</b>
                              (
                  value                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Attempts to cast <code class="chemdoc__id">value</code> into a native <code class="chemdoc__id">Array</code> object.</p><p>The <code class="chemdoc__id">Arguments</code> object becomes an array, <code class="chemdoc__id">Array</code> (<a href="https://squizzle.me/js/nodash/map.html#NoDash--ivisArray" class="chemdoc__custom-link chemdoc__link-extchem chemdoc__link-extchem-no" target="_blank">no:isArray</a>()) is
returned as is while anything else is wrapped into an array to become its
sole member. This means that <code class="chemdoc__id">false</code>, <code class="chemdoc__id">null</code> and <code class="chemdoc__id">undefined</code> all result
in <code>[value]</code>, not in <code>[]</code>.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">;(function () {
  Sqimitive.Core.toArray(arguments)   //=&gt; [5, 'foo']
})(5, 'foo')

Sqimitive.Core.toArray([5, 'foo'])    //=&gt; [5, 'foo']
Sqimitive.Core.toArray(5)             //=&gt; [5]
Sqimitive.Core.toArray()              //=&gt; [undefined]</code></pre></fieldset><p>Note: <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sftoArray" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">toArray()</a> does not clone the result:
<pre><code class="chemdoc__block prism language-javascript match-braces">var a = [5]
Sqimitive.Core.toArray(a).push('foo')
  // a is now [5, 'foo']</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sftoArray---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L1633-L1641" target="_blank">lines 1633-1641</a> (9 lines)                                  &bull; <a href="#Sqimitive-Core--sftoArray---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">toArray: function (value) {
  if (_.isArguments(value)) {
    return ap.slice.call(value)
  } else if (!_.isArray(value)) {
    return [value]
  } else {
    return value
  }
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--sfunique"
                data-entity='{"type":"func","id":922,"name":"unique","start":{"line":786,"column":4,"offset":29069},"end":{"line":788,"column":4,"offset":29169},"forced":null,"modifiers":["static"],"file":"main.js"}'
                class="cp-member__header">
              <b>unique</b>
                              (
                  [prefix]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  static                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Utilities" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Utilities</a></p><p>Returns a sequential number starting from <code>1</code> that is guaranteed to be
unique among all calls to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique()</a> with the same <code class="chemdoc__id">prefix</code> during this
session (page load, etc.).</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--iv_cid" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_cid</a> receives one such value in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifconstructor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_constructor" data-if-entity="909 chemdoc__link-entity-cur">constructor</a>.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique()</a> is similar to <a href="https://underscorejs.org/#uniqueId" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:uniqueId</a>() in Underscore and LoDash.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">unique('my')    //=&gt; 3
unique()        //=&gt; 87
unique('my')    //=&gt; 4
unique('some')  //=&gt; 21
unique('my')    //=&gt; 5</code></pre></fieldset><p>Well-known <code class="chemdoc__id">prefix</code>’es:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">p</th><td rowspan="1" colspan="2"> Used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iv_cid" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_cid</a> (sqimitive’s ID).</td></tr><tr class="chemdoc__first"><th rowspan="1">e</th><td rowspan="1" colspan="2"> Used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> (event handler’s ID).</td></tr><tr class="chemdoc__first"><th rowspan="1">o</th><td rowspan="1" colspan="2"> Used in <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a> (operation’s ID).</td></tr><tr class="chemdoc__first"><th rowspan="1">b</th><td rowspan="1" colspan="2"> Used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> (batch’s ID – group of operations).</td></tr><tr class="chemdoc__first"><th rowspan="1">bg</th><td rowspan="1" colspan="2"> Used in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> (guard’s instance).</td></tr></table></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--sfunique---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L787-L789" target="_blank">lines 787-789</a> (3 lines)                                  &bull; <a href="#Sqimitive-Core--sfunique---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">unique: function (prefix) {
  return this._unique[prefix] = 1 + (this._unique[prefix] || 0)
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--if_batchOptions"
                data-entity='{"type":"func","id":966,"name":"_batchOptions","start":{"line":3546,"column":4,"offset":136208},"end":{"line":3585,"column":4,"offset":138036},"forced":null,"modifiers":["protected"],"file":"main.js"}'
                class="cp-member__header">
              <b>_batchOptions</b>
                              (
                  id [, options]                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  protected                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Options" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Options</a></p><p>Returns information about currently active <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> for use in batched
events.</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>object cloned <code class="chemdoc__id">options</code> with extra keys</td><td rowspan="1" colspan="1"></td></tr></table><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">id</th><td>number </td><td rowspan="1" colspan="1"> Active batch’s identifier as given to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’s <code class="chemdoc__id">func</code></td></tr><tr class="chemdoc__first"><th rowspan="1">object</th><td>object </td><td rowspan="1" colspan="1"> Optional keys to merge into result (batch-specific keys
override them).</td></tr></table><p>Call <a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_batchOptions" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_batchOptions()</a> once for each “operation” when adding custom
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a> events, then pass the result to all operation’s events (e.g.
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet()</a> gives both <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange_OPT" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change_OPT</a> and <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> the same options object).</p><p>You may pass the same object to all events of the same operation (to
allow clients persist data across related events) or you may clone it (to
avoid interference) – but never pass it to events of different operations
or batches.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--if_batchOptions---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L3547-L3586" target="_blank">lines 3547-3586</a> (40 lines)                                  &bull; <a href="#Sqimitive-Core--if_batchOptions---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">_batchOptions: function (id, options) {
  // It might be tempting to optimize cloning away if options was given by
  // mutating and returning options - but that would be erroneous:
  //
  //    var sq1 = new Sqimitive.Base
  //    var sq2 = new Sqimitive.Base
  //    var options = {}
  //
  //    sq1.batch(null, function () {
  //      sq1.set('a', 1, options)
  //
  //      sq2.batch(null, function () {
  //        sq2.set('b', 2, options)
  //
  //        // Expected batched events at this point:
  //        // sq2._batch = [['change_b', 2, undefined, {batchID: 2, ...}]]
  //        // sq1._batch = [['change_a', 1, undefined, {batchID: 1, ...}]]
  //        //
  //        // If _batchOptions() called by set() did not clone options,
  //        // sq1._batch would be [['change_a', ... {batchID: 2, ...}]] -
  //        // note the different batchID. This is because change_a's
  //        // options object was mutated by sq2.set() and now all
  //        // operations where it was used have wrong values (originating
  //        // from last called set()) for those operations.
  //        //
  //        // For example, when change_a is fired its options.batch must
  //        // be [['change_a', 1, undefined, {options...}]] but because
  //        // this key (batch) was overridden (in options) by sq2.set()
  //        // and because change events of b were already dispatched,
  //        // options.batch for change_a would be in fact []!
  //      })
  //    })
  return _.assign({}, options, {
    batch: this._batch,
    batched: this._batched,
    batchID: id,
    operationID: Core.unique('o'),
    trace: Core.trace && (new Error).stack,
  })
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--if_forward"
                data-entity='{"type":"func","id":965,"name":"_forward","start":{"line":3510,"column":4,"offset":134815},"end":{"line":3522,"column":4,"offset":135248},"forced":null,"modifiers":["protected"],"file":"main.js"}'
                class="cp-member__header">
              <b>_forward</b>
                              (
                  prefix, events, sqim, prepend                )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  protected                </p>
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Forwards <code class="chemdoc__id">events</code> occurring on <code class="chemdoc__id">sqim</code> to <code class="chemdoc__id">this</code>, with arguments
<code class="chemdoc__id">prepend</code>’ed.</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td><code class="chemdoc__id">sqim</code></td><td rowspan="1" colspan="1"></td></tr></table><p>Forwarding is done by firing “prefix + event_name” on <code class="chemdoc__id">this</code> (the object
on which <a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_forward" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_forward()</a> is called) with <code class="chemdoc__id">prepend</code> (<code>[sqim]</code> if omitted)
pushed in front of original event’s arguments. <code class="chemdoc__id">event_name</code> is a complete
reference string as given to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfparseEvent" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">parseEvent()</a>, e.g. <code>=foo_</code>.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_forward" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_forward()</a> is used to set up <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childEvents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childEvents</a>, with the <code class="chemdoc__id">prefix</code> of
<code>.</code>.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">d._forward('.', ['render'], o)
d.on('.render', function (o) { alert(o._cid) })
 // now whenever 'render' is fired on o, '.render' is fired on d where
 // it shows the _cid of the object where the original 'render' occurred</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">destination._forward('dlg-', ['change', '-render'], origin, [])</code></pre><p>This example fires <code>dlg-change</code> and <code>dlg--render</code> events on
<code class="chemdoc__id">destination</code> (a Sqimitive) whenever <code class="chemdoc__id">change</code> and <code class="chemdoc__id">render</code> are fired on
<code class="chemdoc__id">origin</code>, keeping original arguments. <code>-render</code> simply means the
forwarded events occur on <code class="chemdoc__id">destination</code> before other handlers of
<code class="chemdoc__id">origin</code> are executed, as per <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>.</p></fieldset></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--if_forward---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L3511-L3523" target="_blank">lines 3511-3523</a> (13 lines)                                  &bull; <a href="#Sqimitive-Core--if_forward---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">_forward: function (prefix, events, sqim, prepend) {
  _.forEach(events.concat(), function (event) {
    var name = prefix + event
    function _forward_() {
      ap.unshift.apply(arguments, prepend || [sqim])
      return this.fire(name, arguments)
    }
    Core.trace && (_forward_.trace = [prefix, events, sqim, prepend])
    sqim.on(event, _forward_, this)
  }, this)

  return sqim
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifautoOff"
                data-entity='{"type":"func","id":955,"name":"autoOff","start":{"line":3069,"column":4,"offset":118652},"end":{"line":3125,"column":4,"offset":120295},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>autoOff</b>
                              (
                  [sqim [, events [, cx]]] | func [, cx]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>A utility method for tracking object connections.</p><p><pre><code class="chemdoc__block prism language-javascript match-braces">this.autoOff(sqim, {})          // add sqim to the list
this.autoOff(sqim, {foo: ...})  // ...and hook some events; cx = this
this.autoOff(sqim, ['foo', ...])        // equivalent
this.autoOff(sqim, {foo: ...}, null)    // ...cx = sqim
this.autoOff(sqim, {foo: ...}, other)   // ...cx = other

this.autoOff()      // off() all sqims tracked so far and clear the list
this.autoOff(sqim)  // off() and un-list sqim, only if it was tracked
this.autoOff(sqim, true)  // just un-list sqim, keep hooks on it

// Iterate over tracked objects:
var found = this.autoOff(sqim =&gt; sqim.get('foo'))</code></pre></p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> has three main forms – tracking, untracking and iterating:</p><ul><li>Adding <code class="chemdoc__id">sqim</code> (an object) to this object’s <code class="chemdoc__id">Set</code> of tracked objects
(<code class="chemdoc__id">_autoOff</code>), optionally hooking <code class="chemdoc__id">events</code> on it – returns <code class="chemdoc__id">sqim</code>.</li><li>Removing all objects from this list and hooks of <code class="chemdoc__id">this</code> on them -
returns <code class="chemdoc__id">this</code>.</li><li>Removing one object, optionally with hooks of <code class="chemdoc__id">this</code> on it – returns
<code class="chemdoc__id">sqim</code>.</li><li>Iterating over objects in this list – calls <code class="chemdoc__id">func</code> for every object
until it returns a value that is not <code class="chemdoc__id">undefined</code> or <code class="chemdoc__id">null</code>; <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a>
returns this value, or last <code class="chemdoc__id">func</code>’s result, or <code class="chemdoc__id">undefined</code> if the list
was empty.</li></ul><p>The list is not used by Sqimitive but your application can use it to
unbind all listeners added by this object to other objects in one go. For
example, you can do <code>this.autoOff()</code> when <code class="chemdoc__id">this</code> is about to be
destroyed so that events on other objects to which <code class="chemdoc__id">this</code> had any
connections won’t trigger its handlers.</p><p><code class="chemdoc__id">events</code>, if given and non-<code class="chemdoc__id">true</code>, is an object in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> format (keys
are comma-separated event references and values are their handlers -
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a>) or an array (hooked in order): <code>['evt', func, 'evt2',
func2, ...]</code>. Commas in event references are allowed even though <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>
only accepts them when <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse</a>’ing.</p><p>With <code class="chemdoc__id">events</code>, <code class="chemdoc__id">cx</code> sets the context in which handlers will be called. If
<code class="chemdoc__id">cx</code> is <code class="chemdoc__id">null</code> then <code class="chemdoc__id">sqim</code> is used, if no <code class="chemdoc__id">cx</code> argument is given then
<code class="chemdoc__id">this</code> is used (i.e. the object on which <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> was called).
<code class="chemdoc__id">sqim</code>’s <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> always receives <code class="chemdoc__id">cx</code> of <code class="chemdoc__id">this</code>.</p><p>Other notes:</p><ul><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> can be called multiple times for one object. This will cause
problems only if supplying the same <code class="chemdoc__id">events</code> (hooks will be added
twice); doing just <code>autoOff(sqim, {})</code> twice is fine, and duplicates
won’t inflate the list because it’s a <code class="chemdoc__id">Set</code>.</li><li>The form <code>autoOff(sqim)</code> doesn’t call <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a> if <code class="chemdoc__id">sqim</code> wasn’t tracked
(better for performance). This works if the code doesn’t manually set up
hooks (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>) on objects-to-be-<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff</a>’d, which is recommended. If it
does, do <code>this.autoOff(sqim).off(this)</code> or <code>this.autoOff(sqim, {})</code>
and later <code>this.autoOff(sqim)</code>.</li><li>It’s safe to call <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> from within <code class="chemdoc__id">func</code> to track or untrack
objects – <code class="chemdoc__id">func</code> will receive each object exactly once. Re-tracking the
same object until the iterating <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> returns will call <code class="chemdoc__id">func</code>
twice for that object (<code class="chemdoc__id">Set</code>’s behaviour). From <code class="chemdoc__id">func</code>, calling
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> without arguments will call <code class="chemdoc__id">func</code> for every object
remaining to be iterated over before that call to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> was made,
regardless of subsequent <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> calls.</li></ul><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Base.html#-chevaoff" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="977 chemdoc__link-entity-cur">chevaoff</a></span></p><ul><li>Use <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childEvents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childEvents</a> to track events of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_children" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_children</a>; use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> to
track events of the outside objects.</li></ul><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">// Track sqim and hook sqim.remove (calls this.remove):
this.autoOff(sqim, {remove: this.remove})

// Equivalent:
this.autoOff(sqim, {remove: 'remove'})

// Track and hook 2 events (both call sqim.render - not this.render!):
this.autoOff(sqim, {'change_foo, change_bar': 'render'}, null)

// Set up a one-time listener that is removed either when sqim fires
// 'loaded' or this calls autoOff() (typically happens in remove()):
var ev = this.autoOff(sqim, {}).once('loaded', 'render', this)
// ...It's also possible to stop listening at any time:
this.cancel = () =&gt; sqim.off(ev)

// Be sure to pass correct cx to on/once for autoOff's off() to work:
autoOff(sqim, {}).once('loaded', 'render')         // WRONG
autoOff(sqim, {}).once('loaded', 'render', sqim)   // CORRECT

// Unbind this instance's events from all sqimitives previously
// enlisted by this.autoOff(sqim, {}) and clear the tracking list:
this.autoOff()

// Unbind from and unlist just one sqimitive:
this.autoOff(sqim)

// Conditionally untrack some objects:
this.autoOff(function (sqim) { sqim.get('foo') &amp;&amp; this.autoOff(sqim) })

// Build an array from tracked objects:
var filtered = []
this.autoOff(function (sqim) {
  if (sqim.get('foo')) {
    filtered.push(sqim)
  }
})</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Array form of events is convenient when keys are not constants:
<pre><code class="chemdoc__block prism language-javascript match-braces">this.autoOff(sqim, ['change_' + prop, 'render', name, 'update'])

// Could be done with computed names in ES6 but it's often longer:
this.autoOff(sqim, {['change_' + prop]: 'render', name: 'update'})

// Equivalent to manual object construction:
var events = {}
events['change_' + prop] = 'render'
events[name] = 'update'
this.autoOff(sqim, events)</code></pre></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Canonical usage:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyNotifyBar = Sqimitive.Base.extend({
  events: {
    owned: function () {
      this.autoOff(new View.LoginForm, {
        loggedIn: function () { alert('Hi there!') },
        '-multiple, events': ...,
      })
    },

    // WRONG: if unnest() is called with any arguments (for whatever
    // the reason) then autoOff()'s behaviour would change and it will
    // not untrack objects. See the note on ev__ danger in on().
    //'-unnest': 'autoOff',

    // WRONG: ES6 'this' is bound to whatever context is calling
    // extend(), see #es6this:
    '-unnest': () =&gt; this.autoOff(),

    // CORRECT:
    '-unnest': function () {
      this.autoOff()
    },

    // CORRECT: masked version:
    '-unnest': 'autoOff-',
  },
})</code></pre><p>Gotcha with the above usage: if you hook using <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> in <code>init()</code>
then those hooks will be removed as soon as the sqimitive is nested
anywhere because <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifnestEx" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.nestEx()</a> calls <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifunnest" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">unnest()</a>. Consider hooking in
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifowned" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">owned()</a> if the class is guaranteed to become nested prior to actual
usage, or check for set <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_parent" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_parent</a> in <code>-unnest</code> before calling
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a>.</p></fieldset><p>As a general rule, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> is not used for permanently connected
objects, i.e. ones that are destroyed at the same time as <code class="chemdoc__id">this</code>. Such
objects are typically set to “_protected” properties and <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifinit" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">init</a>’ialized
during construction:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyGame = Sqimitive.Base.extend({
 // Created together with MyGame and only referenced by MyGame:
  _timer: null,

  events: {
    init: function () {
      this._timer = new MyTimer({interval: 1000})
      this._timer.on({expired:  () =&gt; alert("Time's up!")})
        // on() instead of autoOff({expired: ...})
    },
  },
})</code></pre></p><fieldset class="chemdoc__example"><legend>Example</legend><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> only really calls <code class="chemdoc__id">on</code> and <code class="chemdoc__id">off</code> methods on <code class="chemdoc__id">sqim</code> and can
be used with non-sqimitives if their signatures are compatible. For
example, jQuery’s are partially compatible: <a href="https://api.jquery.com/?s=on" class="chemdoc__custom-link chemdoc__proto-jq" target="_blank">jq:on</a>() is usable (it
ignores <code class="chemdoc__id">cx</code> but you can <code>bind()</code> or use ES6 arrow functions) while
<a href="https://api.jquery.com/?s=off%28%29" class="chemdoc__custom-link chemdoc__proto-jq" target="_blank">jq:off()</a> is not:
<pre><code class="chemdoc__block prism language-javascript match-braces">// Tracking:
this.autoOff($('body'), [
  'onclick.' + this._cid,
  // Need to bind() or use =&gt; as jQuery doesn't accept context object.
  function (e) {
    this.clicked(e.target)
  }.bind(this),
])

// Untracking:
this.autoOff(function (el) {
  if (el instanceof $) {
    el.off('.' + this._cid)
    // Giving true removes object from the list without calling off().
    this.autoOff(el, true)
  }

  // Or, one-liner:
  ;(el instanceof $) &amp;&amp; this.autoOff(el, true).off('.' + this._cid)
})</code></pre></fieldset><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Base.html#-unnestedoff" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="977 chemdoc__link-entity-cur">unnestedoff</a></span></p><p><a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a>’s implementation of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifunnested" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">unnested()</a> calls <code class="chemdoc__id">sqim</code>.<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off</a>(<code class="chemdoc__id">this</code>) to
unregister all event handlers that might have been previously attached to
the removed child by this instance (provided they were not hardwired with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> and used <code>cx === this</code>).</p><p>Because of this, there’s no need to track and explicitly unsubscribe from
children (regardless of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_owning" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_owning</a>):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend({
  events: {
    init: function () {
      var child = this.nest(new MyClass.Child)
      this.autoOff(child, {changed: 'recalc'})
    },

    unnested: function (sqim) {
      this.autoOff(sqim)
    },
  },

  recalc: ...
})</code></pre></p><p>The above is redundant and can be simplified, provided that the context
given to <code>on()</code> is <code class="chemdoc__id">this</code> as below:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend({
  events: {
    init: function () {
      var child = this.nest(new MyClass.Child)
      // this (_parent) will call off(this) on child when child is unnested().
      child.on('changed', 'recalc', this)
    },
  },

  recalc: ...
})</code></pre></p><p>If you are hooking all children then use <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childEvents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childEvents</a> to further
simplify the task:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyGame = Sqimitive.Base.extend({
  _childEvents: ['changed'],

  events: {
    '.changed': 'recalc',
  },

  recalc: ...
})</code></pre></p><h3 id="A49f20375db" class="chemdoc__h1">Garbage collection</h3><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> prevents <code class="chemdoc__id">sqim</code> from being garbage-collected by creating a
reference from <code class="chemdoc__id">this</code> to <code class="chemdoc__id">sqim</code>. (<code class="chemdoc__id">WeakSet</code> would be a solution if only
it supported enumeration.)</p><p>Normally, <code>sqim.on(..., this)</code> results in a reference to <code class="chemdoc__id">this</code> being
stored in <code class="chemdoc__id">sqim</code> so that if <code class="chemdoc__id">sqim</code> is not referenced anywhere else (e.g.
it is not <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifnest" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">nest</a>’ed) then it will be freed even if <code class="chemdoc__id">this</code> remains alive.</p><p>However, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a> additionally lists <code class="chemdoc__id">sqim</code> in the <code class="chemdoc__id">_autoOff</code> <code class="chemdoc__id">Set</code> of
<code class="chemdoc__id">this</code>, creating a two-way link; now both <code class="chemdoc__id">sqim</code> and <code class="chemdoc__id">this</code> may only be
freed together. Imagine a long-term “server” object (<code class="chemdoc__id">this</code>) and
short-term “clients” (<code class="chemdoc__id">sqim</code>): <code class="chemdoc__id">this</code>-server <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifautoOff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">autoOff()</a>-s (tracks) new
<code class="chemdoc__id">sqim</code>-client, then <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifunnest" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">unnest()</a>-s the latter at some point. Even though
clients are not referenced anywhere except server’s <code class="chemdoc__id">_autoOff</code>, they will
be kept alive until the server itself is destroyed.</p><p>Addressing this is application-specific but one common way is to hook
<code class="chemdoc__id">sqim</code>’s <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifunnest" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">unnest</a> (or <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifremove" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.remove()</a>) and remove it from <code class="chemdoc__id">_autoOff</code>
(<code class="chemdoc__id">this</code> = server):
<pre><code class="chemdoc__block prism language-javascript match-braces">this.autoOff(client, {
  ...,
  remove: function () {
    this.autoOff(client)
  },
})</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifautoOff---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L3070-L3126" target="_blank">lines 3070-3126</a> (57 lines)                                  &bull; <a href="#Sqimitive-Core--ifautoOff---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">autoOff: function (sqim, events, cx) {
  var list = this._autoOff

  switch (arguments.length) {
    case 0:
      if (list && list.size) {
        this._autoOff = null
        list.forEach(function (sqim) { sqim.off(this) }, this)
      }
      return this

    case 1:
    case 2:
      if (typeof sqim == 'function') {
        var res
        list && list.forEach(function (item) {
          // Can't break out of Set's forEach().
          res = res == null && sqim.call(events || this, item)
        }, this)
        return res
      } else if (arguments.length == 1 || events === true) {
        if (list && list.delete(sqim)) {
          events === true || sqim.off(this)
        }
        return sqim
      }

      cx = this
    default:
      ;(list || (this._autoOff = new Set))
        .add(sqim)

      var self = this

      function bind(func, name) {
        // For sqim.off(this) to work, on()'s cx must be this. If user wants
        // another context, bind the func.
        if (cx !== self) {
          func = Core.expandFunc(func, cx || sqim)
        }
        var names = name.split(', ')
        for (var i = 0, l = names.length; i < l; i++) {
          sqim.on(names[i], func, self)
        }
      }

      if (_.isArray(events)) {
        for (var i = 1, l = events.length; i < l; i += 2) {
          bind(events[i], events[i - 1])
        }
      } else {
        _.forEach(events, bind)
      }

      return sqim
  }
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifbatch"
                data-entity='{"type":"func","id":972,"name":"batch","start":{"line":4168,"column":4,"offset":164149},"end":{"line":4256,"column":4,"offset":167294},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>batch</b>
                              (
                  sqims, func [, cx]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Options" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Options</a></p><p>Calls <code class="chemdoc__id">func</code> and defers certain events it has produced on <code class="chemdoc__id">this</code> and
<code class="chemdoc__id">sqims</code> until <code class="chemdoc__id">func</code> returns.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> is the backend used in Sqimitive to defer <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> and
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange_OPT" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change_OPT</a> events produced by <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet()</a> (and its <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a> wrapper).
Clients may use it for other events.</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>mixed as returned by <code class="chemdoc__id">func</code></td><td rowspan="1" colspan="1"></td></tr></table><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="2">sqims</th><td>null</td><td rowspan="2" colspan="1"> Sqimitives to defer and to share the same batch ID
with. If array, fails if <code class="chemdoc__id">this</code> or any <code class="chemdoc__id">sqims</code> has an active batch.
First member is ignored if it’s <code class="chemdoc__id">this</code>. If you need several sqimitives
to be batched but don’t require special effects of having them in one
batch, do nested <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> calls with <code class="chemdoc__id">sqims</code> of <code class="chemdoc__id">null</code>.</td></tr><tr><td> array </td></tr><tr class="chemdoc__first"><th rowspan="1">func</th><td rowspan="1" colspan="2"> Receives current batch <code class="chemdoc__id">id</code>. May push to <code>sqim._batch</code>.</td></tr><tr class="chemdoc__first"><th rowspan="2">cx</th><td>object</td><td rowspan="2" colspan="1"> The context for <code class="chemdoc__id">func</code></td></tr><tr><td> null/omitted use <code class="chemdoc__id">this</code> </td></tr></table><p>Some options may be related so that changing one causes a refresh based
on values of other options. For example, 2D coordinates consist of <code class="chemdoc__id">x</code>
and <code class="chemdoc__id">y</code>; <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a>’ing them one by one (e.g. first <code class="chemdoc__id">x</code>, then <code class="chemdoc__id">y</code>) will
cause multiple refreshes but only the last will use actual (new) values
and others may use partially updated state (resulting in an object moving
from <code class="chemdoc__id">x1</code>/<code class="chemdoc__id">y1</code> to <code class="chemdoc__id">x2</code>/<code class="chemdoc__id">y1</code>, then to <code class="chemdoc__id">x2</code>/<code class="chemdoc__id">y2</code> rather than straight to
<code class="chemdoc__id">x2</code>/<code class="chemdoc__id">y2</code>). <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> groups <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> events and fires them after setting
all values instead of after setting each value.</p><p>Once <code class="chemdoc__id">func</code> returns, the batch ends and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> starts dispatching the
events. During this process, if a hook on a <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> event (generated by
<code class="chemdoc__id">func</code>) creates a new batch, that batch’s events will be dispatched after
events of the current batch. Therefore, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> may return much later
than <code class="chemdoc__id">func</code> as there may be numerous pending batches.</p><p>Special fields in <code class="chemdoc__id">options</code> of batched events (added by
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_batchOptions" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_batchOptions()</a>):</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">batch</th><td>array </td><td rowspan="1" colspan="1"> Events in the batch being dispatched, in <code>this._batch</code>
format; custom <code class="chemdoc__id">eventIndex</code> property points to the entry handled by the
current <code>^</code> handler (<a href="../Sqimitive/c_Core.html#-naor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">naor</a>); for regular non-<code>^</code> handlers it’s <code class="chemdoc__id">null</code>
and <code class="chemdoc__id">batch</code> itself omits already fired events (current event is the
first member hence <code class="chemdoc__id">batch</code> is never empty); can be mutated except for
the current member (<code class="chemdoc__id">eventIndex</code>’th if <code>^,</code> else 0); doesn’t include
events of the later pending batches.</td></tr><tr class="chemdoc__first"><th rowspan="1">batchID</th><td>int </td><td rowspan="1" colspan="1"> A <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique</a> batch ID; tells if two <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> events
originated from the same <code class="chemdoc__id">func</code></td></tr><tr class="chemdoc__first"><th rowspan="1">batched</th><td>array of [sqim, batch] </td><td rowspan="1" colspan="1"> <code class="chemdoc__id">this</code> and <code class="chemdoc__id">sqims</code> given to the “main”
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>, with their respective <code class="chemdoc__id">batch</code> arrays.<p>From inside a <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> listener, each <code class="chemdoc__id">batched</code> member can be classified
as a sqimitive that:</p><ul><li>…is currently firing batched events (always exactly one such member
per <code class="chemdoc__id">batched</code>; its batched array is <code>=== options.batch</code>)</li><li>…has finished firing events of this <code class="chemdoc__id">batchID</code> (batched array is
empty; do not change it, the batch won’t “resume”)</li><li>…is yet to start firing batched events (after the current
<code>options.batch</code> becomes empty)</li></ul></td></tr><tr class="chemdoc__first"><th rowspan="1">operationID</th><td>int </td><td rowspan="1" colspan="1"> A <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique</a> identifier of the event group; tells if
events originated from the same <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet()</a> call.</td></tr><tr class="chemdoc__first"><th rowspan="2">trace</th><td>str</td><td rowspan="2" colspan="1"> Set to the stack trace of the batch entry’s creation
if <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivtrace" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">Core.trace</a> was enabled.</td></tr><tr><td> null </td></tr></table><p>Other notes:</p><ul><li>Given two members (<code class="chemdoc__id">sqims</code>) of the same batch, <code>options.batchID</code> of
their <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> events are equal but <code>sqim._batch</code> are equal only for
events of the same sqimitive (IDs are shared but <code class="chemdoc__id">_batch</code> instances are
not).</li><li>Any combination of recursive <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a>/<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> is allowed. <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>
inside a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> just calls <code class="chemdoc__id">func</code> (or fails depending on <code class="chemdoc__id">sqims</code>).
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> after <code class="chemdoc__id">func</code> (i.e. by a hook on a <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a>) defers events to a
new group dispatched after the original <code class="chemdoc__id">func</code>’s events are done.</li><li>An exception in any <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> handler drops all pending events, both of
the same batch and of pending batches.</li><li>Batched events across multiple <code class="chemdoc__id">sqims</code> are dispatched not in order of
their operation calls (e.g. <code class="chemdoc__id">O1</code> on <code class="chemdoc__id">sqim1</code>, <code class="chemdoc__id">O2</code> on <code class="chemdoc__id">sqim2</code>, <code class="chemdoc__id">O3</code> on
<code class="chemdoc__id">sqim1</code>) but in groups per each member of <code class="chemdoc__id">sqims</code>, starting from the
last one (<code class="chemdoc__id">O2</code> on <code class="chemdoc__id">sqim2</code>, <code class="chemdoc__id">O1</code> on <code class="chemdoc__id">sqim1</code>, <code class="chemdoc__id">O3</code> on <code class="chemdoc__id">sqim1</code>). Order
within a group is guaranteed but order of groups is an internal detail
that should not be relied upon.</li></ul><fieldset class="chemdoc__example"><legend>Example</legend>Consider an object with <code class="chemdoc__id">width</code> and <code class="chemdoc__id">height</code> <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_opt" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">Base._opt</a>’ions bound to
a DOM node:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Rect = new Sqimitive.jQuery.extend({
  _opt: {width: 0, height: 0},
  events: {
    change_width: '_recalc',
    change_height: '_recalc',
  },
  _recalc: function () {
    var w = this.get('width')
    var h = this.get('height')
    this.el.css({width: w, height: h})
  },
})</code></pre>
Calling <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a> would trigger two pairs of events:
<pre><code class="chemdoc__block prism language-javascript match-braces">var obj = new Rect
obj.set('width', 10)
  // fires change_width and change
  // obj's options = {width: 10, height: 0}
  // el's size = 10*0
obj.set('height', 20)
  // fires change_height and change
  // obj's options = {width: 10, height: 20}
  // el's size = 10*20</code></pre>
As seen, <code class="chemdoc__id">el</code> would undergo two dimension changes of which the first is
redundant because after <code class="chemdoc__id">width</code> the caller immediately supplies
<code class="chemdoc__id">height</code>. In contrast, doing so in a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a>:
<pre><code class="chemdoc__block prism language-javascript match-braces">obj.batch(null, function () {
  obj.set('width', 10)
  obj.set('height', 20)
})
  // fires change_width, change, change_height, change - all after
  // the batch'ed function returns; change_width sets el's size to
  // 10*20, as does change_height</code></pre>
There are still two dimension changes (<code class="chemdoc__id">_recalc</code> calls) but the second
sets the same size and is optimized by the browser.<p>If <code class="chemdoc__id">_recalc</code> were doing heavy calculations, it could skip them by using
an internal option like so:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Rect = new Sqimitive.jQuery.extend({
  _opt: {width: 0, height: 0, _recalced: ''},
  events: {
    change_width: '_ifRecalc',
    change_height: '_ifRecalc',
    change__recalced: '_recalc',
  },
  _ifRecalc: function () {
    this.set('_recalced', this.get('width') + '*' + this.get('height'))
  },
  _recalc: function () { /* as above */ },
})</code></pre></p></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Demonstration of batch ID:
<pre><code class="chemdoc__block prism language-javascript match-braces">me.on('change', function (name, now, old, options) {
  console.log(name + ' during batch ' + options.batchID)
})

me.set('foo', 123)      //=&gt; foo during batch 1 (implicit batch)
me.set('foo', 456)      //=&gt; foo during batch 2 (implicit batch)

me.batch(null, function () {
  me.set('foo', 789)    //=&gt; foo during batch 3
  me.set('bar', 123)    //=&gt; bar during batch 3
})

me.batch(null, function () {
  me.set('bar', 456)    //=&gt; bar during batch 4
})</code></pre>
Batch-after-batch:
<pre><code class="chemdoc__block prism language-javascript match-braces">me.on('change_foo', function () {
  me.set('bar', 456)
})

me.batch(null, function () {
  me.set('foo', 123)    //=&gt; foo during batch 1
})
  // Logged after func returns but before batch() returns:
  //=&gt; bar during batch 2</code></pre>
Nested <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> vs <code class="chemdoc__id">sqims</code> and <code class="chemdoc__id">null</code> <code class="chemdoc__id">sqims</code> vs array:
<pre><code class="chemdoc__block prism language-javascript match-braces">me.batch(null, function () {
  you.batch(null, function () {
    me.set('foo', 123)    // options.batchID == 1
    you.set('bar', 456)   // options.batchID == 2 (different)
  })
})

me.batch([you], function () {
  me.set('foo', 123)      // options.batchID == 3
  you.set('bar', 456)     // options.batchID == 3 (same)
})

me.batch([], function () {
  me.batch([], ...)       // throws - a batch already active on me
})</code></pre></fieldset><h3 id="-naor" class="chemdoc__h1 chemdoc__anchored">“Natural” order<a class="chemdoc__anchor chemdoc__header-anchor" href="#-naor">naor</a></h3><p>Normally, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> calls accumulated events in order of changes so that
last change dispatches its events last while events in response to a
batch (by hooks on events it’s dispatched) are fired after that batch’s
own events.</p><p>To illustrate the issue, consider this class:
<pre><code class="chemdoc__block prism language-javascript match-braces">Sqimitive.Base.extend({
  _opt: {
    original: '123',
    linked: null,
  },

  events: {
    change_original: function (now) { this.set('linked', now) },
    change: function (opt) { console.log('change of ' + opt) },
  },
})</code></pre></p><p>When calling <code>set('original', 'new')</code> on such an object, logically you
would expect these events: <code class="chemdoc__id">change_original</code>, <code class="chemdoc__id">change</code> of <code class="chemdoc__id">original</code>,
<code class="chemdoc__id">change_linked</code>, <code class="chemdoc__id">change</code> of <code class="chemdoc__id">linked</code>. However, with a naive
implementation handling <code class="chemdoc__id">change_original</code> would trigger <code class="chemdoc__id">change_linked</code>,
then <code class="chemdoc__id">change</code> of <code class="chemdoc__id">linked</code> and only then – <code class="chemdoc__id">change</code> of <code class="chemdoc__id">original</code>.</p><p>This would be also a problem if changing the same option from within its
own event handler because <code class="chemdoc__id">change</code> with the new value would be fired
first (since <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a> was called last), then when the original <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifset" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">set()</a>
returns it would also fire <code class="chemdoc__id">change</code> but this time with the original (now
old!) value.</p><p>Notwithstanding, rarely a handler must be notified of the change
immediately (sort of “out of band data”). <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> calls listeners whose
event name starts with <code>^</code> immediately after <code class="chemdoc__id">func</code> returns, even if
there are events of earlier-created batches yet to be dispatched. While
normal listeners can be seen as an asynchronous event bus, <code>^</code> are closer
to direct function calls.</p><p>For example, let’s assume two objects: one an array of 2D points, another
its index (array of points on the given Y axis). The index must be kept
in sync so that clients accessing it at any point in time see no
discrepancies with the main array (the only exception we allow is inside
the same <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a> <code class="chemdoc__id">func</code>).</p><p><pre><code class="chemdoc__block prism language-javascript match-braces">var Points = Sqimitive.Base.extend({
  points: [],

  add: function (point) {
    this.points.push(point)
    this.batch(null, id =&gt; this._batch.push(['added', point]))
  },

  added: Sqimitive.Core.stub,
})

var Index = Sqimitive.Base.extend({
  byY: {},

  events: {
    init: function (opt) {
      this.autoOff(opt.points, {
        added: '_added',
        //'^added': '_added',
      })
    },
  },

  _added: function (point) {
    (this.byY[point.y] || (this.byY[point.y] = [])).push(point)
  },
})

var points = new Points
var index = new Index({points})
points.add({x: 0, y: 0})
  // index.byY = {0: [{...}]}
points.add({x: 1, y: 1})
  // index.byY = {0: [{...}], 1: [{...}]}</code></pre></p><p>The above implementation works but at the first glance only:
<pre><code class="chemdoc__block prism language-javascript match-braces">var points = new Points
var index = new Index({points})

points.on('change_foo', function () {
  console.dir(index.byY)      // (1)
  points.add({x: 2, y: 2})
  console.dir(index.byY)      // (2)
})

points.add({x: 0, y: 0})
points.set('foo', 123)
console.dir(index.byY)        // (3)</code></pre></p><p>Both (1) and (2) output the same result: <code>{0}</code> while (3) outputs
<code>{0, 2}</code>. Why output of (2) is the same as of (3)? Because <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet()</a>
uses <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a>, it delays dispatching events of other batches (<code class="chemdoc__id">added</code> in
our case) until its own events are finished. <code class="chemdoc__id">change_foo</code> calls <code>add()</code>
which creates a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a> (queued after the currently executing <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet</a>’s
batch) and pushes <code class="chemdoc__id">added</code> to it (to be dispatched after <code>set('foo')</code>
returns, hence (3) showing expected result). In contrast, if <code class="chemdoc__id">Index</code>
hooks <code>'^added'</code> then it becomes exempt from this delay and causes
<code>_added()</code> to be called after <code>points.add({x: 2, y: 2})</code> returns (or,
precisely, upon returning from <code class="chemdoc__id">func</code> <code>id =&gt; ...</code> given to <code>batch()</code>
inside <code>add()</code>) and the index to be updated.</p><p><code>^</code> makes it “closer” to direct function call but not exactly that: such
handler is called once the batch closes (<code class="chemdoc__id">func</code> returns), not once a
corresponding event if queued (“function is called”). Below, <code>add()</code> runs
inside an already active batch so no index update takes place then:
<pre><code class="chemdoc__block prism language-javascript match-braces">points.batch(null, function () {
  points.add({x: 3, y: 3})
    // points._batch = [['added', {x: 3, y: 3}]]
  console.dir(index.byY)
    //=&gt; {}
})
console.dir(index.byY)
  //=&gt; {3: [{...}]}</code></pre></p><p><code>^</code> has no special meaning for dispatching initiated by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> and,
consequently, in <code>=</code>wrapped handlers (<a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>; compare <code class="chemdoc__id">eventIndex</code>
with <code class="chemdoc__id">null</code> to determine the phase).</p><p><code>^</code> separates firing into two groups which are then ordered by priority.
This means that in response to a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch</a>, <code>^0^event</code> will run before
<code>-1^event</code> even though the latter has lower priority.
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on('^0^event', () =&gt; console.log(0))
sqim.on('-1^event', () =&gt; console.log(-1))

sqim.fire('event')      // outputs -1, 0

sqim.batch(null, function () {
  this._batch.push(['event'])
})    // outputs 0, -1</code></pre></p><h3 id="A3235ed740c" class="chemdoc__h1">Custom events</h3><p>You can defer arbitrary events from within <code class="chemdoc__id">func</code> by pushing an array to
<code>sqim._batch</code>, with first member being event name and others being its
arguments. Because <code class="chemdoc__id">sqims</code> is rarely used, <code class="chemdoc__id">sqim</code> here is typically
<code class="chemdoc__id">this</code>.</p><p>For consistency with Sqimitive’s <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ififSet" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">ifSet()</a>, provide hooks with
information (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--if_batchOptions" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_batchOptions()</a>) about the current batch.</p><p><pre><code class="chemdoc__block prism language-javascript match-braces">this.batch(function (id) {
  this._batch.push(['firstOff', 'pa', 'ra', 'ms'])
  // Or, better:
  var options = {batch: this._batch, batchID: id, operationID: Core.unique('o')}
  this._batch.push(['firstOff', 'pa', 'ra', 'ms', options])
  // Or, best:
  this._batch.push(['firstOff', 'pa', 'ra', 'ms', this._batchOptions(id)])
})
  // does fire('firstOff', ['pa', 'ra', 'ms'...]) when func returns</code></pre></p><p>Once batched events start firing, the batch is considered “closed”. This
typically means that <code class="chemdoc__id">_batch</code> will no longer change, allowing heavy
update functions to process all batched events as one unit in response to
the first event such a function is interested in, remembering its batch
ID and ignoring subsequent events with the same ID. Remembering the ID
might be simpler than maintaining a hash of current state (<code class="chemdoc__id">_recalced</code>)
as in the earlier <code class="chemdoc__id">Rect</code> example:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Rect = new Sqimitive.jQuery.extend({
  _opt: {width: 0, height: 0},
  _lastBatch: 0,
  events: {
    change_width: '_ifRecalc',
    change_height: '_ifRecalc',
  },
  _ifRecalc: function (now, old, options) {
    if (this._lastBatch != options.batchID) {
      this._lastBatch = options.batchID
      this._recalc()
    }
  },
  _recalc: function () {
    var w = this.get('width')
    // ...
  },
})</code></pre>
Or the ID itself may be seen as a kind of hash:
<pre><code class="chemdoc__block prism language-javascript match-braces">var Rect = new Sqimitive.jQuery.extend({
  _opt: {width: 0, height: 0, _lastBatch: 0},
  events: {
    change_width: '_ifRecalc',
    change_height: '_ifRecalc',
    change__lastBatch: '_recalc',
  },
  _ifRecalc: function (now, old, options) {
    this.set('_lastBatch', options.batchID)
  },
  _recalc: function () { /* as above */ },
})</code></pre></p><h3 id="-skb" class="chemdoc__h1 chemdoc__anchored">Skipping known batches<a class="chemdoc__anchor chemdoc__header-anchor" href="#-skb">skb</a></h3><p>Things get hairy if your “<code class="chemdoc__id">_ifRecalc</code>” handler is attached to multiple
sqimitives and processes all batched sqimitives as one, rather than each
batched sqimitive’s events as one:
<pre><code class="chemdoc__block prism language-javascript match-braces">function update(options) {
  if (!skip(options)) {    // read below
    _.each(options.batched, function (item) {
      // item[0] is a sqimitive.
      _.each(item[1], function (event) {
        // Any change must cause an update. Or can check event[1] if
        // only some _opt'ions cause it. Don't use event[0] == 'change_OPT'
        // as it will never match since change_OPT is fired prior to
        // change and is already removed from batched by the time update()
        // runs.
        if (event[0] == 'change') {
          // ...
  }
}

sqim1.on('change', (name, now, old, options) =&gt; update(options))  // (1)
sqim2.on('change', (name, now, old, options) =&gt; update(options))  // (2)
sqim3.on('change', (name, now, old, options) =&gt; update(options))  // (3)</code></pre></p><p>Now, <code>update()</code> should ignore batches that it has seen. Previously used
<code>!=</code> fails short since there may be events of other sqimitives fired
between batched events of one sqimitive, as below:
<pre><code class="chemdoc__block prism language-javascript match-braces">var lastBatch = 0
function skip(options) {
  if (lastBatch != options.batchID) {
    lastBatch = options.batchID
  } else {
    return true
  }
}

sqim3.on('change', function () {    // (4)
  sqim2.set('quux', 789)
})
sqim1.batch([sqim3], function () {  // (5)
  sqim1.set('foo', 123)
  sqim3.set('bar', 456)
})
  // When batch()'s func returns, first event to be fired happens to be
  // sqim3 change_bar, handled by (3). skip() receives options.batchID
  // of N, storing it in lastBatch. Then, change_bar is handled by (4),
  // which starts another batch (N + 1) that is closed immediately after
  // set() in (4). This triggers (2), where skip() stores N + 1 in
  // lastBatch. But now, the pending sqim1 change_foo from (5) triggers
  // (1) where skip() sees options.batchID of N and considers this batch
  // to be "new", even though it was already processed in response to (3).</code></pre></p><p>Another incorrect solution would be to skip all batches with the same or
lower ID than previously seen. After all, <code class="chemdoc__id">batchID</code> is guaranteed to be
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfunique" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">unique</a> and growing. However, the ID is generated when a batch starts
(before calling <code class="chemdoc__id">func</code>), not when the first batched event is dispatched:
<pre><code class="chemdoc__block prism language-javascript match-braces">var lastBatch = 0
function skip(options) {
  if (lastBatch &lt; options.batchID) {
    lastBatch = options.batchID
  } else {
    return true
  }
}

sqim1.batch(null, function () {
  sqim1.set('foo', 123)
  sqim3.set('bar', 456)   // not part of sqim1's batch!
})
  // batch() has allocated the batchID of N before calling func.
  // Then, before batch()'s func returns, sqim3 change_bar is fired
  // since this time sqim3 is not part of batch()'s sqims list (the
  // batchID for change_bar is N + 1). This triggers (3), where
  // skip() stores N + 1 in lastBatch. Then sqim3.set() returns, then
  // sqim1.batch()'s func returns and fires the delayed sqim1 change_foo,
  // to which (1) responds. skip() compares lastBatch of N + 1 with
  // options.batchID of N and decides this batch is not "new".</code></pre></p><p>To summarize, a handler hooked onto multiple objects must store the
actual list of <code class="chemdoc__id">batchID</code>-s it has seen. Most straightforward approach is
to have a round-robin array holding up to N last IDs but choosing N is
not trivial – make it too large and you will be wasting memory; make it
too small and you will be identifying old batches as new.</p><p>Instead of hardcoding any such value, we may rely on the fact that a
given <code class="chemdoc__id">batchID</code> can never reappear after the batch ends and that
<code>options.batched</code> may not change after the batch has started. We can
keep only as many IDs in the list as there are currently active batches.
On the first event, push <code class="chemdoc__id">batchID</code> to the list and push an internal event
to each of the batched sqimitive’s current batch. When the event fires N
times, we pop that <code class="chemdoc__id">batchID</code> (N = count of batched sqimitives, except
ones with empty – already drained – batches).
<pre><code class="chemdoc__block prism language-javascript match-braces">var seenBatches = new Set
function skip(options) {
  if (seenBatches.size == seenBatches.add(options.batchID).size) {
    // Already saw this batchID.
    return true
  } else {
    // Event is firing in the batch for the first time, across all
    // batched sqimitives. Wait for all sqimitives to drain this batch.
    var event = 'mySkip' + Core.unique('mySkip')
    var remaining = 0
    _.each(options.batched, function (item) {
      if (item[1].length) {
        remaining++
        item[1].push([event])
        item[0].once(event, function () {
          --remaining || seenBatches.delete(options.batchID)
        })
      }
    })
    // Instead of hooking every batched sqimitive, we could hook only
    // batched[0] since it will fire its events last. However, the order
    // in which batched sqimitives are processed is an internal detail.
  }
}</code></pre></p><p>Use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfbatchGuard" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">batchGuard()</a> that implements this algorithm in a generalized form.</p><h3 id="Acaa42982a6" class="chemdoc__h1">Listening for batch end</h3><p>Occasionally you need to do some clean-up when all batched events finish
but before the next batch starts firing. One way would be to override
<code>batch()</code> itself, tap into <code class="chemdoc__id">func</code> and push some internal event into
<code class="chemdoc__id">_batch</code> as the client-provided <code class="chemdoc__id">func</code> returns. This is the only option
when you need to react to every batch, but usually the clean-up is
necessary only if certain events occurred during a batch, similarly to
<code class="chemdoc__id">try</code>/<code class="chemdoc__id">finally</code> (except an exception breaks the batch). In this case you
can push the internal event to <code>options.batch</code> or <code>options.batched</code>
from within a listener as done in the example in <a href="../Sqimitive/c_Core.html#-skb" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">skb</a>.</p><fieldset class="chemdoc__example"><legend>Example</legend>With the above <code class="chemdoc__id">Rect</code> class, we know that <code class="chemdoc__id">change_width</code> and
<code class="chemdoc__id">change_height</code> may trigger a lengthy synchronous process (as a result
of the <code class="chemdoc__id">_ifRecalc</code> listener) and we want to show hourglass cursor to the
user until <code class="chemdoc__id">_recalc</code> returns, i.e. the batch ends:
<pre><code class="chemdoc__block prism language-javascript match-braces">var rect = new Rect
var sym = Symbol()
var waiting = 0
rect.on('-change_width, -change_height', function (now, old, options) {
  if (!options.batch[sym]) {
    $('body').css('cursor', 'wait')
    options.batch.push(['restoreCursor'])
    // Fire restoreCursor only once per batch, even if there are other
    // change events pending.
    options.batch[sym] = true
    // This counter is in case we hook several Rect-s or other objects
    // controlling the cursor.
    // We could also use the counter alone, ditching Symbol and allowing
    // duplicate restoreCursor events per batch but that'd be slightly
    // less efficient.
    waiting++
  }
})
rect.on('restoreCursor', function () {
  --waiting || $('body').css('cursor', '')
})</code></pre>
In a real application you should make lengthy processes async to avoid
freezing the UI. Luckily, <a href="../Sqimitive/c_Async.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="824 chemdoc__link-entity-cur">Async</a> exists just for that.</fieldset><p>Generally speaking, it is permitted to modify <code>options.batch</code> in other
ways as well, except touching the member corresponding to the event being
fired. However, this is not recommended as it may quickly become
unmanageable. In particular, since the order in which listeners are
called is hard to predict, there is no guarantee that the batch update
function alike to <code class="chemdoc__id">_recalc</code> above will be affected by these modifications
(such as an added or removed <code class="chemdoc__id">change_width</code>) because it might have
already executed. Or, with the <code>skip()</code> function example in <a href="../Sqimitive/c_Core.html#-skb" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">skb</a>,
appending a new <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifchange" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">change</a> event that would trigger <code>update()</code> will cause
<code>skip()</code> to wrongly report a batch with such event as “new” because
<code>skip()</code>’s internal on-batch-end listener has already deleted <code class="chemdoc__id">batchID</code>
from <code class="chemdoc__id">seenBatches</code>.</p><p>This problem does not exist for internal events like <code class="chemdoc__id">restoreCursor</code> and
<code class="chemdoc__id">mySkip</code> that are not used outside of their private scope.</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifbatch---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L4169-L4257" target="_blank">lines 4169-4257</a> (89 lines)                                  &bull; <a href="#Sqimitive-Core--ifbatch---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">batch: function (sqims, func, cx) {
  var id = this._batchID || (this._batchID = Core.unique('b'))

  if (sqims) {
    if (this._batch) {
      // Disallowing as active batch's ID cannot change.
      throw new Error('Batch already active')
    }

    var i = +(sqims[0] === this)

    if (sqims.length > i) {
      var sqim = sqims[i]
      // Start a batch across multiple sqimitives.
      if (!sqim._batch) {
        // If !!_batch, don't overwrite (call batch() and let it throw).
        sqim._batchID = id
        sqim._batched = this._batched
      }
      func = sqim.batch.bind(sqim, sqims.slice(i + 1), func, cx || this)
    }
  }

  // Batch already active, append.
  if (this._batch) {
    return func.call(cx || this, id)
  }

  var batch = this._batch = []
  var outermost = !this._batches
  outermost ? this._batches = [batch] : this._batches.push(batch)
  this._batched.push([this, batch])

  try {
    try {
      var res = func.call(cx || this, id)
    } finally {
      // Multi-sqim batch must not only start simultaneously but also finish
      // (i.e. clear _batch, etc.) on all sqims at once. If each sqim would
      // finish after its own func has returned, this would fail:
      //
      //   sqim2.on('^change_foo', function () {
      //     sqim1.batch([sqim2], function () {   // (1)
      //       sqim2.set('foo', 456)
      //     })
      //   })
      //
      //   sqim2.set('foo', 123)                  // (2)
      //
      // (2) triggers change_foo which calls (1), whose func queues another
      // change_foo. Before sqim1.batch() returns, sqim2.batch([]) (called
      // by the former) would first clear _batch on itself, i.e. sqim2 (but
      // not sqim1!), then proceed to dispatching queued events on sqim2.
      // After that sqim2.batch() would return and sqim1.batch() would clear
      // _batch on sqim1. In the example, sqim2.batch() dispatches
      // change_foo, reentering the hook which calls (1) and fails with
      // "batch active on sqim1" because sqim2._batch would be null but
      // sqim1._batch would be not.
      _.forEach(this._batched, function (item) {
        item[0]._batch = item[0]._batchID = null
        item[0]._batched = []
      })
    }

    batch.eventIndex = -1

    for (var item; item = batch[++batch.eventIndex]; ) {
      this.fire(item[0], item.slice(1), false)
    }

    batch.eventIndex = null

    // Outermost batch has finished but hooks on events that it has produced
    // could have added new batches. Process them until the queue is
    // exhaused.
    if (outermost) {
      while (batch = this._batches.shift()) {
        while (batch.length) {
          this.fire(batch[0][0], batch[0].slice(1), true)
          batch.shift()
        }
      }
    }

    return res
  } finally {
    outermost && (this._batches = null)
  }
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifconstructor"
                data-entity='{"type":"func","id":910,"name":"constructor","start":{"line":142,"column":2,"offset":4752},"end":{"line":147,"column":2,"offset":5063},"forced":true,"modifiers":["constructor"],"file":"main.js"}'
                class="cp-member__header">
              <b>constructor</b>
                              (
                                  )
                          </dt>
            <dd class="cp-member__info">
                              <p class="cp-member__mods">
                  Modifiers:
                  constructor                </p>
                                            <div class="fmt"><p>
Assigns new unique <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iv_cid" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_cid</a> (a string: <code class="chemdoc__id">p</code> + unique positive number) and
clones all instance properties of self that are not listed in
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_shareProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_shareProps</a>. Cloning puts a stop to accidental static sharing of
properties among all instances of a class where those properties are
defined.</p></div>
                                          <p class="cp-member__file "
                 id="Sqimitive-Core--ifconstructor---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L143-L143" target="_blank">line 143</a>                              </p>
                          </dd>
                      <dt id="Sqimitive-Core--iffire"
                data-entity='{"type":"func","id":948,"name":"fire","start":{"line":2317,"column":4,"offset":87270},"end":{"line":2326,"column":4,"offset":87686},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>fire</b>
                              (
                  event [, args [, inBatch]]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Triggers an event giving <code class="chemdoc__id">args</code> as parameters to all registered
listeners. Returns result of the last called listener that was eligible
for changing it.</p><p>The actual event processing is performed by static <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::fire()</a>.</p><p>It’s safe to add/remove new listeners while <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> is executing – they
will be in effect starting with the next <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> call (even if it’s
nested).</p><p><a id="-fireOverride" class="chemdoc__anchor chemdoc__anchor_token" href="#-fireOverride">fireOverride</a><b>Warning:</b> to override <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse</a> and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on</a>, don’t use the usual
<code>on('fire')</code> as it will lead to recursion (even the <code>=fire</code> form,
<a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>). Use the old-school prototype overriding (<code class="chemdoc__id">__super__</code> is set up
by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) – see <a href="../Sqimitive/c_Async.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="824 chemdoc__link-entity-cur">Async</a>’s source code for an example:
<pre><code class="chemdoc__block prism language-javascript match-braces">fire: function (event, args) {
  // Do your stuff...
  return MyClass.__super__.fire.apply(this, arguments)
},</code></pre></p><h3 id="-fireAll" class="chemdoc__h1 chemdoc__anchored">The <code class="chemdoc__id">all</code> event<a class="chemdoc__anchor chemdoc__header-anchor" href="#-fireAll">fireAll</a></h3><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> first triggers the special <code class="chemdoc__id">all</code> event. If <code class="chemdoc__id">all</code>’s return
value is anything but <code class="chemdoc__id">undefined</code> – <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> returns it bypassing the
actual handlers of <code class="chemdoc__id">event</code>.</p><p><code class="chemdoc__id">all</code>’s handlers get <code class="chemdoc__id">event</code> put in front of other <code class="chemdoc__id">args</code> (e.g.
<code>['eventName', 'arg1', 2, ...]</code>).</p><p>Note that the <code class="chemdoc__id">all</code> event is only triggered for actual events so if, for
example, <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifrender" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">render()</a> isn’t overridden then it will be called as a regular
member function without triggering <code class="chemdoc__id">all</code> or any other event:
<pre><code class="chemdoc__block prism language-javascript match-braces">var ClassA = Sqimitive.Base.extend({
  events: {
    render: function () { return this },
  },
})

;(new ClassA)
  .on({all: () =&gt; alert('booh!')})
  .render()
    // alert() happens, render is a firer

var ClassB = Sqimitive.Base.extend({
  render: function () { return this },
})

;(new ClassB)
  .on({all: () =&gt; alert('booh!')})
  .render()
    // no alert(), render of extend() is not an event handler but a
    // method

;(new ClassB)
  .on({all: () =&gt; alert('booh!')})
  .on({render: function () { return this }})
  .render()
    // alert() happens because of on('render') which converted
    // the render function from ClassB's declaration to a
    // firer('render') which when called triggers fire('render') which
    // in turn triggers 'all'</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--iffire---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L2318-L2327" target="_blank">lines 2318-2327</a> (10 lines)                                  &bull; <a href="#Sqimitive-Core--iffire---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">fire: function (event, args, inBatch) {
  if (this._events.all && event != 'all') {
    var allArgs = arguments.length < 2 ? [] : Core.toArray(args).concat()
    allArgs.unshift(event)
    var res = this.constructor.fire.call(this, this._events.all, allArgs)
    if (res !== undefined) { return res }
  }

  return this.constructor.fire.call(this, this._events[event], args, inBatch)
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--iffuse"
                data-entity='{"type":"func","id":959,"name":"fuse","start":{"line":3205,"column":4,"offset":123065},"end":{"line":3252,"column":4,"offset":124968},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>fuse</b>
                              (
                  event, func[, cx]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Registers a single permanent event handler.</p><p>Unlike with <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a>, this handler cannot be removed with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">event</th><td>string </td><td rowspan="1" colspan="1"> A single event reference (no comma notation).</td></tr><tr class="chemdoc__first"><th rowspan="2">func</th><td>function</td><td rowspan="2" colspan="1"> Masked method name (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a>).</td></tr><tr><td> string </td></tr><tr class="chemdoc__first"><th rowspan="2">cx</th><td>object</td><td rowspan="2" colspan="1"> The context for <code class="chemdoc__id">func</code></td></tr><tr><td> null/omitted use <code class="chemdoc__id">this</code> </td></tr></table><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>object </td><td rowspan="1" colspan="1"> An internal event registration object (<code class="chemdoc__id">eobj</code>) that should be
discarded.</td></tr></table><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> is a low-level method. You are advised to call <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on</a>({event})
instead.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on({
  something: function () { ... },
  someone: function () { ... },
})

// Identical to the above:
sqim.fuse('something', function () { ... })
sqim.fuse('someone', function () { ... })

// A masked callback - receives (a1, a2, a3), passes (a3, a1, a1, a1)
// to sqim.meth().
sqim.fuse('somewhere', 'meth-3111', sqim)</code></pre></fieldset><h3 id="-post" class="chemdoc__h1 chemdoc__anchored">The <code class="chemdoc__id">post</code> callback<a class="chemdoc__anchor chemdoc__header-anchor" href="#-post">post</a></h3><p>One case when <code class="chemdoc__id">eobj</code> can be accessed is to assign its <code class="chemdoc__id">post</code> key (this is
considered advanced usage). If set to a function, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::fire()</a> calls
<code>post(eobj, res, args)</code> after executing the handler (<code class="chemdoc__id">func</code>), within
the handler’s <code class="chemdoc__id">cx</code>. <code class="chemdoc__id">post</code> must return the new result (replaces <code class="chemdoc__id">res</code> in
any case – even if <code class="chemdoc__id">undefined</code> and regardless of <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>). <code class="chemdoc__id">args</code> is the
event’s arguments, an array-like object (possibly <code class="chemdoc__id">Arguments</code>). If <code class="chemdoc__id">post</code>
sets <code>eobj.stop</code> to <code class="chemdoc__id">true</code> then remaining handlers are skipped. <code class="chemdoc__id">post</code>
is only called along with its associated handler and not called, for
example, if it was attached to a <code>=wrapped</code> hook that was <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off</a>’ed, or to
a hook with mismatching arguments (<code class="chemdoc__id">ev__</code>, see <a href="../Sqimitive/c_Core.html#-argDanger" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">argDanger</a>).</p><fieldset class="chemdoc__example"><legend>Example</legend>See the source code of <a href="../Sqimitive/c_Async.html" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="824 chemdoc__link-entity-cur">Sqimitive\Async</a> for a practical example on
<code class="chemdoc__id">post</code>.<p><pre><code class="chemdoc__block prism language-javascript match-braces">var sqim = new Sqimitive.Base

sqim.on('+event', function () {
  console.log(1)
  return 'test'
})

var eobj = sqim.fuse('event', function () {
  console.log(2)
}, this)

eobj.post = function (eobj, res, args) {
  console.log(3)
  eobj.stop = true
  return res.toUpperCase()    // res is 'test', args is []
}

sqim.on('event', function () {
  console.log(4)
})

sqim.fire('event')      //=&gt; 'TEST'
  // console logs: 1, 2, 3 but not 4</code></pre></p></fieldset><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-fireOverride" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">fireOverride</a></span></p><p><b>Warning:</b> to override <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse</a> and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on</a>, don’t use the usual
<code>on('fire')</code> as it will lead to recursion (even the <code>=fire</code> form,
<a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>). Use the old-school prototype overriding (<code class="chemdoc__id">__super__</code> is set up
by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) – see <a href="../Sqimitive/c_Async.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="824 chemdoc__link-entity-cur">Async</a>’s source code for an example:
<pre><code class="chemdoc__block prism language-javascript match-braces">fire: function (event, args) {
  // Do your stuff...
  return MyClass.__super__.fire.apply(this, arguments)
},</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--iffuse---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L3206-L3253" target="_blank">lines 3206-3253</a> (48 lines)                                  &bull; <a href="#Sqimitive-Core--iffuse---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">fuse: function (event, func, cx) {
  func = Core.expandFunc(func)
  var eobj = Core.parseEvent(event)
  // Don't just do _events[name] or (name in _events) because if name is
  // toString or other Object.prototype member, this will fail (array won't
  // be created).
  var list = _.has(this._events, eobj.event)
    ? this._events[eobj.event] : (this._events[eobj.event] = [])
  this._wrapHandler(eobj.event)
  eobj.func = func
  eobj.cx = cx

  if (eobj.prefix == '+') {
    eobj.res = eobj.ret = true
  } else if (eobj.prefix == '=') {
    eobj.ret = true
    eobj.supList = list.splice(0)

    // function (this[, arguments])
    // sup() itself is removed if present as arguments[0].
    var sup = eobj.sup = function (self, args) {
      if (args && args[0] === sup && _.isArguments(args)) {
        args = ap.slice.call(args, 1)
      }

      return Core.fire.call(self, eobj.supList, args)
    }

    Object.defineProperty(sup, 'name', {value: eobj.event})
  }

  this._insertHandler(list, eobj)

  // A benchmark with optimized event handlers was done on Chrome: it was
  // discovered that in a certain application 60% of fire() calls were on
  // events with 1 handler so I made it bypass fire() if there were no
  // handlers (replaced the wrapped method, firer() with stub) or 1 handler
  // (replaced with direct call to it); this was also maintained on event
  // handler changes (on()/off()).
  //
  // However, performance savings from this optimization were ~5% (on 30k
  // fire() calls) while the added complexity was significant (due to
  // different eobj properties like cx and post which implementation needed
  // to be duplicated in both fire() and the fire()-less wrapper) so it was
  // discarded.

  return eobj
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--iflogEvents"
                data-entity='{"type":"func","id":949,"name":"logEvents","start":{"line":2400,"column":4,"offset":90420},"end":{"line":2426,"column":4,"offset":91250},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>logEvents</b>
                              (
                  [enable]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>A debug method for logging all triggered events to the console.</p><p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--iflogEvents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">logEvents()</a> allows enabling event logging as well as acts as an event
handler for <code class="chemdoc__id">all</code>. The handler can be used on its own, without enabling
logging with <code>logEvents(true)</code>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">true</th><td rowspan="1" colspan="2"> Enable logging; do nothing if browser doesn’t provide
<code>console.log()</code></td></tr><tr class="chemdoc__first"><th rowspan="1">-</th><td>no arguments </td><td rowspan="1" colspan="1"> Same as <code class="chemdoc__id">true</code> (enable logging).</td></tr><tr class="chemdoc__first"><th rowspan="1">false</th><td rowspan="1" colspan="2"> Disable logging, if enabled.</td></tr><tr class="chemdoc__first"><th rowspan="1">string</th><td>event name </td><td rowspan="1" colspan="1"> Log this event; other arguments are the event’s
arguments.</td></tr></table><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>this if <code class="chemdoc__id">enable</code> is bool</td><td rowspan="2" colspan="1"></td></tr><tr><td> undefined if string</td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">sqim.logEvents(true)   // enable logging
sqim.logEvents()       // same as above
sqim.logEvents(false)  // disable</code></pre></fieldset><p>Note: <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iflogEvents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">logEvents</a> logs only events passing through the instance
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.fire()</a>. This means that only real event calls are tracked, not calls
of non-overridden methods (i.e. of regular functions, not <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer</a>). See
<a href="../Sqimitive/c_Core.html#-fireAll" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fireAll</a>.</p><h3 id="Aa68a1c22a8" class="chemdoc__h1">Extending default logger</h3><p>You can override or extend the default logging behaviour by testing the
argument for string:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyLoggee = Sqimitive.Base.extend({
  events: {
    logEvents: function (event) {
      // logEvents() calls itself when an event occurs and the first
      // argument is the event name - a string. In other cases it's
      // not the logger being called.
      if (typeof event == 'string') {
        console.log('el.' + this.el[0].className)
      }
    },
  },
})

// Logs both standard logEvents() info and our class name line.
;(new MyLogger).logEvents().fire('something')</code></pre></p><p>Note: returning non-<code class="chemdoc__id">undefined</code> from the <code class="chemdoc__id">all</code> handler prevents calling
real event handlers (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">.fire()</a>). In the above example it never
happens since <code class="chemdoc__id">logEvents</code> event is hooked with no prefix (<a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>)
meaning the handler’s return value is ignored (even if it does return
anything). However, not in this example:
<pre><code class="chemdoc__block prism language-javascript match-braces">events: {
  '=logEvents': function (sup, event) {
    if (typeof event == 'string') {
      console.log(this.el[0].className)
    } else {
      sup(this, arguments)
    }
    return 'break!'
      // returning non-undefined from an 'all' handler bypasses real
      // event handlers
  },
},</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--iflogEvents---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L2401-L2427" target="_blank">lines 2401-2427</a> (27 lines)                                  &bull; <a href="#Sqimitive-Core--iflogEvents---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">logEvents: function (enable) {
  if (typeof enable == 'string') {
    // function (event, eventArg1, arg2, ...)
    var info = this._cid

    if (this.el) {
      //! +ig
      var el = this.el.nodeType ? this.el : this.el[0] // jQuery
      info += '\t\t' + el.tagName
      var className = el.className.trim()

      if (className != '') {
        info += (' ' + className).replace(/\s+/g, '.')
      }
    }

    console.log(enable + ' (' + (arguments.length - 1) + ') on ' + info)
    return undefined
  } else if (!enable && arguments.length) {
    this.off(this._logEventID)
    this._logEventID = null
  } else if (console && console.log && !this._logEventID) {
    this._logEventID = this.on('all', Core.logEvents)
  }

  return this
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifmixIn"
                data-entity='{"type":"func","id":947,"name":"mixIn","start":{"line":2128,"column":4,"offset":79537},"end":{"line":2236,"column":4,"offset":84243},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>mixIn</b>
                              (
                  newClass, options                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Extension" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Extension</a></p><p>Extends this object instance with a behaviour of another “class” (a
“mix-in”).</p><p>The static <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::mixIn()</a> exists which affects all objects of a class.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">this</th><td><a id="-mixInDesc" class="chemdoc__anchor chemdoc__anchor_token" href="#-mixInDesc">mixInDesc</a></td><td rowspan="1" colspan="1"> The object receiving new “mixed-in” fields (for static
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">::mixIn()</a> <code class="chemdoc__id">this</code> is the “child” class).</td></tr><tr class="chemdoc__first"><th rowspan="1">newClass</th><td>object </td><td rowspan="1" colspan="1"> The mix-in, the object “mixed into” <code class="chemdoc__id">this</code>.</td></tr><tr class="chemdoc__first"><th rowspan="1">options</th><td rowspan="1" colspan="2"> An arbitrary value (usually an object) given to
<code class="chemdoc__id">newClass</code>.<code>finishMixIn()</code>, allowing creation of parametrized mix-ins
(basically, generics).</td></tr></table><p>Possible <code class="chemdoc__id">newClass</code> keys:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">staticProps</th><td>object </td><td rowspan="1" colspan="1"> Static fields made available as
<code>newClass.something</code></td></tr><tr class="chemdoc__first"><th rowspan="1">events</th><td>object </td><td rowspan="1" colspan="1"> Event listeners (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a>).<p>Because this is not a real field, keys in <code>newClass.events</code> do not
override keys in <code>this.events</code>. If both <code class="chemdoc__id">this</code> and <code class="chemdoc__id">newClass</code> have the
<code class="chemdoc__id">foo</code> event key (i.e. if both listen to this event) then two listeners
are set up, not one. Compare with <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a> overriding
(<a href="../Sqimitive/c_Core.html#-elEventsMixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">elEventsMixIn</a>).</p></td></tr><tr class="chemdoc__first"><th rowspan="1">finishMixIn</th><td>function </td><td rowspan="1" colspan="1"> Called before returning.<p><code class="chemdoc__id">this</code> = <code class="chemdoc__id">newClass</code>. arguments = <code>child, options</code> where <code class="chemdoc__id">child</code> is the
prototype of the updated class</p></td></tr><tr class="chemdoc__first"><th rowspan="1">mixIns</th><td>array </td><td rowspan="1" colspan="1"> Each item is either a mixed-in class or an array:
<code>[class, options]</code></td></tr><tr class="chemdoc__first"><th rowspan="1">*</th><td rowspan="1" colspan="2"> Other keys represent instance fields (the <code class="chemdoc__id">protoProps</code> argument of
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>).<p><a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> is respected, but of <code class="chemdoc__id">this</code> (not of <code class="chemdoc__id">newClass</code>).</p><p>A string form of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> is only allowed in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>, not here;
other forms (array, object) are allowed in both places.</p></td></tr></table><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  staticProps: {
    staticMethod: function () { ... },
  },
  events: {
    '-init': function () {
      // (1) Define a property only if it's not defined yet.
      this._someProp = this._someProp || 'buzz'
    },
  },
  finishMixIn: function (targetProto) {
    alert("I'm now mixed into " + targetProto.toString())

    // (2) Or could do it here, more performance-efficient since ran
    // only once for each mixed-in class, not once for each such class
    // instantiation:
    //targetProto._someProp = targetProto._someProp || 'buzz'
    //targetProto.constructor.someStatic = 123
  },
  _opt: {
    correctly: 'merged',
  },
  instanceMethod: function () { ... },
}

var Base1 = Sqimitive.Base.extend({})

var Base2 = Sqimitive.Base.extend({
  _opt: {
   a: 'base',
 },
  // Not overridden by MixIn.
  _someProp: 123,
})

Base1.mixIn(MixIn)   // alerts
  //=&gt; _someProp = 'buzz'
  //=&gt; opt = {correctly: 'merged'}

Base2.mixIn(MixIn)   // alerts again
  //=&gt; _someProp = 123
  //=&gt; opt = {a: 'base', correctly: 'merged'}</code></pre></fieldset><p><b>Warning:</b> <code class="chemdoc__id">this</code> is modified in-place; no new class is created
(<code>mixIn()</code> returns no value). If you want a base class without a given
mix-in and a subclass with that mix-in – first <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> the base class
and then mix into the new sub-class:
<pre><code class="chemdoc__block prism language-javascript match-braces">// CORRECT:
var Base = Sqimitive.Base.extend()
var Sub = Base.extend({mixIns: [SomeMixIn]})

// WRONG: will modify Base, not return a new subclass:
var Base = Sqimitive.Base.extend()
var Sub = Base.mixIn(SomeMixIn)</code></pre></p><fieldset class="chemdoc__example"><legend>Example</legend>There is no way to determine if a class or object has some <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn</a> or
not. For example, listing a mix-in in <a href="../Sqimitive/c_Base.html#Sqimitive-Base--iv_childClass" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_protected" data-if-entity="977 chemdoc__link-entity-cur">_childClass</a> is useless because
<a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifnestEx" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.nestEx()</a> is using <code class="chemdoc__id">instanceof</code> and it works on real classes
only. You can add a field to work around this – static (only for mix-ins
applied to declarations) or instance (for mix-ins applied on run-time):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MyMixIn = {staticProps: {myMixInIsMixedIn: true}}
var instanceofMyMixIn = 'myMixInIsMixedIn' in myObj.constructor

var sqim1 = new Sqimitive.Core
var sqim2 = new Sqimitive.Core
sqim1.mixIn(MyMixIn)
sqim2.constructor.myMixInIsMixedIn    //=&gt; true (!)

var MyMixIn = {myMixInIsMixedIn: true}
var sqim3 = new Sqimitive.Core
var sqim4 = new Sqimitive.Core
sqim3.mixIn(MyMixIn)
sqim4.myMixInIsMixedIn                //=&gt; false</code></pre></fieldset><p>Other notes:</p><ul><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> is doing most of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’s job, which is just creating a
special form of a mix-in.</li><li>Hooking <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifinit" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">init</a> and similar events for a mix-in applied on run-time is
useless since they will be never invoked.</li><li><a id="-mixInDoes" class="chemdoc__anchor chemdoc__anchor_token" href="#-mixInDoes">mixInDoes</a><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> applies “sub mix-ins” (calls <code>mixIn()</code> if <code class="chemdoc__id">newClass</code> contains
the <code class="chemdoc__id">mixIns</code> key; this is recursive), overwrites fields of <code class="chemdoc__id">this</code> with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfdeepClone" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">deepClone</a>-s of those in <code class="chemdoc__id">newClass</code> (or merges according to
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a>), adds <code class="chemdoc__id">staticProps</code>, hardwires events into class
definition (<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>) and calls <code>finishMixIn()</code>.</li><li>Not to be confused with Underscore’s <a href="https://underscorejs.org/#mixin%28%29" class="chemdoc__custom-link chemdoc__proto-un" target="_blank">un:mixin()</a>. However, LoDash’s
<code>mixin()</code> is of a similar purpose.</li></ul><h4 id="-elEventsMixIn" class="chemdoc__h2 chemdoc__anchored">Merging of <code class="chemdoc__id">elEvents</code><a class="chemdoc__anchor chemdoc__header-anchor" href="#-elEventsMixIn">elEventsMixIn</a></h4><p><a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a> lists <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a> in <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sv_mergeProps" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg mmods-fg_static mmods-fg_protected" data-if-entity="909 chemdoc__link-entity-cur">_mergeProps</a> so the former are
merged but unlike with <code>newClass.events</code> keys (which can never have a
conflict and be dropped), keys in <code class="chemdoc__id">elEvents</code> get overridden on name
collisions. This is sometimes desirable (to override the parent’s
handler), sometimes not (then use a unique <code>.ns</code> suffix):
<pre><code class="chemdoc__block prism language-javascript match-braces">var Base = Sqimitive.Base.extend({
  elEvents: {
    click: function () { alert("Click-click-click!') },
  },
})

var ChildA = Base.extend({
  elEvents: {
    click: function () { alert("Overridden!') },
  },
})

var ChildB = Base.extend({
  elEvents: {
    'click.new-in-child-B': function () { alert("Combined!') },
  },
})

// in ChildA, 'click' has 1 listener (Base's dropped)
// in ChildB, 'click' has 2 listeners (Base's and ChildB's)</code></pre></p><h4 id="A04fa545a8e" class="chemdoc__h2">Mix-in inheritance</h4><p><code class="chemdoc__id">mixIns</code> is applied before setting other properties which allows
extending mix-ins themselves (later mix-ins override preceding just like
with normal inheritance on classes). For example:
<pre><code class="chemdoc__block prism language-javascript match-braces">var ParentMixIn = {
  someEvent: function () { /* parent */ },
]

var ChildMixIn = {
  mixIns: [ParentMixIn],
  events: {
    someEvent: function () { /* child */ },
  },
}

var myClass = Sqimitive.Base.extend({
  mixIns: [ChildMixIn],
})

// myClass had ParentMixIn added, then ChildMixIn, and now has two
// listeners on someEvent</code></pre></p><p><code class="chemdoc__id">ParentMixIn</code> could also have the <code class="chemdoc__id">mixIns</code> property to specify its own
parent.</p><p>In the above example, the mix-in specified its parent, which is usually
intuitive. Still, it could be specified in the final class’ <code class="chemdoc__id">mixIns</code>
alone:
<pre><code class="chemdoc__block prism language-javascript match-braces">var ParentMixIn = {
  someEvent: function () { /* parent */ },
]

var ChildMixIn = {
  // mixIns property is missing.
  events: {
    someEvent: function () { /* child */ },
  },
}

var myClass = Sqimitive.Base.extend({
  // Added ParentMixIn in front of ChildMixIn.
  mixIns: [ParentMixIn, ChildMixIn],
})

// or (equivalent, no mixIns property, mixIn() calls instead):
var myClass = Sqimitive.Base.extend()
myClass.mixIn(ParentMixIn)
myClass.mixIn(ChildMixIn)

// or (equivalent for a particular object instance):
var myClass = Sqimitive.Base.extend()
var obj = new myClass
obj.mixIn(ParentMixIn)
obj.mixIn(ChildMixIn)

// in any case, MyClass (or obj) has 'someEvent' firer() with
// 2 listeners: of ParentMixIn and of ChildMixIn</code></pre></p><p><b>Warning:</b> calling <code>mixIn()</code> in <code>finishMixIn()</code> would have a
different effect. If <code class="chemdoc__id">ChildMixIn</code> were defined as follows then <code class="chemdoc__id">MyClass</code>
or <code class="chemdoc__id">obj</code> would have <code class="chemdoc__id">someEvent</code> not as a <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sffirer" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">firer()</a> but as the
<code class="chemdoc__id">ParentMixIn</code>’s function (because it was mixed-in after <code class="chemdoc__id">ChildMixIn</code> and
overrode its <code class="chemdoc__id">events</code> handler):
<pre><code class="chemdoc__block prism language-javascript match-braces">var ChildMixIn = {
  finishMixIn: function (newClass) {
    newClass.mixIn(ParentMixIn)
  },
  events: {
    someEvent: function () { /* child */ },
  },
}</code></pre></p><p>This will override the handler introduced in the declaration of <code class="chemdoc__id">Class</code>
for the same reason – <code class="chemdoc__id">MixIn</code> is added to <code class="chemdoc__id">Class</code> after <code class="chemdoc__id">Class</code>’ own
fields:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  some: function () { ... },
}

var Class = Sqimitive.Base.extend({
  events: {
    some: function () { ... },
  }
})

Class.mixIn(MixIn)</code></pre></p><p>This is the correct way (using <code class="chemdoc__id">mixIns</code> property when <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ing
<code class="chemdoc__id">Class</code>):
<pre><code class="chemdoc__block prism language-javascript match-braces">var MixIn = {
  some: function () { ... },
}

var Class = Sqimitive.Base.extend({
  mixIns: [MixIn],
  events: {
    some: function () { ... },
  }
})</code></pre></p><h4 id="A6cc2566c0e" class="chemdoc__h2">Edge cases</h4><p>See the source code for details.</p><ul><li>Given a base class <code class="chemdoc__id">B</code> and subclass <code class="chemdoc__id">C</code>, adding mix-ins to <code class="chemdoc__id">B</code> after <code class="chemdoc__id">C</code>
has been <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ed from <code class="chemdoc__id">B</code> when <code class="chemdoc__id">C</code> declares <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> will lead to
<code class="chemdoc__id">C</code> not having <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> of the newly mixed-in objects of <code class="chemdoc__id">B</code>.</li><li>Declaration-time <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> of <code class="chemdoc__id">B</code> are <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>’d and their <code class="chemdoc__id">eobj</code>-s are
shared among all subclasses of <code class="chemdoc__id">B</code> and should not be changed (list of
events may change, just not properties of inherited handlers): <pre><code class="chemdoc__block prism language-javascript match-braces">var ClassB = Sqimitive.Core.extend({
  events: {change: 'render'},
})

ClassB.prototype._events.change[0].post    //=&gt; undefined

var ClassC = ClassB.extend()
ClassC.prototype._events.change[0].post = function () { ... }
ClassB.prototype._events.change[0].post    //=&gt; Function

// In this version instances' _events are deepClone()'d so changing it
// (not the prototype) doesn't affect other classes/objects:
var obj = new ClassC
obj._events.change[0].post = 'foo'
ClassB.prototype._events.change[0].post    //=&gt; still Function</code></pre></li></ul></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifmixIn---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L2129-L2237" target="_blank">lines 2129-2237</a> (109 lines)                                  &bull; <a href="#Sqimitive-Core--ifmixIn---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">mixIn: function (newClass, options) {
  //! +ig=4
  // Don't expose internal inheritance fields on the final classes.
  var merged = {mixIns: undefined, finishMixIn: undefined, staticProps: undefined, events: undefined}

  _.forEach(newClass.mixIns || [], function (mixIn) {
    // mixIns items are either objects or arrays. concat() ensures mixIn()
    // is called either with (class, options) or (class) alone.
    this.mixIn.apply(this, [].concat(mixIn))
  }, this)

  _.forEach(this.constructor._mergeProps, function (prop) {
    if ((prop in this) && (prop in newClass)) {
      if (_.isArray(newClass[prop])) {
        merged[prop] = this[prop].concat(newClass[prop])
      } else {
        merged[prop] = _.assign({}, this[prop], newClass[prop])
      }
    }
  }, this)

  _.assign(this, newClass, merged)
  _.assign(this.constructor, newClass.staticProps || {})

  if (newClass.events) {
    // Core has no __super__ but it doesn't use mix-ins either so no check
    // for null. This condition will evaluate to true except when a class
    // has mix-ins (via mixIns property or mixIn() method) - we could clone
    // it in the second case too but this would be a waste.
    //
    // Warning: this operates under assumption that the base class is
    // finalized (all mix-ins applied) before any of its sub-classes is
    // created.
    //
    //   var Base = Sqimitive.extend()
    //   Base.mixIn(...)    // fine
    //   var Child = Base.extend()
    //   Base.mixIn(...)    // wrong
    //
    // Adding mix-ins after Child was declared may have unexpected side
    // effects - if the mix-in adds an event and if Child had its own events
    // block, then Child won't receive new mix-in's events. This is an
    // implementation detail - "officially", adding mix-ins after declaring
    // a subclass leads to undefined behaviour and should never be used (but
    // it's fine to mix-in into live instances at any time).
    if (this._events === this.constructor.__super__._events) {
      //! +ig
      // Could use deepClone but it's more intense - we don't clone eobj-s
      // which theoretically could be changed before instantiation but we
      // ignore this possibility.
      this._events = _.assign({}, this._events)

      for (var ev in this._events) {
        this._events[ev] = this._events[ev].concat()
      }
    }

    this.on(newClass.events)
  }

  if (this === this.constructor.prototype) {   // static mixIn()
    //! +ig
    // Constructor fills this one when the class is created for the first
    // time. It should be regenerated for every class and not be copied to
    // subclasses to avoid the following:
    //
    //   var Base = Sqimitive.Base.extend()
    //   new Base
    //   Base._copyProps      //=> [...]
    //   var Sub = Base.extend({newProp: []})
    //   new Sub
    //   Sub._copyProps       //=> same as Base; newProp is missing
    //   ;(new Sub).newProp.push(123)
    //   ;(new Sub).newProp   //=> [123] instead of []
    //
    // Additionally, it should be cleared when a mix-in is added since it
    // may have provided new properties (in finishMixIn if not via
    // newClass). This is not done for instance mixIn() since the latter is
    // called after constructor.
    this.constructor._copyProps = initCopyProps
  } else {    // instance mixIn()
    // When mixing-in to a declaration, inherited and mixed-in properties'
    // values are cloned by the constructor. Obviously, the latter isn't
    // called when mixing-in to an instance so need to clone now.
    //
    //   // Instance mix-in:
    //   var MixIn = {newProp: []}
    //   var sqim = new (Sqimitive.Base.extend())
    //   sqim.mixIn(MixIn)
    //   sqim.newProp.push(123)
    //   MixIn.newProp    //=> must be [], not [123]
    //
    //   // Compare with declaration mix-in (cloning done by constructor):
    //   var sqim = new (Sqimitive.Base.extend({
    //     mixIns: [MixIn]
    //   }))
    //   // Or, the same:
    //   var Decl = Sqimitive.Base.extend()
    //   Decl.mixIn(MixIn)
    //   var sqim = new Decl
    for (var prop in newClass) {
      if (!(prop in merged) && this._mustClone(prop)) {
        this[prop] = this.constructor.deepClone(this[prop])
      }
    }
  }

  newClass.finishMixIn && newClass.finishMixIn(this, options)
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifoff"
                data-entity='{"type":"func","id":962,"name":"off","start":{"line":3386,"column":4,"offset":130082},"end":{"line":3411,"column":4,"offset":130863},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>off</b>
                              (
                  key                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Removes non-<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a>’d event listener(s).</p><table class="chemdoc__entity-table chemdoc__entity-type">
<caption>Result Types</caption>
<thead>
  <tr>
    
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><td>this</td><td rowspan="1" colspan="1"></td></tr></table><p><code class="chemdoc__id">key</code> can be one of:</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">string</th><td>event name </td><td rowspan="1" colspan="1"> Like “render”; removes all listeners to that event.</td></tr><tr class="chemdoc__first"><th rowspan="1">number</th><td>listener ID </td><td rowspan="1" colspan="1"> As returned by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>; removes that particular
listener from that particular event.</td></tr><tr class="chemdoc__first"><th rowspan="1">object</th><td>context </td><td rowspan="1" colspan="1"> The <code class="chemdoc__id">cx</code> to which listeners were registered; removes
all listeners to all events with that context.</td></tr><tr class="chemdoc__first"><th rowspan="1">array</th><td rowspan="1" colspan="2"> Containing any of the above values including more sub-arrays;
identical to multiple <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a> calls.</td></tr></table><p>Does nothing if no matching events, contexts or listeners were found
(thus safe to call multiple times).</p><p>When unregistering a wrapping handler (<code>=event</code>, see <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>) its
underlying handlers are reinserted into the list of handlers (“undoing”
method override) maintaining priority (<a href="../Sqimitive/c_Core.html#-evtref" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtref</a>) but not necessary the
original order (calls to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>).</p><p>See <a href="../p_ov.html#-evt" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">evt</a> for a nice example on this subject and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a> for attaching
one-shot listeners.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">// key = 'evtname' | 12345 | {cx} | [key, key, ...]

var id = sqim.on('=superseded', function () { ... }, this)
sqim.off(id)
sqim.off('superseded')
sqim.off(this)

// Just like the above 3 calls:
sqim.off([id, 'superseded', this])</code></pre></fieldset><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Base.html#-unnestedoff" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="977 chemdoc__link-entity-cur">unnestedoff</a></span></p><p><a href="../Sqimitive/c_Base.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base</a>’s implementation of <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ifunnested" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">unnested()</a> calls <code class="chemdoc__id">sqim</code>.<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off</a>(<code class="chemdoc__id">this</code>) to
unregister all event handlers that might have been previously attached to
the removed child by this instance (provided they were not hardwired with
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> and used <code>cx === this</code>).</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifoff---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L3387-L3412" target="_blank">lines 3387-3412</a> (26 lines)                                  &bull; <a href="#Sqimitive-Core--ifoff---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">off: function (key) {
  if (_.isArray(key)) {
    // List of identifiers of some kind.
    _.forEach(key, this.off, this)
  } else if (key instanceof Object) {
    // By context.
    var list = this._eventsByCx.get(key)
    if (list) {
      this._eventsByCx.delete(key)
      _.forEach(list, this._unregHandler.bind(this, {cx: true}))
    }
  } else if (typeof key == 'string') {
    // By event name.
    var list = this._events[key]
    if (list) {
      delete this._events[key]
      _.forEach(list, this._unregHandler.bind(this, {sup: true}))
    }
  } else {
    // By handler ID.
    var eobj = this._eventsByID[key]
    eobj && this._unregHandler({}, eobj)
  }

  return this
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifon"
                data-entity='{"type":"func","id":952,"name":"on","start":{"line":2700,"column":4,"offset":103841},"end":{"line":2714,"column":4,"offset":104315},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>on</b>
                              (
                  event(s) [, func] [, cx]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Registers a single event handler and returns its ID or permanently
hardwires multiple events and/or handlers.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="2">event</th><td>string to register one handler and return ID that can be used to
unregister it with <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a></td><td rowspan="2" colspan="1"> Object keys are event references (<a href="../Sqimitive/c_Core.html#-evtref" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtref</a>), values
are handlers.<p>If an object, keys can contain multiple event references separated with
<code>, </code> – this is identical to multiple <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> calls but shorter. Note: a
space after the comma is mandatory (unlike with <a href="../Sqimitive/c_jQuery.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="882 chemdoc__link-entity-cur">jQuery</a> selectors).</p></td></tr><tr><td> object to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> one or multiple handlers
and return <code class="chemdoc__id">this</code> </td></tr><tr class="chemdoc__first"><th rowspan="2">cx</th><td><a id="-onOnce" class="chemdoc__anchor chemdoc__anchor_token" href="#-onOnce">onOnce</a>object</td><td rowspan="2" colspan="1"> Context in which the handler(s)
are called. <code class="chemdoc__id">this</code> is the object on which <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> was called so
<code>on('e', 'h')</code> will call <code>h()</code> on the object where the event occurs
(and in that object’s context).</td></tr><tr><td> null/omitted use <code class="chemdoc__id">this</code> </td></tr></table><p>The handler (<code class="chemdoc__id">func</code> or <code class="chemdoc__id">event</code> object value) can be either a (masked)
method reference (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a>) or function. Strings are resolved
when the event is fired so their handlers are always up-to-date and don’t
even have to exist by the time <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> is called.</p><p>Errors if an event reference can’t be parsed.</p><fieldset class="chemdoc__example"><legend>Example</legend>Object form – <code>on( {events} [, cx] )</code>:
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on({'-get_, nest': 'render'})
  //=&gt; this (handlers cannot be unbound)
  // call render() on sqim when get() and nest() happen

// WRONG: no space, seen as a single event name "get_,nest":
sqim.on({'-get_,nest': 'render'})</code></pre><p>String form – <code>on( 'event', func [, cx] )</code>:
<pre><code class="chemdoc__block prism language-javascript match-braces">var id = sqim.on('change', this.render, this)
  //=&gt; 12345
  // handler called in a different context (this, not sqim)
sqim.off(id)

// WRONG: comma notation only accepted by on({events}):
sqim.on('change, nest', this.render, this)</code></pre></p></fieldset><fieldset class="chemdoc__example"><legend>Example</legend>Object-<code class="chemdoc__id">event</code> form is used behind the scenes when <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>’ing or
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> a class and supplying the <code class="chemdoc__id">events</code> key in <code class="chemdoc__id">protoProps</code>,
therefore <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ivevents" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">events</a> format is exactly the <code class="chemdoc__id">events</code> argument of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>.<p>Warning: when giving <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a> or <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifmixIn" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">mixIn()</a> a method (as a property,
not as an <code class="chemdoc__id">events</code> member) which name is already used for an event it
will conceal existing handlers and generally misbehave – see <a href="../p_ov.html#-evtconc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="797 chemdoc__link-entity-cur">evtconc</a>.</p><p>Warning: this semantics does not apply to <a href="../Sqimitive/c_Base.html#Sqimitive-Base--ivelEvents" class="chemdoc__custom-link chemdoc__link-entity member-fg member-fg_var mmods-fg " data-if-entity="977 chemdoc__link-entity-cur">Base.elEvents</a>!</p><p><pre><code class="chemdoc__block prism language-javascript match-braces">var MyClass = Sqimitive.Base.extend({
  events: {
    // Calls render() after 'name' option change and before
    // 'birthday' change.
    'change_name, -change_birthday': 'render',

    // Calls fadeOut() when 'close' gets fired.
    close: function () {
      this.el.fadeOut(_.bind(this.remove, this))
    },
  },
})

obj.set('name', 'miku')   // render() called
obj.close()               // fadeOut() called</code></pre></p></fieldset><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-fireOverride" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">fireOverride</a></span></p><p><b>Warning:</b> to override <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire</a>, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse</a> and <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on</a>, don’t use the usual
<code>on('fire')</code> as it will lead to recursion (even the <code>=fire</code> form,
<a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>). Use the old-school prototype overriding (<code class="chemdoc__id">__super__</code> is set up
by <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfextend" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">extend()</a>) – see <a href="../Sqimitive/c_Async.html" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_class mmods-fg " data-if-entity="824 chemdoc__link-entity-cur">Async</a>’s source code for an example:
<pre><code class="chemdoc__block prism language-javascript match-braces">fire: function (event, args) {
  // Do your stuff...
  return MyClass.__super__.fire.apply(this, arguments)
},</code></pre></p><p>Other notes:</p><ul><li>To register one-time handlers use <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a> instead of <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> + <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a>.</li><li><a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> with an object <code class="chemdoc__id">event</code> is like <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> but with added comma
notation in <code class="chemdoc__id">event</code> keys.</li><li>Treat event ID as an opaque scalar value. Its type and format may change
but not its meaning in regards to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a> and other methods.</li><li>Fusing is a bit more efficient since no tracking information about
handlers is stored. If your handler is meant to stay with the object for
its lifetime – use <code>on({event: func}, cx)</code> or <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> (this also
clearly conveys your intention of keeping it forever).</li><li>Specifically, <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> affects one internal value (the list of hooks),
single-handler <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> – two (+ list of event IDs) or three (+ list of
events by context if <code class="chemdoc__id">cx</code> is not <code class="chemdoc__id">null</code>), <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a> – also two or three.</li></ul><h3 id="-evtref" class="chemdoc__h1 chemdoc__anchored">Event reference format<a class="chemdoc__anchor chemdoc__header-anchor" href="#-evtref">evtref</a></h3><p>An event reference is a string with four parts:
<code>[priority^][prefix]event[args]</code>.</p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">priority</th><td rowspan="1" colspan="2"> Optional; an integer ending on <code>^</code> determining the order of
calling hooks of the same event (defaults to <code class="chemdoc__id">0</code>, may be negative),
lower called first. If begins with <code>^</code> or is <code>^</code> alone, marks the
handler out-of-batch: when due for calling in response to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifbatch" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">batch()</a>’ed
events, it is called immediately after <code class="chemdoc__id">func</code> returns – without draining
accumulated batches (see <a href="../Sqimitive/c_Core.html#-naor" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">naor</a>).</td></tr><tr class="chemdoc__first"><th rowspan="1">prefix</th><td rowspan="1" colspan="2"> Optional; changes the way event handler is bound and called as
explained in <a href="../Sqimitive/c_Core.html#-evtpf" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtpf</a>.</td></tr><tr class="chemdoc__first"><th rowspan="1">event</th><td rowspan="1" colspan="2"> Event name – exactly what is given to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffire" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fire()</a> when triggering
an event.</td></tr><tr class="chemdoc__first"><th rowspan="1">args</th><td rowspan="1" colspan="2"> Zero or more underscores (<code class="chemdoc__id">_</code>); if present, the handler gets
called only if <code class="chemdoc__id">event</code> was given that exact number of arguments (it’s
not possible to match zero arguments).<p>For example, <code class="chemdoc__id">eve__</code> registers a handler that is called for
<code>fire('eve', [1, 2])</code> but is not called for <code>fire('eve', [1])</code> or
<code>fire('eve', [1, 2, 3])</code>.</p><p>In case of <code>=event</code> (overriding handler), if argument count differs then
all handlers superseded by this one get called while the superseding
handler itself is not called (as if the superseding handler was just
<code>return sup(this, arguments)</code>).</p><p>Generally, usage of <code class="chemdoc__id">args</code> is frowned upon because of its unintuitive
nature – see <a href="../Sqimitive/c_Core.html#-argDanger" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">argDanger</a>.</p></td></tr></table><h4 id="-evtpf" class="chemdoc__h2 chemdoc__anchored">Event prefixes<a class="chemdoc__anchor chemdoc__header-anchor" href="#-evtpf">evtpf</a></h4><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">none</th><td>evArgs… </td><td rowspan="1" colspan="1"> Add new handler <b>after</b> existing handlers. It
neither receives the current event result nor it can change it (the
handler’s return value is ignored). This form is used most often and
it’s perfect for “attaching” extra behaviour to the end of the original
code, retaining the original result.</td></tr><tr class="chemdoc__first"><th rowspan="1">-</th><td>evArgs… </td><td rowspan="1" colspan="1"> Add new handler <b>before</b> existing handlers of the same
priority, otherwise identical to “no prefix”.</td></tr><tr class="chemdoc__first"><th rowspan="1">+</th><td><b>res</b>, evArgs… </td><td rowspan="1" colspan="1"> Add new handler after existing handlers. It
receives the current <b>event return value</b> (<code class="chemdoc__id">res</code>) and can change it if
the handler returns anything but <code class="chemdoc__id">undefined</code>.</td></tr><tr class="chemdoc__first"><th rowspan="1">=</th><td><b>sup</b>, evArgs… </td><td rowspan="1" colspan="1"> <b>Wrap around</b> existing handlers – they are
removed, regardless of their priority (own priority of <code>=</code> sorts it in
relation to non-<code>=</code> handlers added later). It receives a callable <code class="chemdoc__id">sup</code>
of form <code>function (this, args)</code> which it may call or not (alike to
calling <code class="chemdoc__id">super</code> in Java). <code>sup.name</code> equals plain event name, handy
with comma notation. If it returns <code class="chemdoc__id">undefined</code> the current event return
value is unchanged.<p>First argument of <code class="chemdoc__id">sup</code> is the context (normally the object that
initiated the event, i.e. the handler’s own <code class="chemdoc__id">this</code>). Second argument is
an array of arguments the overridden handlers receive. The handler may
change these arguments to trick the underlying (wrapped) handlers into
believing the event received a different set of data or it can pass the
<code class="chemdoc__id">arguments</code> object that the handler itself has received – in this case
<code>args[0]</code> (which is <code class="chemdoc__id">sup</code>) is removed and the rest is given to the
underlying handlers.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">// sup.name == 'someEvent'.
'=someEvent': function (sup, a1, a2) {
  // Passes original context and arguments unchanged.
  return sup(this, arguments)
  // Identical to above but longer - sup() removes itself from the
  // first argument.
  return sup(this, _.rest(arguments))
  // Not identical to above - if event was given &gt;2 arguments they
  // will be omitted here but passed as is by above.
  return sup(this, [a1, a2])
  // Changes first argument and omits 3rd and other arguments (if
  // given).
  return sup(this, [1, a2])
  // Gives no arguments at all to the underlying handlers.
  return sup(this)
  // Passes sup verbatim because removal doesn't happen for array.
  return sup(this, [sup])
},</code></pre></fieldset><p>Note: old handlers are not technically “removed” – they are kept around
and restored if the <code>=wrapping</code> handler is removed so treat this prefix
like any other. It can be even used with <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a>:
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.once('=update', function () { alert('Holding tight!') })
sqim.update()   // alerts

// Old 'update' handlers are now restored.

sqim.update()   // no more alerts</code></pre></p><p>This works even if more handlers were added to the event after wrapping:
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on('-update', ...)
  // 1 handler
var id = sqim.on('=update', ...)
  // 1 handler - '-update' superseded
sqim.on('update', ...)
  // 2 handler2: ['=update', 'update']
sqim.off(id)
  // 2 handler2: ['-update', 'update'] - '=update' removed</code></pre></p><p>Warning: don’t pass a wrong <code class="chemdoc__id">this</code> by accident, as when <code>=overriding</code>
from an outside object using <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a>/<a href="../Sqimitive/c_Core.html#Sqimitive-Core--iffuse" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">fuse()</a> with a <code class="chemdoc__id">cx</code>:
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on('=foo', function (sup) {
  // Likely an error: this in '=foo' is not sqim.
  sup(this, arguments)
}, this)   // &lt;- note explicit context</code></pre></p><p>Wrapped handlers are sorted by their priorities, as usual. However,
their out-of-batch marks (leading <code>^</code>) have no use because the main
handler determines when/if they are called.
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.on('foo', ...)       // (1)
sqim.on('^=foo', ...)     // (2)
  // (1) is never called by itself; if (2) calls its sup() immediately
  // then (1) will be processed out-of-batch

sqim.on('^foo', ...)      // (3)
sqim.on('=foo', ...)      // (4)
  // the opposite: (4) forces (3) to be called in-batch, if called at all</code></pre></p></td></tr></table><p>It’s impossible for a handler to set the event’s result to <code class="chemdoc__id">undefined</code> as
it is considered a “keep current result” marker. This can be worked
around using <code class="chemdoc__id">eobj</code>.<a href="../Sqimitive/c_Core.html#-post" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">post</a> whose result is taken literally:
<pre><code class="chemdoc__block prism language-javascript match-braces">sqim.fuse('event', new Function)
  .post = function (eobj, res, args) { return undefined }</code></pre></p><h3 id="-argDanger" class="chemdoc__h1 chemdoc__anchored">The danger of ev__<a class="chemdoc__anchor chemdoc__header-anchor" href="#-argDanger">argDanger</a></h3><p>In JavaScript, functions accept extra arguments with ease; often you
would provide an iterator and only care for some of its arguments.
However, if using the <code class="chemdoc__id">ev__</code> form (underscores are the <code class="chemdoc__id">args</code> part of
<a href="../Sqimitive/c_Core.html#-evtref" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_anchor mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">evtref</a>) then the event must have been given that <b>exact</b> number of
arguments even if none of its handlers uses the rest:
<pre><code class="chemdoc__block prism language-javascript match-braces">var MySqimitive = Sqimitive.Base.extend({
  accessor: function (prop, value) {
    if (arguments.length == 1) {
      return this._foo[prop]
    } else {
      this._foo[prop] = value
      return value
    }
  },
})

var sqim = new MySqimitive
// This handler should always be called when a property is being
// set... right?
sqim.on('accessor__', function (prop, value) {
  alert('Now ' + prop + ' is ' + value)
})

// Alerts "Now name is val". So far so good.
sqim.accessor('name', 'val')

var propsToSet = {prop: 'foo', bar: 123}
// map() calls sqim.accessor() for every key in propsToSet and
// properties are indeed properly set - but no alerts appear! This is
// because map() passes 3 arguments to the iterator: value, key and
// the list itself (object in our case). Therefore even if accessor()
// uses just 2 of these arguments (like it does above) the actual
// event fired is "accessor___" (3 underscores), not "accessor__" (the
// one we've hooked).
_.map(_.invert(propsToSet), sqim.accessor, sqim)</code></pre></p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifon---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L2701-L2715" target="_blank">lines 2701-2715</a> (15 lines)                                  &bull; <a href="#Sqimitive-Core--ifon---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">on: function (event, func, cx) {
  if (event instanceof Object) {
    for (var name in event) {
      var names = name.split(', ')
      for (var i = 0, l = names.length; i < l; i++) {
        this.fuse(names[i], event[name], func)
      }
    }
    return this
  } else if (arguments.length >= 2) {
    return this._regHandler( this.fuse(event, func, cx) )
  } else {
    throw new TypeError('on: Bad arguments')
  }
},</code></pre>
                          </dd>
                      <dt id="Sqimitive-Core--ifonce"
                data-entity='{"type":"func","id":953,"name":"once","start":{"line":2753,"column":4,"offset":106074},"end":{"line":2782,"column":4,"offset":106815},"forced":null,"modifiers":[],"file":"main.js"}'
                class="cp-member__header">
              <b>once</b>
                              (
                  event, [retainer, ] func[, cx]                )
                          </dt>
            <dd class="cp-member__info">
                                            <div class="fmt"><p class="chemdoc__anchor-addendum">Part of: <a href="../p__7ibvkbid.html#-tag_Events" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="794 chemdoc__link-entity-cur">tag_Events</a></p><p>Regsiters a single one-shot event handler that removes itself as soon as
<code class="chemdoc__id">func</code> returns non-<code class="chemdoc__id">retainer</code> (or after the first call).</p><p>In all other aspects <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifonce" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">once()</a> is identical to <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> with the string
argument, i.e. <code>on(event, func, cx)</code>. Returns new event ID suitable for
<a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifoff" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">off()</a> so you can unregister it before it’s called (or during or after -
nothing will happen). Doesn’t allow registering multiple events/handlers
in one call.</p><fieldset class="chemdoc__example"><legend>Example</legend><pre><code class="chemdoc__block prism language-javascript match-braces">sqim.once('+normalize_foo', () =&gt; 123, this)
sqim.off(this)   // removes the above hook, along with others of this
sqim.once('=render', () =&gt; { /* skips one call, keeps event's result */ })

sqim.once('change_visible', null, now =&gt; now ? this.update() : null)
  // Returns null until sqim._opt.visible becomes truthy, retaining
  // the handler. Then returns result of update() and unhooks.
  // In any case, the hook's result is ignored because of no event prefix.</code></pre></fieldset><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="1">event</th><td>string</td><td rowspan="1" colspan="1"></td></tr><tr class="chemdoc__first"><th rowspan="2">retainer</th><td>mixed except string, function, NaN (not comparable)</td><td rowspan="2" colspan="1"> Compared using <code>===</code>, acts as event result if returned; typical
choices are <code class="chemdoc__id">undefined</code>, <code class="chemdoc__id">null</code>, <code class="chemdoc__id">true</code> and <code class="chemdoc__id">false</code></td></tr><tr><td> omitted
</td></tr><tr class="chemdoc__first"><th rowspan="2">func</th><td>string</td><td rowspan="2" colspan="1"></td></tr><tr><td> function</td></tr></table><p class="chemdoc__anchor-inclusion"><span>from <a href="../Sqimitive/c_Core.html#-onOnce" class="chemdoc__link-entity chemdoc__anchor-link" data-if-entity="909 chemdoc__link-entity-cur">onOnce</a></span></p><table class="chemdoc__entity-table chemdoc__entity-args">
<caption>Arguments</caption>
<thead>
  <tr>
    <th>Name</th>
    <th>Types</th>
    <th>Notes</th>
  </tr>
</thead>
<tbody><tr class="chemdoc__first"><th rowspan="2">cx</th><td>object</td><td rowspan="2" colspan="1"> Context in which the handler(s)
are called. <code class="chemdoc__id">this</code> is the object on which <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> was called so
<code>on('e', 'h')</code> will call <code>h()</code> on the object where the event occurs
(and in that object’s context).</td></tr><tr><td> null/omitted use <code class="chemdoc__id">this</code> </td></tr></table><p>The handler (<code class="chemdoc__id">func</code> or <code class="chemdoc__id">event</code> object value) can be either a (masked)
method reference (see <a href="../Sqimitive/c_Core.html#Sqimitive-Core--sfexpandFunc" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg mmods-fg_static" data-if-entity="909 chemdoc__link-entity-cur">expandFunc()</a>) or function. Strings are resolved
when the event is fired so their handlers are always up-to-date and don’t
even have to exist by the time <a href="../Sqimitive/c_Core.html#Sqimitive-Core--ifon" class="chemdoc__anchor-link chemdoc__link-entity member-fg member-fg_func mmods-fg " data-if-entity="909 chemdoc__link-entity-cur">on()</a> is called.</p><p>Errors if an event reference can’t be parsed.</p><p>If the handler somehow gets called again after it should not have been,
or if <code class="chemdoc__id">event</code> occurs again while running (reenters), or if <code class="chemdoc__id">func</code> throws
- the handler returns <code class="chemdoc__id">undefined</code> without calling <code class="chemdoc__id">func</code> and unbinds.
This is in line with <a href="https://squizzle.me/js/nodash/map.html#NoDash--ifonce" class="chemdoc__custom-link chemdoc__link-extchem chemdoc__link-extchem-no" target="_blank">no:once</a>().</p></div>
                                          <p class="cp-member__file def-snip__hdr"
                 id="Sqimitive-Core--ifonce---code">
                Defined in:
                main.js, <a href="https://github.com/ProgerXP/Sqimitive/blob/e3ca0da61659b8f47cfead401e705fef592f15b8/main.js#L2754-L2783" target="_blank">lines 2754-2783</a> (30 lines)                                  &bull; <a href="#Sqimitive-Core--ifonce---code" class="def-snip__toggler">Show code</a>
                              </p>
                                              <pre class="def-snip__code"><code class="code_block prism language-javascript match-braces">once: function (event, retainer, func, cx) {
  var args = arguments
  var self = this
  var running = 0

  switch (typeof retainer) {
    case 'string':      // expandFunc()
    case 'function':
      ap.splice.call(args, 1, 0, retainer = {})
  }

  function once_() {
    var incomplete = {}
    var res = incomplete

    try {
      if (!running++) {
        res = Core.expandFunc(args[2]).apply(this, arguments)
      }
    } finally {
      res === retainer ? running-- : self.off(id)
    }

    return res === incomplete ? undefined : res
  }

  Core.trace && (once_.trace = arguments)
  var id = this.on(event, once_, args[3])
  return id
},</code></pre>
                          </dd>
                  </dl>
      </div>


<footer class="footer">
      <span class="footer__group">
      ⁂
              <a href="https://squizzle.me/js/sqimitive/">
            Sqimitive</a>    </span>
    <span class="footer__group">
    <a href="#">Scroll to top</a>
  </span>
  <span class="footer__group">
    Generated by
    <a href="http://squizzle.me/chem" target="_blank">Chem &amp; Chemdoc</a>
  </span>
  <span class="footer__group">
    2022-12-25  </span>
  <span class="footer__group">
    Typo?
    <a href="https://github.com/ProgerXP/Orphus" target="_blank">Ctrl+Enter</a>
  </span>
</footer>
    <script src="../scripts.js"></script>

          <link rel="stylesheet" href="../prism.css">
      <script src="../prism.js"></script>
      <script>
        Prism.plugins.customClass.prefix('prism__')
      </script>
    
        <script src="../entities.js"></script>
  </body>
</html>
