{"entities":{"801":{"type":"anchor","id":801,"name":"setOnDecl","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"802":{"type":"anchor","id":802,"name":"settable","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"803":{"type":"anchor","id":803,"name":"setOnDeclViaPush","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"804":{"type":"anchor","id":804,"name":"readOnly","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"805":{"type":"anchor","id":805,"name":"inMergeProps","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"806":{"type":"anchor","id":806,"name":"inMergePropsA","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"807":{"type":"anchor","id":807,"name":"es6thiswarn","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"808":{"type":"anchor","id":808,"name":"inBB","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"809":{"type":"anchor","id":809,"name":"unordered","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"810":{"type":"anchor","id":810,"name":"tag_Events","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"811":{"type":"anchor","id":811,"name":"tag_Extension","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"812":{"type":"anchor","id":812,"name":"tag_Lifecycle","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"813":{"type":"anchor","id":813,"name":"tag_Nesting","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"814":{"type":"anchor","id":814,"name":"tag_Options","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"815":{"type":"anchor","id":815,"name":"tag_Utilities","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"816":{"type":"anchor","id":816,"name":"deps","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"817":{"type":"anchor","id":817,"name":"opt","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"818":{"type":"anchor","id":818,"name":"chld","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"819":{"type":"anchor","id":819,"name":"evt","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"820":{"type":"anchor","id":820,"name":"evtconc","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"821":{"type":"anchor","id":821,"name":"vw","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"HELP.chem"},"794":{"type":"page","id":794,"name":"_7ibvkbid","comment":"`! +pg=_7ibvkbid\n\n`#setOnDecl\n` `*May only be set upon declaration via `@Core::extend()`@ or `#mixIn.`*\n\n`#settable\n` `*May be set upon declaration via `@Core::extend()`@ or `#mixIn and/or read/written directly on run-time.`*\n\n`#setOnDeclViaPush\n` `*May only be set after `@Core::extend()`@ using `[MyClass.prop.push(...)`].`*\n\n`#readOnly\n` `*May only be read, not changed.`*\n\n`#inMergeProps\nThis property is listed in `#_mergeProps by default so subclass defining it adds to its parent's object instead of overwriting it entirely (but identical keys are still overwritten).\n\n`#inMergePropsA\nThis property is listed in `#_mergeProps by default so subclass defining it adds to its parent's values instead of overwriting the array entirely.\n\n`#es6thiswarn\nWarning: avoid using ES6 arrow functions as handlers due to their fixed `'this (`#es6this).\n\n`#inBB\n`## In Backbone...\n\n`#unordered\nAttention: JavaScript objects are unordered, as explained in the description of `#Ordered.\n\n\n`#tag_Events Event system (`#evt):\n`#tag_Extension Inheritance-related:\n`#tag_Lifecycle Object's lifecycle (construct, attach, render, update):\n`#tag_Nesting Children and nesting (`#chld):\n`#tag_Options Dealing with options (`#opt):\n`#tag_Utilities Utility methods (`#util):\n\n\n","start":{"line":42,"column":-1,"offset":878},"end":{"line":79,"column":-1,"offset":2134},"forced":null,"modifiers":[],"file":"HELP.chem"},"795":{"type":"page","id":795,"name":"start","comment":"`! +pg=start +pgo=-10\n\n`# Introduction\n\n`## Sqimitive.js - A Universal Primitive\n\nSqimitive.js is a minimalistic paradigm-agnostic building block for applications written in JavaScript (not necessary in-browser or DOM-related). It provides core infrastructure without much domain-specific logic that you can quickly develop thanks to its flexible API.\n\n`* Declaration-time and run-time mix-ins and traditional OOP inheritance using events. `#evt `#events `#mixIn `#_mergeProps\n`* Collections with Underscore (or other) integration and assisted management of children. `#util `#_childEvents `#autoOff\n`* Transparently ordered collections. `#Ordered `#_repos\n`* Attributes with normalization, on-change notifications and batching. `#opt `#change_OPT `#batch\n`* Unserialization of data in arbitrary format. `#assignChildren `#assignResp\n`* DOM integration for \"views\". `#jQuery `@Base.elEvents`@\n`* Fractal Promise on steroids. `#Async `#Fetch\n\nSqimitive.js is under 20K (minified), sports documentation that is over 200 pages long (printed A4), needs no transpilers (plain pre-ES6 JavaScript, IE 11+) and depends only on a compatible utility library (NoDash `@no@`@ +16K, Underscore.js >=1.9.0 `@un:`@ or LoDash) and, optionally, on jQuery `@jq:`@ or Zepto (for `@Sqimitive\\jQuery`@).\n\nAnd it's in public domain (`@http://unlicense.org`@).\n\n`#-jqex\n\n`## Resources\n\n`<img src=\"data:image/gif;base64,R0lGODlhKQAQAIAAAP///8s5OCH5BAAAAAAALAAAAAApABAAAAJOjI+py+0Po5wK2GsP3np7kHygIY5BiYUXaaZst55jhri0fOf2bLK0roP9eKqhsCMkyopKnCf5WtZiwKfPKJW4KNxr97v9OkUMlPlcPosKADs\" alt=\"npm\"`> `*npm install sqimitive`*\n\n\n`* New to Sqimitive? Start with the overview: `#ov\n`* Download for development: `@https://github.com/ProgerXP/Sqimitive/archive/master.zip`@\n`* Download for production (minified): `@https://raw.githubusercontent.com/ProgerXP/Sqimitive/master/sqimitive.min.js`@\n`* Check out the sample To-Do application: `@https://squizzle.me/js/sqimitive/demo/to-do.html`@\n`* Report issues: `@https://github.com/ProgerXP/Sqimitive/issues`@\n`* Get the code on GitHub: `@https://github.com/ProgerXP/Sqimitive`@\n\nIf you spot a typo - select the fragment and press `*Ctrl+Enter`*. Help us keep this memo free of vexatious mistakes! Powered by `@https://github.com/ProgerXP/Orphus`@.\n\n`## Basic code conventions\n\n`* `*Protected fields begin with underscore (`'_)`* - such fields (data properties and methods) are meant to be read or written only by the class they are defined in, or by one of its subclasses. It's bad practice to try to access them from an ancestor (not the descendant they're defined in) or, mind you, from an unrelated class - this is only justified, if ever, by really severe optimizations (such as tons of `@Base._opt`@ calls bypassing `#get()).\n\n`* `*Naming style: underscores separating camelCase`* - when an identifier (`[oneId`]) needs to be combined with another (`[twoId`]) it becomes simply `[oneId_twoId`] instead of `[oneIdTwoId`], `[one_id_two_id`] or something else dictated by \"pretty printing\" identifiers. For example, `#Base fires events of form \"`#change_OPT\" so the event name used when `'attrName option (`@Base._opt`@) was changed is `'change_attrName.\n\n`* `*Semicolon-free zone`* - JavaScript is one of those languages where operation separators are optional, much like in Lua. You just need to remember to put `[;`] before any operation beginning with `[(`] (which most of the time has to do with IIFE):\n  `[\n    foo = 123\n    ;(function () { ... })()\n      // without ; above is equivalent to 123(function () { {... })()\n  `]\n\n`* `*`'null is `'undefined`* - unless mentioned, these two values are used interchangeably: when testing, use `[value == null`] instead of `[===`]; when supplying, give any of the two. One case when `'undefined is different are event handler results (see `#::fire()).\n\n`##deps Customizing dependencies\n\nSqimitive can be included using several methods as implemented by `[umh.js`]. Each method has its own way of overriding dependencies (which default to NoDash `@no@`@ and jQuery `@jq:`@). Alternatively, you can change the `'deps variable in the source code but you'll have to redo it on upgrade.\n\n`### CommonJS/Node.js\nIn npm 8.3+, put this into your project's `[package.json`] before doing `[npm install sqimitive`] (`@https://github.com/npm/cli/issues/4909`@):\n`[\n  \"overrides\": {\n    \"sqimitive\": {\n      \"nodash\": \"npm:underscore\",\n      \"jquery\": \"npm:zepto\"\n    }\n  }\n`]\n\n`### AMD/Require.js\nUse `'map and/or `'path options (`@https://requirejs.org/docs/api.html#config`@):\n`[\n  requirejs.config({\n    map: {\n      'sqimitive/main': {\n        'nodash/main': 'lodash'\n      },\n      'sqimitive/jquery': {\n        jquery: 'zepto'\n      }\n    },\n    paths: {\n      nodash: 'https://cdn.jsdelivr.net/npm/underscore@latest/underscore-umd-min.js'\n    }\n  })\n`]\n\n`### Plain `[<script>`]\nDependencies land in global `'window so simply fetch the needed script before including Sqimitive:\n`[\n  <script src=\"https://cdn.jsdelivr.net/npm/underscore@latest/underscore-umd-min.js\"></script>\n  <script src=\"https://raw.githubusercontent.com/ProgerXP/Sqimitive/master/sqimitive.min.js\"></script>\n`]\n\n\n","start":{"line":80,"column":-1,"offset":2134},"end":{"line":171,"column":-1,"offset":7273},"forced":null,"modifiers":[],"file":"HELP.chem"},"796":{"type":"page","id":796,"name":"vsbb","comment":"`! +pg=vsbb +pgo=10\n\n`# Comparing with Backbone\n\nSqimitive has been inspired by Backbone.js (`@bb:`@) and was written as a solution to most annoying problems after working with Backbone for months in a production project. It avoids certain less used (read: project-specific) features while conceptually bringing the rest under one roof. In particular, Sqimitive:\n\n`* Removes somewhat artificial separation for Model, Collection and View classes providing a single unified \"primitive\" (the \"sqimitive\"). This way Views can use options (`#opt - attributes with on-change notifications, `#change_OPT), Underscore.js helpers (`#util), object nesting (`#chld - just like Collections), jQuery/Zepto bindings (`[this.el`], `@jQuery.elEvents`@) and every other feature, shared by all, not imposed on any.\n\n`* Greatly expands on the idea of events (`#evt), making inheritance as sensible as possible given JavaScript's idea of OOP and adding automatic event management for connected objects (e.g. elements of a collection - `#_childEvents).\n\n`* Removes server-side communication layer (`@bb:Model-sync`@) while keeping routines to smart-update object states (`#assignChildren(), `#assignResp()). Instead of overriding parts of the library (as it's often done with Backbone) you implement them yourself just once given your unique project requirements.\n\nWhile different, Sqimitive will appear very familiar to Backbone users and being paradigm-free, it will even let you work the way you used with Backbone or another framework - in aspects you wish. You can create your own Model, Collection and View classes to follow MVC, use traditional `'__super__-style inheritance, write your specific `'sync() routines and so on.\n\nThis section highlights most notable gaps present in Backbone and other frameworks. Strictly subjective!\n\n`## OOP that makes sense\n\nIn Backbone and other JavaScript frameworks inheritance (overriding of parent properties and methods) is painful.\n\n` `*With properties`*, if it's a complex object that you would rather extend (append to) rather than replace entirely - as it is the case with `@bb:Model-attributes`@, `@bb:Model-defaults`@, `@bb:View-events`@ (DOM bindings) and others - you have to add them in the constructor because if you define such a property in the child class you will `*entirely overwrite the inherited value`*. Moreover, if at some point the base class that did not have that property decided to declare it - all its subclasses overwrite it without notice... Unless you remember to update them, which is an unnecessary cognitive burden.\n\n` `*With methods`*, you have to hardcode reference to the base class - that's not to mention the entire construct which is already ugly: `[My.Class.__super__.baseMethod.apply(this, arguments)`]. So if you later rename the base class or move this subclass under another parent, or rename the method, or just make a typo - the entire inheritance chain for this method is broken. You may or may not get an error, too.\n\nThis is the price for trying to push classic OOP into JavaScript prototype model.\n\nSqimitive solves both problems by using `#_mergeProps for listing which properties should be merged together on extension. For methods, there is a fantastic event-driven inheritance (`#evt) that makes JavaScript OO coding a breeze. Any method can be turned into an event without altering the base class, it can be temporary (`#once()) and works for \"traditional\" events too, like `#change notifications.\n\nAt the same time, the `'__super__ way of doing this is still available if you are feeling a bit masochistic.\n\nBelow is just one simple example. Look for more details at the mentioned sections.\n\n`[\n  var MyBaseClass = Sqimitive.jQuery.extend({\n    complexProp: {\n      base: 123,\n    },\n\n    init: function () {\n      alert('I init()!')\n    },\n  })\n\n  // _mergeProps is a static property.\n  MyBaseClass._mergeProps.push('complexProp')\n\n  var MySubclass = MyBaseClass.extend({\n    complexProp: {\n      sub: 'foo',\n    },\n\n    events: {\n      init: function () {\n        alert('Now I init() too!')\n      },\n    },\n  })\n\n  var obj = new MySubclass\n    // 1. alert: I init()!\n    // 2. alert: Now I init() too!\n  alert(obj.complexProp.base)\n    // alert: 123\n  alert(obj.complexProp.sub)\n    // alert: foo\n`]\n\n`## Built-in child nesting\n\nBackbone offers no nested views out of the box. There are plugins such as Babysitter (from Marionette.js, `@https://github.com/marionettejs/backbone.babysitter`@) but they don't provide a complete solution.\n\nIn Sqimitive, nested views are native. When used, they are automatically managed: elements and event listeners removed (`#autoOff()) when the corresponding view is removed, DOM events rebound (`@jQuery.elEvents`@) and root element reinserted (`@jQuery.attach()`@) when root element is moved (e.g. on `#render()), it is possible to filter (`#util) nested views using Underscore methods (just like filtering contents of `@bb:Collection`@s in Backbone), receive notifications about newly `#nested/`#unnested/changed views, maintain sort order (`#Ordered, `#_repos) and so on.\n\nNo more need for `'delegateEvents(), `[off(null, null, this)`] or `[return this`] (when overriding `'render() thanks to `#evtpf).\n\nSee more details and examples in the Views overview section (`#vw).\n\n`## Change-driven behaviour\n\nIn Backbone and other frameworks, you have to track changes to your data and view states. Backbone eases this task by providing standard events like `[change:attr`] event for Models. However, this approach must be brought further to let us take full advantage of it.\n\nIn Sqimitive, you get a special object property - `@Base._opt`@ (\"options\") - that is a pool of trackable states, similar to Backbone's `@bb:Model-attributes`@. Items in this pool are read with `#get() and written with `#set(). When a new and different value is written a bunch of events occurs; within their listeners you can cancel or normalize the change (`#normalize_OPT()) or perform an action (`#change_OPT() and `#change()). Parent sqimitives can optionally forward their children events to themselves (`#_childEvents).\n\nThis can be used to create event observation spots too. Suppose that you have an object that's loading some data from the server. Since it's asynchronous you don't know when (or if) it will finish. Usually you would either create a callback property and call it or use a custom event (like jQuery and Backbone do) and trigger it once loading is done. In Sqimitive, you simply introduce some `[_opt.loading`], set it to `'false initially and once done - change to `'true. Observers listen to the `'change_loading event having the full set of event handling routines at their disposal (`#on, `#once, `#fuse, `#off, `#autoOff, `#logEvents, etc.) instead of introducing `'isLoading(), `'abortLoading(), `'onLoading(), etc.\n\nThanks to the new option, this starts working the other way too: an external object can `[set('loading', true)`] to trigger data refresh on the object. Better still - the loading object itself can set this option to trigger its own loading routine - naturally, avoiding code duplication.\n\nMoreover, since options are not accessed directly you can always listen for their access with `'get or add custom behaviour with `'set, disregarding the fact they are originally methods (`#get(), `#set()). Lack of direct access to `#opt'ions improves stability of the code base.\n\nGiven this mechanism you can significantly lower your `'render() and custom event rates while being much more aware of what has triggered the change at the same time, performing incremental (lightweight) updates. And since Models and Views are the same thing in Sqimitive these principles work universally for any kind of object you might have.\n\n`[\n  var MyView = Sqimitive.jQuery.extend({\n    _opt: {\n      loading: false,\n      people: [],   // array of names.\n    },\n\n    // We will keep jqXHR object here to be able to abort the request.\n    _loadingXHR: null,\n\n    events: {\n      init: function () {\n        // Wait 300 msec and then start fetching server data.\n        _.delay(_.bind(this.set, this, 'loading', true), 300)\n      },\n\n      // Loading was either cancelled or started.\n      change_loading: function (value) {\n        // Update class name of our DOM element.\n        this.el.toggleClass('loading', value)\n        // Abort old request, if any.\n        this._loadingXHR && this._loadingXHR.abort()\n\n        if (value) {\n          // Fetch the data, pass to _load().\n          this._loadingXHR = $.getJSON('api/get/some', _.bind(this._load, this))\n        }\n      },\n\n      // _opt.people changed - update names.\n      change_people: '_updatePeople',\n\n      render: function () {\n        // Retrieve all _opt to pass them to the template.\n        var vars = this.get()\n        // Overwrite with new HTML.\n        this.el.html(_.template($('#MyViewTemplate').text(), vars))\n        // Add peoples' names.\n        this._updatePeople()\n      },\n    },\n\n    _updatePeople: function () {\n      var el = this.$('.people').empty()\n\n      _.each(this.get('people'), function (name) {\n        $('<em>').text(name).appendTo(el)\n      })\n    },\n\n    _load: function (resp) {\n      // Do something with resp, then finally:\n      this.set('loading', false)\n    },\n  })\n`]\n\n`## Events do occur on events - no cheating\n\nIf you have used Backbone's `'add, `'remove and `'change events then you probably know that they do not occur... always. For example, if you `'reset() a Collection it won't fire `'add for new Models, `'remove for gone or `'change for existing Models that were updated.\n\nThis smells like an optimization - after all, firing hundreds of events when resetting a huge Collection might be slow. However, such cases are very rare and yet the existence of `'reset() makes it problematic to track the updates because often you will end up with your own routine bound to `'reset as an event that will figure the difference between old Collection contents and new one.\n\nThis also happens with attribute normalization on Models that for some reason doesn't occur when assigning an API response.\n\nSqimitive fires events when things change, period. In case you do have a performance-heavy object you can always implement your own, less \"noisy\" and more optimized update routines. However, 90% of the time you will rely on `#nest, `#unnested, `#change and others to keep you notified.\n\n`## Cloned instance properties\n\nIn JavaScript, when you create a prototype with properties having non-scalar values (like objects or arrays) what you actually create are `*shared instance properties`*. If at run-time you modify such a property (but not reassign it) this operation will affect all objects where that property was defined, unless its value was overwritten with a new object.\n\nBackbone inherits this behaviour which most of the time leads to very confusing results (from the human's perspective). Consider this snippet (`@http://jsfiddle.net/Proger/vwqk67h8/`@):\n\n`[\n  var MyView = Backbone.View.extend({foo: []})\n  var first = new MyView\n  var second = new MyView\n  first.foo.push(123)\n  alert(second.foo[0])\n  // alert: 123\n`]\n\nThe only way around is to assign such properties in the constructor, which you should first override using the crazy `[My.Class.__super__.baseMethod.apply(this, arguments)`] construct. This gives your code -50 points in the ability to save kittens on this planet!\n\nSqimitive eliminates this problem by automatically deep cloning (`#deepClone) all complex values upon new object instantiation. Of course, sometimes this is not desired - for this you can always assign them in the constructor just like before or list them in `#_shareProps to prevent automatic cloning.\n\n`## Backbonization\n\nThe following tricks can be used to make Sqimitive's API appear more like Backbone's. It will not make it 100% identical so don't use it in production as is - it's intended to give you some pointers.\n\n`### General\n\nIn Backbone, `#_cid is named `@bb:Model-cid`@, `@jQuery.el`@ is `@bb:View-$el`@ with the `@bb:View-el`@ counterpart (native DOM node), `#fire() is named `@bb:Events-trigger`@(), `@bb:Events-listenTo`@() and `@bb:Events-stopListening`@() are `#autoOff()  flavours, `@bb:Model-toJSON`@() is basically `#get(), `@bb:Model-attributes`@ is the same as `@Base._opt`@, `@bb:Model-defaults`@ are declaration-time `'_opt.\n\n`[\n  var BackboneBase = Sqimitive.Base.extend('BackboneBase', {\n    cid: null,    // alias to _cid; do not write to.\n\n    events: {\n      '-init': function () {\n        this.cid = this._cid\n      },\n\n      init: function () {\n        this._childClass = this._childClass || this.model   // used below.\n      },\n    },\n\n    trigger: function (event, arg_1) {\n      return this.fire(event, _.rest(arguments))\n    },\n\n    listenTo: function (sqim, event, func) {\n      this.autoOff(sqim, _.object([[event, func]]))\n      return this\n    },\n\n    stopListening: function (sqim, event, func) {\n      if (!arguments.length) {\n        return this.autoOff()\n      } else if (func || (sqim && event)) {\n        throw new Error('Unsupported stopListening() call.')\n      } else {\n        return this.off(event || sqim)\n      }\n    },\n  })\n`]\n\n`### Collection\n\nCollections have `@bb:Collection-model`@ (a class reference) which simply specifies `#_childClass, `@bb:Collection-reset`@() is alike to `#assignChildren (`'Collection's `@bb:Collection-set`@() is entirely different though), `@bb:Collection-push`@(), `@bb:Collection-pop`@(), `@bb:Collection-shift`@(), `@bb:Collection-unshift`@() are shortcuts for `#nest() and the company of `#util (Sqimitive by default is not `#Ordered), `@bb:Model-clone()`@ is another shortcut for non-`#_owning lists. Models are keyed by their `@bb:Model-id`@ attribute value (or `@bb:Model-idAttribute`@) which are like `#_defaultKey().\n\n`[\n  var BackboneCollection = BackboneBase.extend('BackboneCollection', {\n    model: null,  // alias to _childClass; do not write to.\n    el: null,\n    idAttribute: 'id',\n\n    events: {\n      '=assignChildren': function (sup, resp, options) {\n        options = _.extend(options || {}, {eqFunc: this.idAttribute})\n        return sup(this, [resp, options])\n      },\n    },\n\n    _defaultKey: function (model) {\n      return model.get(this.idAttribute)\n    },\n\n    reset: function (models, options) {\n      if (!arguments.length) {\n        this.each(this.unlist, this)\n      } else {\n        this.assignChildren(models, {\n          eqFunc: this.idAttribute || 'id',\n          keepMissing: !('remove' in options) || !options.remove,\n        })\n      }\n\n      return this\n    },\n\n    push: function (model) {\n      this.nest(model)\n    },\n\n    unshift: function (model) {\n      this.nest(model)\n    },\n\n    pop: function () {\n      var model = this.last()\n      model && model.remove()\n      return model\n    },\n\n    shift: function () {\n      var model = this.first()\n      model && model.remove()\n      return model\n    },\n\n    toJSON: function () {\n      return this.invoke('get')\n    },\n\n    clone: function () {\n      if (this._owning) {\n        throw new Error('clone() will clear the original collection.')\n      }\n\n      var copy = new this.constructor(this.get())\n      this.each(function (child, key) { copy.nest(key, child) })\n      return copy\n    },\n  })\n`]\n\n`### Model\n\nModels' `@bb:Model-escape`@() and `@bb:Model-has`@() are shortcuts for `#get(). `@bb:Model-id`@ option (\"attribute\") is readable/writable as `[get('id')`]/`[set('id', ...)`] and also readable directly as `[obj.id`] (write attempts won't be caught nor will they change the \"real\" `'id).\n\n`[\n  var BackboneModel = BackboneBase.extend('BackboneModel', {\n    attributes: {}, // alias to _opt; do not write to.\n    defaults: {},   // alias to declaration-time _opt; do not write to.\n    id: null,       // alias to get('id'); do not write to.\n\n    _opt: {\n      id: null,\n    },\n\n    events: {\n      '-init': function () {\n        this.defaults = Sqimitive.Core.deepClone(this._opt)\n      },\n\n      init: function () {\n        this.attributes = this._opt\n      },\n\n      change_id: function (id) { this.id = id },\n    },\n\n    toJSON: function () {\n      return this.get()\n    },\n\n    escape: function (opt) {\n      return _.escape(this.get(opt))\n    },\n\n    has: function (opt) {\n      return this.get(opt) != null    // undefined or null.\n    },\n  })\n`]\n\n`### View\n\nViews have `@bb:View-setElement`@(), `@bb:View-delegateEvents`@() and `@bb:View-undelegateEvents`@() that are similar to `@jQuery.attach()`@.\n\n`[\n  var BackboneView = BackboneBase.extend('BackboneView', {\n    el: null,     // el must remain a wrapped jQuery node in Sqimitive.\n    $el: null,    // alias to el; do not write to.\n\n    events: {\n      init: function () {\n        this.$el = this.el\n      },\n    },\n\n    setElement: function (el) {\n      this.undelegateEvents() // unnecessary since attach() does this already.\n      this.el = this.$el = el\n      return this.attach()    // only binds events if el has no parent.\n    },\n\n    delegateEvents: function (events) {\n      this.elEvents = events\n      return this.attach()    // only binds events if el has no parent.\n    },\n\n    undelegateEvents: function () {\n      this.el.off('.sqim-' + this._cid)\n    },\n  })\n`]\n\n`### Babysitting Models\n\nOne of the most common problems when developing a complex client-side app is keeping track of multiple Models or of a Collection connected to a particular View. When a new Model appears you need to create and display a new nested View; when it's removed - its View should go away; when Model attributes change the View should be updated (and this case is often but not always handled by that Model's specific View).\n\nOn top of that, when parent View acquires another Collection it should properly detach itself from the previously assigned Collection, attach to the new object and repopulate itself.\n\nThings get even more complex with asynchronous operations - sometimes the user gets ahead of his network packets and you don't want the user interface to tangle up.\n\nSqimitive addresses all of these challenges:\n\n`* Attach/detach event handlers to the related Collection with `#autoOff() or `[off(collection)`] (`#off).\n`* Keep that Collection as an option (`@Base._opt`@) so once it changes you receive `[change_collection(newCol, oldCol)`] event (`#change_OPT).\n`* Make sure only proper Collections are assigned by checking the value-to-be-set in `[normalize_collection(newCol)`] (`#normalize_OPT).\n`* Listen to new Models with `#on on `@Base.nestEx`@ (`[on('+nestEx')`]) and to gone Models on `#unnested.\n`* Listen to changed Models via `#_childEvents: set it to `[['change']`] and listen to `[on('.change')`].\n`* Automatically manage nested Views' connections to DOM with `'attachPath (`@jQuery._opt`@) and `@jQuery.attach()`@. Quite often there's no need for `#render() at all.\n\nSample code below demonstrates this in practice. It's a good idea to make a class handling this basic logic and reuse it throughout your project.\n\n`[\n  var ParentView = Sqimitive.jQuery.extend({\n    _childClass: ChildView,\n\n    _opt: {\n      collection: null,   // Collection.Foo.\n    },\n\n    normalize_collection: function (newCol) {\n      if (!(newCol instanceof Collection.Foo)) {\n        throw new Error('Bad collection type.')\n      } else {\n        return newCol\n      }\n    },\n\n    change_collection: function (newCol, oldCol) {\n      // Unbind self from the old collection, if any.\n      oldCol && oldCol.off(this)\n\n      // Clear existing nested Views, if any (this form only works if _owning).\n      this.invoke('remove')\n\n      // Set up the link to the new collection.\n      if (newCol) {\n        this.autoOff(newCol, {\n          nestEx: function (options) {\n            options.changed && this._modelAdded(options.child)\n          },\n          unnested: '_modelRemoved',\n          // Requires that the collection declares _childEvents: ['change'].\n          '.change': '_modelChanged',\n        })\n\n        // Populate with the existing models.\n        newCol.each(this._modelAdded, this)\n      }\n    },\n\n    _modelAdded: function (model) {\n      // This is the place where a new View gets created, nested and linked to\n      // the model. First argument to nest() is view's parent key by which it\n      // can be retrieved later. Model's ID is usually unique so use it if you\n      // have one. If this key already existed then that View will be removed\n      // and replaced with the new View.\n      var view = this.nest(model.get('id'), new this._childClass({\n        model: model,\n        attachPath: '.models',\n      }))\n\n      // Append view.el to this.el.find('.models') and bind its DOM event\n      // listeners. This won't render() the View but it might listen to\n      // 'attach' and call render() automatically.\n      view.attach()\n      // ...If it doesn't auto-render - no big deal:\n      view.render()\n    },\n\n    _modelRemoved: function (model) {\n      var view = this.nested(model.get('id'))\n      if (view) {\n        // Removes view's DOM element from this.el and unnests view from this\n        // children. This essentially unbinds view's DOM listeners and its\n        // Sqimitive listeners on the parent (this).\n        view.remove()\n      } else {\n        console.warn('Removed a Model with no nested View.')\n      }\n    },\n\n    _modelChanged: function (model) {\n      // Update something when model's options change...\n    },\n  })\n`]\n\nThe above code can be used like this:\n\n`[\n  var col = new Collection.Foo\n  col.nest(new Model.Foo({id: 1}))\n\n  new ParentView({collection: col, attachPath: 'body'})\n    // Gets created with one nested ChildView (existing Model in col).\n    // ParentView's el is appended to <body>.\n\n  col.nest(new Model.Foo({id: 2}))\n    // New ChildView nested. Now col.length and ParentView's length are 2.\n\n  col.nested(2).remove()\n    // Removed the just nested View after retrieving it by its key (\"id\" here).\n\n  col.nested(1).set('smth', 'foo')\n    // The '.change' event got fired on ParentView.\n`]\n\n\n","start":{"line":172,"column":-1,"offset":7273},"end":{"line":649,"column":-1,"offset":29283},"forced":null,"modifiers":[],"file":"HELP.chem"},"797":{"type":"page","id":797,"name":"ov","comment":"`! +pg=ov +pgo=-3\n\n`# Anatomy of a Sqimitive\n\nObjects in Sqimitive are homogeneous and mostly deal with other \"sqimitives\" only - the basic building blocks provided by the library, the \"primitive\".\n\nEach sqimitive has three fundamental features that in different combinations cover an extremely wide range of tasks: `*`#opt options`*, `*`#chld children`* and `*`#evt events`*. Below is a quick high-level overview to demonstrate the main idea; consult the API documentation on `#Core, `#Base and others with hundreds of examples if you want to get all out of Sqimitive.\n\n`##opt Options\n\n` `*Options`* are `@bb:Model-attributes`@ in Backbone's terms - set of key/value pairs defined under `@Base._opt`@ which trigger events on `#change or access, can be normalized and can be virtual (i.e. you can write your accessor that won't correspond to a \"physical\", listed option). They are solely accessed via `#set() and `#get() methods to create a sort-of public object interface.\n\nSample code below defines a class with two options - `'isCompleted (boolean) and `'caption (string). When one of them is changed, the associated DOM node is updated (see the sample To-Do application for more: `@https://squizzle.me/js/sqimitive/demo/to-do.html`@).\n\n`[\n  var MyToDoItem = Sqimitive.jQuery.extend({\n    _opt: {\n      isCompleted: true,\n      caption: 'Do me at home!',\n    },\n\n    events: {\n      // When task becomes complete or incomplete its DOM element gets that\n      // class added or removed on the fly.\n      change_isCompleted: function (newValue) {\n        this.el.toggleClass('done', newValue)\n      },\n\n      change_caption: 'render',\n    },\n\n    // HTML template for this node's contents as used below.\n    _tpl: '<h3><%- caption %></h3>',\n\n    normalize_isCompleted: function (value) {\n      // Turn whatever is given as a new value for isCompleted into a boolean.\n      // If the result is identical to the current value - 'change' is not\n      // fired.\n      return !!value\n    },\n\n    // Trim whitespace around the caption.\n    normalize_caption: function (value) {\n      return _.trim(value)\n    },\n\n    render: function () {\n      // Retrieve the map of all options/values and pass them as variables to\n      // the template. Note that template() implementation differs in NoDash,\n      // Underscore and LoDash.\n      var vars = this.get()   // = {isCompleted: false, caption: 'foo'}\n      this.el.html(_.template(this._tpl, vars))\n    },\n  })\n`]\n\n`##chld Children\n\n` `*Children`* are zero or more \"sqimitives\" `#nested into zero or more parent \"sqimitives\". Their events may be forwarded to parent - but only while they are still part of that parent (`#_childEvents); upon removal they are automatically unbound (`#autoOff). When a child is added or removed its parent, if any, gets notified (`#unnested). Also, most of Underscore.js is available as methods to easily filter or transform children into native arrays or objects (`#util).\n\nParent sqimitives can be of two types: `*`#_owning`* (by default) and `*non-owning`*. First represent a typical tree where each child has exactly one `#_parent and which you can traverse the tree in either direction starting from any node. If you `#nest a child into another parent it's automatically removed from the former owner. Second type is more of a list where you can only traverse from the outside because a child doesn't know in what other sqimitives it might be listed in, if at all, and no automatic removal is done when a child becomes part of another parent.\n\nSample code below defines a to-do list that is meant for storing `[MyToDoItem`]s from the above example. Note that in Backbone you would have at least two classes: one `@bb:Collection`@ for storing the list of to-do items and one `@bb:View`@ for displaying that collection... Or, to be brutally honest, you would create four classes: a `@bb:Model`@ holding data of a single to-do item, a `@bb:View`@ displaying it, a `@bb:Collection`@ holding to-do items as a whole and another `@bb:View`@ holding the Collection holding the Models - and you still have to link each Model to its View and keep track of their events and DOM elements.\n\nIn Sqimitive you can still do all that but it's the author's opinion that such pure concepts are only good for academics and very large projects - most of the time you would rather have something more utilitarian and dirty, if you will. Sqimitive allows you a choice since everything is ultimately a primitive and can be \"purified\" to the point you need.\n\nNote that the hierarchy of sqimitives (defined by `#nest) doesn't necessary reflect the hierarchy in DOM (of `@jQuery.el`@) - `#_children can have their elements under their `#_parent's `'el or elsewhere, or not have DOM elements at all (as \"models\" do).\n\n`[\n  var MyToDoList = Sqimitive.jQuery.extend({\n    // Add extra protection against accidental foreign class being added as a\n    // child.\n    _childClass: MyToDoItem,\n    // Leading dash means \"listen before\" - see next section about events.\n    _childEvents: ['-change', 'change'],\n\n    events: {\n      // To avoid collisions between children-generated and self events those\n      // forwarded from children get prepended with a period. If you have\n      // another parent that is forwarding its child's children events then\n      // another period appears - e.g. '..change'. Think of this as of regular\n      // '../../path' notation where each period means \"one level above\".\n      '.-change': function (sqim, optName, newValue, currentValue) {\n        // Outputs something like \"To-do item's caption ... from foo to bar\".\n        console.log('To-do item\\'s ' + optName + ' is about to be changed' +\n                    ' from ' + currentValue + ' to ' + newValue)\n      },\n\n      '.change': function (sqim, optName, newValue, currentValue) {\n        console.log(optName + ' has changed to ' + newValue)\n      },\n    },\n\n    postInit: function () {\n      var itemOptions = {isCompleted: false, caption: 'Dummy item'}\n      var sqim = this.nest(new MyToDoItem(itemOptions))\n      sqim.set('caption', 'fire them!')\n      // Because of forwarded events two new messages have appeared in the\n      // console.\n\n      // Can also assign an explicit name (if omitted _cid is used).\n      this.nest('childName', new this._childClass)\n      // Can retrieve the object like this:\n      var sqim = this.nested('childName')\n      sqim.unnest()\n    },\n\n    // Use Underscore to retireve only children with isCompleted being false.\n    getIncomplete: function () {\n      // picker() gets inherited from Sqimitive.Core and is simply a function\n      // calling a method on the given object with given parameters. In other\n      // words, equivalent to ES6's: (o) => o.get('isCompleted') LoDash has a\n      // similar method called rearg().\n      return this.reject(MyToDoList.picker('get', 'isCompleted'))\n    },\n  })\n`]\n\n`##evt Events\n\n` `*Events`* are Squimitive's Swiss Army Knife to deal with everything from inheritance (OOP style - `#extend and `#mixIn) and prototyping (native JavaScript style) to dynamic property morphing and dispatching notifications in an Observer-like fashion. When defined upon class declaration handlers are \"`#fuse'd\" into the class (reducing their performance overhead), otherwise they work as regular event listeners that can be manipulated on run-time using `#on, `#off and others (for instance, they are automatically removed once a `#nested sqimitive is `#unnested).\n\nWhen you try to listen to an event and there is a method of the same name, Sqimitive turns that method into an event slot and the method itself becomes its first listener. This way every method is potentially an event that you can manipulate on run-time as well as upon declaration (`#events), working with nearly conventional OOP as found in languages like C and PHP while still utilizing the power of dynamic object manipulation as it's meant with JavaScript.\n\nLikewise, if there is no method when you define an event - Sqimitive creates it so that calling it actually triggers the event (`#firer). This way you can always invoke a method without knowing if it's a real function or an event trampoline, bridging the gap between the two.\n\nAn example to demonstrate how methods become events \"on demand\" (`#logEvents):\n`[\n  var MyBase = Sqimitive.Base.extend({\n    // render() is essentially a function, regular \"method\".\n    render: function () {\n      this.el.text('Hello!')\n    },\n  })\n\n  // What we're doing is calling a function. It's not an event and won't be\n  // caught by logEvents().\n  ;(new MyBase).render()\n\n  var MyChild = MyBase.extend({\n    events: {\n      render: function () {\n        this.el.append('...I extend...')\n      },\n    },\n  })\n\n  // Now we are in fact firing 'render' which is an event with two listeners:\n  // one from MyBase (called first) and another from MyChild. 'render' is fired\n  // whenever we call render() in MyChild and descendants, and for them\n  // logEvents() logs the call.\n  ;(new MyChild).render()\n\n  // POTENTIALLY WRONG:\n  var MyChile = MyChild.extend({\n    render: function () {\n      alert('Boom!')\n    },\n  })\n\n  // Now we're back to event-less render() - a mere function. Note that two\n  // former 'render' handlers are still present so if we attach a new listener\n  // to 'render' current render() (\"Boom\") will be prepended to the list of\n  // handlers as a 3rd handler and MyChile.render() itself will be replaced by\n  // firer('render'). It's a bad practice to supersede an \"evented\" function\n  // like this and usually indicates a mistake (forgetting that a method of the\n  // same name exists in some parent). Consequently, logEvents() here won't\n  // track anything. More on this below, in #evtconc.\n  ;(new MyChile).render()\n`]\n\nCompare Sqimitive-style inheritance (`#evtpf) and the traditional inheritance using `'__super__ (which still works in Sqimitive):\n`[\n  var MyBase = Sqimitive.Base.extend({\n    effect: function (arg) {\n      console.log('MyBase.effect(' + arg + ')')\n      return this\n    },\n  })\n\n  // Traditional JavaScript-OOP inheritance as supported by Backbone.\n  var JsOopSubclassing = Sqimitive.Base.extend({\n    // This way you override the inherited method, entirely.\n    effect: function (arg) {\n      return 'foo'\n    },\n\n    // Calling the inherited implementation...\n    effect: function (arg) {\n      console.log('pre-actions')\n      // We have to hardcode current class and method names, plus the call is\n      // quite long.\n      var result = JsOopSubclassing.__super__.effect.apply(this, arguments)\n      console.log('post-actions')\n      return result\n    },\n  })\n\n  // Event-oriented Sqimitive inheritance.\n  var SqimitiveSubclassing = Sqimitive.Base.extend({\n    events: {\n      // This is how you override the entire method in Sqimitive.\n      '=effect': function (sup, arg) {\n        return 'foo'\n      },\n\n      // ...and this is how you call the inherited implementation.\n      '=effect': function (sup, arg) {\n        console.log('pre-actions')\n        // No hardcoded class reference, concise calling format.\n        var result = sup(this, arguments)\n        console.log('post-actions')\n        return result\n      },\n\n      // However, such a full override is rarely needed - most often you only\n      // need to do something after the original method executes, keeping its\n      // return value. This one is identical to the above in effect but without\n      // logging 'pre-actions'.\n      effect: function (arg) {\n        console.log('post-actions')\n      },\n\n      // Sometimes we need to do just 'pre-actions' - this is how.\n      '-effect': function (arg) {\n        console.log('pre-actions')\n      },\n\n      // Yet at other times we need to call the original code and obtain and/or\n      // change its return value.\n      '+effect': function (result, arg) {\n        console.log('post-actions')\n\n        if (result === this) {\n          // Return something other than the original code returned.\n          return new That(arg)\n        }\n\n        // Returning undefined or not returning at all retains the current\n        // result. These are identical:\n        //return undefined\n        //return\n      },\n    },\n  })\n`]\n\nFinally, to demonstrate the usage of dynamic event binding and method overriding.\n\n`[\n  var DynamicEvents = Sqimitive.Base.extend({\n    events: {\n      slotA: function () {\n        console.log('slotA')\n        return 'slotA'\n      },\n    },\n\n    slotB: function () {\n      return 'slotB'\n    },\n\n    // Just a property that isn't a function.\n    notASlot: 123,\n\n    listeners: function () {\n      // When slotA is fired, it outputs \"slotA\" and \"post-effect\" to the\n      // console and returns 'slotA'. Exactly the same would be with slotB even\n      // though it was't explicitly declared as an event - it becomes one as\n      // soon as the first handler is attached.\n      this.on('slotA', function () {\n        console.log('post-effect')\n      })\n\n      // Nobody said we can't create events out of thin air without defining\n      // them anywhere first. Note that since it's an event handler and not a\n      // class method it cannot return any value (it would be ignored). This\n      // way no disruption is caused if the class suddenly declares a method of\n      // the same name (this handler will be called after it).\n      this.on('slotC', function () {\n        console.log('post-effect')\n        return 'ignored'\n      })\n\n      this.slotC()        // both are\n      this.fire('slotC')  // equivalent.\n\n      // Of course, events can have prefixes seen in the previous sample.\n      this.on('+slotC', function (result) {\n        console.log('post-effect')\n        return 'new result'\n      },\n\n      this.on('-slotC', function () {\n        console.log('pre-effect')\n        return 'ignored'\n      })\n\n      // You can do a full override as well - and the beauty is that you can\n      // off() it any time later and original method(s) (now \"inside\" sup) will\n      // be put back in place.\n      this.on('=slotC', function (sup) {\n        console.log('pre-effect')\n        var result = sup(this, arguments)\n        console.log('post-effect')\n        return result\n      })\n\n      // If you try to turn a non-method into an event nothing will break - you\n      // will add an event listener all right and fire('notASlot') will work\n      // but doing notASlot() won't fire the event - only access that property.\n      // Granted, it's confusing to have an event which works differently from\n      // this.notASlot() so better avoid it.\n      this.on('notASlot', function () {\n        alert('Boo!')\n      })\n\n      alert(this.notASlot)    // alerts 123.\n      this.fire('notASlot')   // alerts Boo!\n    },\n\n    dynamic: function () {\n      var handler = function () { };\n      var context = new SomeObject;\n\n      // Unless \"fused\" (on class declaration time), each event handler gets a\n      // unique ID that can be used to unbind it later (very fast). Contrary to\n      // the common approach, Sqimitive offers no event namespaces (such as\n      // my.handler) used to unbind group of events - by-context lookup is\n      // available and it covers most of such use-cases (see below).\n      var id = this.on('event', handler)\n      this.off(id)\n\n      // You are free to use dots and colons in event names for your needs.\n      this.on('com.myapi.proc:group', handler)\n\n      // Slower but removes all bindings to the given context object among all\n      // events of this object in one go.\n      this.on('withContext', handler, context)\n      this.off(context)\n\n      // You can also clear all listeners to a particular event.\n      this.on('wipeEvent', handler)\n      this.off('wipeEvent')\n    },\n  })\n`]\n\n`##evtconc Events vs methods on extension\nAs demonstrated, method calls are often event triggers in disguise and so both `[obj.method()`] and `[obj.fire('method')`] work exactly the same way. However, there is a catch: when `#extend'ing a class or an object (`#mixIn) you can either add methods within the `#events property or list them as regular properties - and the latter is wrong. Compare:\n`[\n  // WRONG:\n  Sqimitive.Base.extend({\n    method: function () { ... }\n  })\n\n  // CORRECT:\n  Sqimitive.Base.extend({\n    events: {\n      '=method': function () { ... }\n    }\n  })\n`]\n\nThe first declaration is bad: it overrides the `#firer of `'method so if called as `[obj.method()`] it works as expected but as soon as a new handler is added with `#on/`#once/`#fuse the defined `'method() is moved to the beginning of handlers of the `'method event while retaining all previously defined handlers on that event (unlike with `'=method which removes old handlers entirely, see `#evtpf). Also, `[obj.fire('method')`] calls old (now concealed) handlers while `[obj.method()`] does not, with different side effects to the caller!\n\n` `*Follow this rule of a thumb:`* when introducing a method (or an event, which are very close things in Sqimitive) - declare it as a property; when overriding an existing method - always put it into `#events, without exceptions.\n\nBut then, if you want to be on the safe side you can declare all functions in `#events - they will work just like regular methods but you'll need a bit more typing (as the empty event prefix ignores return value - `#evtpf).\n\n`#vw Opening the views\n\nOptions, children and events compose 90% of what a sqimitive is. However, they all are mostly about logic and data; to make the user happy we should interact with him and present some visual information. This is when Views in MVC and Backbone terminology come into play.\n\nBy default, each sqimitive possesses a `*DOM element`* stored in `[this.el`] - a jQuery/Zepto object. It can be disabled for pure data classes (like Models or Collections) but if it isn't then such a node is automatically created by the constructor and assigned to this property (`@jQuery.el`@). Then you can make use of automatic binding of DOM events via `@jQuery.elEvents`@ and of convenient methods like `@jQuery.attach()`@, `@jQuery.remove()`@, `[this.$('sel.ector')`], `[bubble('eventForAllParents')`] and others.\n\nSample code below creates a simple login form. It stores data in its own `#opt'ions but, as you must know by now, Sqimitive allows you to extract it into another Model-like object if you need more abstraction in your application.\n\n`[\n  var MyFormView = Sqimitive.jQuery.extend({\n    // If omitted will create just a plain <div>.\n    el: {tag: 'form', action: 'javascript:void 0', className: 'login-form'},\n\n    _opt: {\n      login: '',\n      password: '',\n      remember: false,\n    },\n\n    elEvents: {\n      submit: function () {\n        var data = this.el.serializeArray()\n        $.each(data, _.bind(this.set, this))\n\n        $.ajax({\n          url: 'login',\n          type: 'POST',\n          data: data,\n          context: this,\n          success: this.loggedIn,\n          error: function () {\n            this.addClass('error')\n          },\n        })\n\n        return false\n      },\n\n      'change [name=remember]': function (e) {\n        this.set('remember', e.target.checked)\n      },\n\n      render: function () {\n        this.el.empty()\n          .append('<input name=login autofocus>')\n          .append('<input name=password type=password>')\n          .append('<input name=remember type=checkbox>')\n          .append('<button type=submit>Log In</button>')\n\n        this.update()\n      },\n    },\n\n    update: function () {\n      this.$('[name=login]').val(this.get('login'))\n      this.$('[name=password]').val(this.get('password'))\n      this.$('[name=remember]')[0].checked = this.get('remember')\n    },\n\n    // stub() is just a function that returns undefined (nothing). When it's\n    // used in place of a method and if that method becomes an event (getting a\n    // listener) then there's a small optimization - Sqimitive removes the old\n    // method entirely without adding it as a listener for that event.\n    //\n    // Alternatively, you could just leave this undefined and always use\n    // fire('loggedIn') but it's against Sqimitive conventions, more tricky and\n    // less obvious if you ever get a loggedIn() method that for any reason\n    // does something else.\n    loggedIn: Sqimitive.jQuery.stub,\n  })\n`]\n\nWe can use the above class as follows:\n\n`[\n  // A typical use case - just create a new form object along with its DOM\n  // element:\n  var sqim = new MyFormView({login: 'default@login'})\n\n  // Or if we have an existing container element - use it:\n  var sqim = new MyFormView({login: 'default@login', el: '#loginForm'})\n\n  // Then we can listen to new sqimitive's events like so:\n  sqim.on('loggedIn', function () { alert('Hello, ' + this.get('login')) })\n\n  // ...or morph it dynamically - just like good old JavaScript but better:\n  sqim.on('=render', function (sup) {\n    if (location.protocol != 'https:') {\n      this.el.text('Your connection is not secure!')\n    } else {\n      // Only show the form over HTTPS.\n      sup(this, arguments)\n    }\n  })\n\n  // This is not Sqimitive-way: it's long-winded, overrides whatever is already\n  // defined as render() including all event listeners (if 'render' is an event\n  // slot, see #evtconc) and hardcodes parent class name and return value...\n  // but if you don't mind that - use it, Sqimitive doesn't care.\n  sqim.render = function () {\n    if (location.protocol != 'https:') {\n      this.el.text('Your connection is not secure!')\n      return this\n    } else {\n      return MyFormView.render.apply(this, arguments)\n    }\n  }\n`]\n\n\n","start":{"line":650,"column":-1,"offset":29283},"end":{"line":1129,"column":-1,"offset":50807},"forced":null,"modifiers":[],"file":"HELP.chem"},"798":{"type":"page","id":798,"name":"ex","comment":"`! +pg=ex\n\n`# Examples, tips & tricks\n\nThis section is a collection of practical snippets and recipes demonstrating how Sqimitive addresses real-world, day-to-day problems.\n\n`## Figuring \"class name\"\n\nWith its concept of \"functions as first-class citizens\", JavaScript lacks any kind of \"class name\" references in instantiated objects. The best we can afford is duck-typing: if we see an object X having properties Y and Z the we `*suspect`* it's that kind of object (i.e. of that \"class\").\n\nQuite often, while debugging we need to figure what's the object we see, `*reliably`*. If your app has all Sqimitive classes defined under a certain object (like `'window - which is a bad practice - or `[window.MyApp`]) you can go through all prototypes on start-up and add some property, let's say \"sqClassName\", holding string reference to that prototype, like `[MyApp.Collections.FooBar`].\n\nFirst, let's override `@Core::extend()`@ with our own version that will mark each produced prototype so we know we're looking at something we have created:\n\n`[\n  var BaseSqimitive = Sqimitive.jQuery.extend()\n\n  BaseSqimitive.extend = function () {\n    var child = Sqimitive.jQuery.extend.apply(this, arguments)\n    // If you're strictly ES6+ then use Symbols.\n    child.sqIsClass = true\n\n    // If your classes are defined like AppRoot, AppRoot.View, AppRoot.View.Cart\n    // the following code will skip subclasses when extending a class:\n    //   AppRoot.OtherBaseView = AppRoot.View.extend()\n    // Without it OtherBaseView would get AppRoot.View.Cart as OtherBaseView.Cart.\n    for (var prop in this) {\n      if (/^[A-Z]/.test(prop) && typeof this[prop] == 'function' && this[prop].sqIsClass) {\n        delete child[prop]\n      }\n    }\n\n    return child\n  }\n`]\n\nNow on start-up we can go through all classes and add `'sqClassName like `[View.Cart`]:\n\n`[\n  // Define classes above or wrap the following into $().\n  ;(function (cls, prefix) {\n    for (var key in cls) {\n      var member = cls[key]\n      if (/[A-Z]/.test(key[0]) && typeof member == 'function' && member.sqIsClass) {\n        member.prototype.sqClassName = prefix + key\n        arguments.callee(member, prefix + key + '.')\n      }\n    }\n  })(window.MyAppRoot, '')\n  // Replace MyAppRoot reference with your root.\n`]\n\nHere's an example of what you get:\n\n`* `*`[MyAppRoot.BaseView`]`*`[.sqClassName = 'BaseView'`]\n`* `*`[MyAppRoot.BaseView.SubView`]`*`[.sqClassName = 'BaseView.SubView'`]\n`* `*`[MyAppRoot.BaseModel`]`*`[.sqClassName = 'BaseModel'`]\n\nThis technique allows attaching custom info to every class (prototype) but is fairly slow to enable in production. It's recommended that you pass your \"class name\" (or other string) directly to `@Core::extend()`@ - it's zero-overhead and will appear in debugger too:\n`[\n  MyAppRoot.BaseView.SubView = MyAppRoot.BaseView.extend('BaseView.SubView', {\n    // ...\n  })\n\n  // MyAppRoot.BaseView.SubView is a constructor, i.e. a function, and so has a\n  // name property:\n  MyAppRoot.BaseView.SubView.name     //=> 'BaseView.SubView'\n    // some browsers even show the function's name when you hover or print such\n    // an object\n\n  var sqim = new MyAppRoot.BaseView.SubView\n  sqim.constructor.name               //=> 'BaseView.SubView'\n`]\n\n`## Countdown class\n\nSometimes you get a number of actions to be completed before performing a specific task. For example, you need to preload a bunch of images and work on them once they are all ready. You can use native `'Promise objects or their \"fractal\" form (`@Sqimitive\\Async`@), or you can write a simple class for counter-based synchronization:\n\n`[\n  // We need no associated el object so we extend Base and don't depend on\n  // jQuery.\n  var Countdown = Sqimitive.Base.extend('Countdown', {\n    _opt: {\n      count: 0,\n      cx: null,\n    },\n\n    events: {\n      init: function (opt, onDone) {\n        // This way dec() and inc() calls will always happen on this object\n        // instance.\n        _.bindAll(this, 'dec', 'inc')\n        onDone && (this.done = onDone)\n      },\n    },\n\n    done: Sqimitive.Base.stub,\n    error: Sqimitive.Base.stub,\n\n    dec: function () {\n      if (--this._opt.count == 0) {\n        this.done.call(this.get('cx') || this)\n      } else if (this._opt.count < 0) {\n        console && console.warn('Countdown below zero.')\n      }\n\n      return this\n    },\n\n    inc: function () {\n      ++this._opt.count\n      return this\n    },\n  })\n`]\n\nIts usage is straightforward:\n\n`[\n  var images = ['pic1.jpg', 'pic2.jpg']\n\n  var countdown = new Countdown({count: images.length}, function () {\n    // Executed when all images have been loaded.\n  });\n\n  // Start loading images.\n  _.each(images, function (path) {\n    var img = new Image\n    // dec() is bound to the instance so can be called with an arbitrary\n    // context.\n    img.onload = countdown.dec\n    img.src = path\n  })\n`]\n\n`## Activity pipeline class\n\nAt other times, you might need complex synchronization, like `@Sqimitive\\Async`@ or Promises but with multiple stages that should be easy to override, e.g. in a subclass or by outside listeners.\n\nFor example, imagine a `'Page class. Its objects occupy all available window space and when switched from one to another must perform a visual effect (e.g. slide or fade). Effect can be changed in specific `'Page subclass, there are various actions to perform when it's done (e.g. freeing of data), and there are also conditions when pages should not be changed - e.g. when it's busy or asking for confirmation. And it must be singular - we don't want effects or other phases overlap.\n\nBelow is a helper class that represents a pipeline of actions: the process begins with `'prereq(), proceeds to `'passthru(), then to `'transition() and finishes with `'done(). If the action has been stopped then `'cancel() occurs at any point. They are all methods but can be turned into events by overriding them with `#on() according to Sqimitive's event model (`#evt).\n\nAn instance of this class can have only one stage active at a given time and so it ignores multiple `'start() calls until `'done() or `'cancel() are reached. `'done callbacks given during a single run are retained and called upon completion.\n\n`[\n  var Activity = Sqimitive.Base.extend('Activity', {\n    _done: [],\n\n    _opt: {\n      cx: null,\n      active: false,\n    },\n\n    // (1) Proceed to 'passthru' if the activity can be performed (e.g. if\n    // popup window can be closed without explicit user choice), otherwise\n    // proceed to 'cancel'.\n    prereq: function () {\n      this.passthru()\n    },\n\n    // (2) Proceed to 'transition' if need to perform any action (e.g. if a\n    // window is visible, not hidden) or to 'done'.\n    passthru: function () {\n      this.transition()\n    },\n\n    // (3) Proceed to 'done' when all actions are finished.\n    transition: function () {\n      this.done()\n    },\n\n    // (4) Invokes all pending callbacks.\n    done: function () {\n      var funcs = this._done.splice(0)\n      this.set('active', false)\n      this._invoke(funcs)\n    },\n\n    // (2) Remove all on-done callbacks (not possible to perform the activity).\n    cancel: function () {\n      this._done = []\n      this.set('active', false)\n    },\n\n    _invoke: function (list) {\n      _.each(list, function (item) {\n        try {\n          item[0].call(item[1])\n        } catch (e) {\n          console && console.error('Activity callback exception: ' + e)\n        }\n      })\n    },\n\n    // If currently active func will be called upon completion. If not active\n    // the activity will be started and func called when it's done.\n    start: function (func, cx) {\n      func && this.enqueue(func, cx, true)\n      this.ifSet('active', true) && this.prereq()\n      return this\n    },\n\n    // Unlike start() doesn't run the activity but instead calls func if it's\n    // currently active or calls func right away if not, without starting up.\n    enqueue: function (func, cx, always) {\n      cx = cx || this.get('cx') || this\n      ;(always || this.get('active')) ? this._done.push([func, cx]) : func.call(cx)\n      return this\n    },\n  })\n`]\n\nWhen you want to start running a new activity use `'start() with an optional callback:\n\n`[\n  var MyPage = Sqimitive.jQuery.extend({\n    _activity: null,\n\n    elEvents: {\n      'click .close': function () {\n        this._activity.start(function () {\n          alert('Completely went away...')\n        })\n      },\n    },\n\n    events: {\n      init: function () {\n        this._activity = new Activity({\n          cx: this,\n        })\n\n        // You don't have to implement every method down here, this is just an\n        // example.\n        this._activity.on({\n          passthru: function () {\n            if (this.el(':visible')) {\n              this.transition()\n            } else {\n              this.done()\n            }\n          },\n\n          transition: function () {\n            // Since Activity's event handlers are called with the Activity's\n            // context we can use this.get('cx') to access this page instance.\n            this.get('cx').el.fadeOut(_.bind(this.done, this))\n          },\n\n          done: function () {\n            this.get('cx').remove()\n          },\n        })\n      },\n    },\n  })\n\n  var MyAskingPage = MyPage.extend({\n    events: {\n      init: function () {\n        this._activity.on('prereq', function () {\n          if (confirm('Really close this page?')) {\n            this.passthru()\n          } else {\n            this.cancel()\n          }\n        })\n      },\n    },\n  })\n`]\n\nWhen you want to have your callback fired right away without starting the activity and postpone it if it is active - use `'enqueue():\n\n`[\n  this._activity.enqueue(function () {\n    // At this point it's guaranteed that the activity is no more/was not\n    // running.\n  })\n`]\n\n\n","start":{"line":1130,"column":-1,"offset":50807},"end":{"line":1412,"column":-1,"offset":60580},"forced":null,"modifiers":[],"file":"HELP.chem"},"799":{"type":"page","id":799,"name":"util","comment":"`! +pg=util +pgo=-1\n\n`# Utility methods\n\n`##+tag_Utilities\n`* Underscore.js: `#util\n\n`##\n\nEach Sqimitive instance inherits a bunch of functions from your utility library in addition to standard ones (`#tag_Utilities) - those used to sort, filter, transform, count, locate, cook, boil, slice up and serve `#nest'ed children as regular objects and arrays. For example: `[\n  sqim.filter(child => child.get('enabled'))\n  // Instead of:\n  _.filter(sqim.slice(), child => child.get('enabled'))\n`]\n\nThese functions are generally portable but with subtle differences in availability and behaviour between NoDash `@no@`@, Underscore `@un:`@ and LoDash - check the `@no@COMPATIBILITY`@ table for details.\n\n  For portability avoid using shortcut iterator syntax - it's only supported in Underscore (`@un:iteratee`@), not in NoDash, LoDash or in standard `'Array/`'Object methods. Notable exceptions are `'pick()/`'omit(): in Underscore and NoDash the iterator may be a function or a list of property names, in LoDash - list only.\n\nIf doing several transformations one after another consider `#_() which allows chaining.\n\n`#-unordered\n`* `'each(), `'filter(), etc. can iterate in any order\n`* `'find(), `'first(), etc. can return an arbitrary child\n`* `'indexOf(), etc. may change result on each call\n`* `'reduceRight() may not fold from the end\n\nFor this reason some methods are only available when mixing-in `@Sqimitive\\Ordered`@ which guarantees iteration order.\n\nThe `'iterator argument may be followed by call context (`'cx) which defaults to the sqimitive if omitted.\n\n`## Methods working with children keys (`#nested())\n`[\n  iterator = function (Sqimitive child, string parentKey)\n`]\nExample: `[sqim.keys()`] -> `[_.keys(sqim.nested())`].\n\nMethods available for `@Sqimitive\\Base`@ subclasses:\n\n`* `@no@keys`@`[()`] - returns an array of all children keys (of `#_parentKey-s if `#_owning)\n`* `@no@omit`@`[(keys | key[, key, ...] | iterator[, cx])`] - the opposite of `'pick(), children with mismatching keys\n`* `@no@pick`@`[(keys | key[, key, ...] | iterator[, cx])`] - returns object of children with matching keys: `[\n      sqim.pick(['k1', 'k2'])   //=> {k1: child1, k2: child2}\n      sqim.pick('k1', 'k2')\n      sqim.pick(child => child.get('enabled'))\n   `]\n\n   The `'iterator form is similar to `'filter() but returns `[{key: child, ...}`], not `[[child, ...]`].\n\n   Warning: keys are always strings (see `@Base.nestEx()`@). `[sqim.pick(1)`] always returns `[[]`] - use `[sqim.pick('1')`].\n\n`## Methods working on children positions (`#slice())\n`[\n  iterator = function (Sqimitive child, int index)\n`]\nExample: `[sqim.sample()`] -> `[_.sample(sqim.slice())`].\n\n`#-unordered\nIf `@Sqimitive\\Ordered`@ is not used, `'index is an arbitrary number sequential in this particular call to the utility method; `[sqim.filter((c, i) => sqim.slice(i, 1))`] may produce undefined behaviour. For `#Ordered, `'index is stable and can be given to `#at() or `#slice().\n\nAttention: `'forEach() and other methods here work with child indexes, not keys! Obtain keys by `#_parentKey if the collection is `#_owning, or by `#findKey(), or do `[_.each(col.nested(), (sqim, key) => ...)`]. For `#Ordered, can also use `[at(index).key`].\n\nMethods available for `@Sqimitive\\Base`@ subclasses:\n\n`* `@no@chunk`@`[(length)`] - returns an array of arrays of `'length members each (except last): `[[child1, child2], [child3, child4], [child5]`]\n`* `@no@includes`@`[(sqim)`] - returns `'true if there's a nested `'sqim instance (similar to `#nested())\n`* `@no@countBy`@`[(iterator[, cx])`] - same as `'groupBy() but values are group lengths: `[{group1: 3, group2: 1, ...}`]\n`* `@no@difference`@`[(array[, array, ...])`] - same as `'without() but accepts one or more arrays\n`* `@no@forEach`@`[(iterator[, cx])`] - calls `'iterator on every child; returns nothing; alias: `'each()\n`* `@no@every`@`[(predicate[, cx])`] - returns `'true if for every child `'predicate returned a truthy value\n`* `@no@filter`@`[(predicate[, cx])`] - returns array of children for which `'predicate returned a truthy value; see `'pick() which returns an object\n`* `@no@find`@`[(predicate[, cx])`] - returns the first child for which `'predicate returned a truthy value or `'undefined\n`* `@no@groupBy`@`[(iterator[, cx])`] - returns an object with arrays of children for which `'iterator returned the same string (the object's keys are those strings): `[{group1: [child1, child3], group2: [...]}`]\n`* `@no@indexBy`@`[(iterator[, cx])`] - same as `'groupBy() but expects strings to be unique; returns `[{group1: child1, group2: child2, ...}`]; warning: missing from LoDash\n`* `@no@intersection`@`[(array[, array, ...])`] - returns an array of children listed in any of the given arrays\n`* `@no@invoke`@`[(method[, arg1, arg2, ...])`] - calls `'method of each child, giving it the passed `[arg`]uments; returns an array with results of every call; see `'map() which calls an iterator instead; warning: LoDash's works differently, do not use\n`* `@no@map`@`[(iterator[, cx])`] - returns an array with results of calling `'iterator for every child; similar to `'invoke() but doesn't call children's methods\n`* `@no@max`@`[(iterator[, cx])`] - ranks all children by calling `'iterator and returns the \"highest\" one\n`* `@no@min`@`[(iterator[, cx])`] - same as `'max() but returns the \"lowest\" child\n`* `@no@partition`@`[(predicate)`] - returns an array of two arrays: first with children matching `'predicate, second - not matching\n`* `@no@pluck`@`[(prop)`] - returns array of values of the `'prop property of every child; warning: missing from LoDash\n\n   `'pluck() is hardly useful in Sqimitive since public properties are usually within `@Base._opt`@ and picking protected \"_properties\" has limited utility. Use `'map() in combination with `#picker() or `'invoke() with `#get(): `[\n     col.map(Sqimitive.Core.picker('get', 'opt'))   // map() + picker()\n     col.invoke('get', 'opt')                       // invoke() + get()\n   `]\n\n`* `@no@reduce`@`[(iterator, memo[, cx])`] - calls `[iterator(memo, sqim, parentKey)`] for every child (returns new `'memo) and returns the final value of `'memo\n`* `@no@reject`@`[(predicate[, cx])`] - the opposite of `'filter(), returns array of children mismatching `'predicate\n`* `@no@sample`@`[([n])`] - returns one random child (if no arguments) or `'n random children (or less if have fewer); alias of `'shuffle()\n`* `@no@shuffle`@`[()`] - returns array of children in random order\n`* `@no@some`@`[(predicate[, cx])`] - returns `'true if `'predicate returned a truthy value for any child\n`* `@no@sortBy`@`[(iterator[, cx])`] - returns array of children sorted by their rank determined by `'iterator (ascending)\n`* `@no@toArray`@`[()`] - simply returns array of all children; same as `#slice() and `@no@values`@() (not exposed as a method)\n`* `@no@union`@`[(array[, array, ...])`] - returns array of children plus members of all given arrays\n`* `@no@without`@`[(sqim[, sqim, ...])`] - returns array of children omitting those given as arguments; same as `'difference() but takes objects\n\nMethods available if mixed-in `@Sqimitive\\Ordered`@:\n\n`* `@no@findIndex`@`[(predicate[, cx])`] - returns index of the first child for which `'predicate returns a truthy value or `[-1`]; similar to `'indexOf() but takes a callback\n`* `@un:findLastIndex`@`[(predicate[, cx])`] - same as `'findIndex() but returns index of the last child; only useful for non-`#_owning (see `'lastIndexOf()); warning: missing from NoDash\n`* `@no@first`@`[()`] - returns first nested child or `'undefined\n`* `@no@indexOf`@`[(sqim)`] - returns the ordinal number of `'sqim or `[-1`] if it's not nested\n`* `@no@initial`@`[([n])`] - returns all but last `'n children (`[1`] if no arguments)\n`* `@no@last`@`[()`] - returns last nested child or `'undefined\n`* `@no@lastIndexOf`@`[(sqim)`] - same as `'indexOf() but counts from the end; only useful for non-`#_owning that may have duplicate children, else `'lastIndexOf() is the same as `'indexOf()\n`* `@no@reduceRight`@`[(iterator, memo[, cx])`] - same as `'reduce() but goes from the end\n`* `@no@rest`@`[([n])`] - returns all but first `'n children (`[1`] if no arguments)\n","start":{"line":1413,"column":-1,"offset":60580},"end":{"line":1522,"column":-1,"offset":68744},"forced":null,"modifiers":[],"file":"HELP.chem"},"877":{"type":"anchor","id":877,"name":"completeDesc","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"async.js"},"878":{"type":"anchor","id":878,"name":"sec","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"async.js"},"824":{"type":"class","id":824,"name":"Sqimitive.Async","comment":"! +ig +cl=Sqimitive.Async:Sqimitive.Base\n Asynchronous operation manager - a \"promise\" on steroids, with intuitive\n grouped handling of a large number of asynchronous processes.\n\n ` `#Async is \"native\" Sqimitive's re-implementation of JavaScript's\n `'Promise. It provides a unified wrapper around asynchronous operations\n such as remote requests. Unlike `'Promise, `#Async may contain `#nest'ed\n operations (the parent only completes when all children complete,\n recursively), allows the usual (`#evt) event listeners and can be\n `#abort()'ed.\n\n ` `#Async's state is stored in the `'status `#_opt'ion (`'true when\n succeeded, `'false if failed, `'null if still incomplete). On change,\n `#Async fires `#success or `#error and, always, `#complete:\n* Listeners can be prioritized relative to others (see `#MAX_PRIORITY).\n* `#exception-s during an event handler do not mark `#Async as failed\n  (unlike with `'Promise).\n* If `'status changes during `#error or `#success then remaining handlers\n  are skipped and handlers of the new `'status (`#success or `#error) are\n  called. `#complete is always triggered in the end, once `'status stops\n  changing.\n\n  `[\n    var async = new Sqimitive.Async\n\n    async.whenSuccess(function () {\n      if (Math.random() > 0.5) { async.set('status', false) }\n    }, this, -1)\n\n    // This one will run after the previous handler where we've given a\n    // smaller priority (-1):\n    async.whenSuccess(function () {\n      alert('You win!')\n    })\n\n    async.whenError(function () {\n      alert('No luck :<')\n    })\n\n    async.set('status', true)\n      // will show either of the alert messages\n  `]\n\n Attention: `@Base.nest()`@ returns new child, not the parent. The following\n creates an `'Async containing an `'Async which in turn has another `'Async\n inside, to which `#whenSuccess() is attached:\n[\n   ;(new Sqimitive.Async)\n     .nest(new Sqimitive.Async)\n     .nest(new Sqimitive.Async)\n     .whenSuccess(...)\n]\n This most likely indicates an error and should be rewritten like so:\n[\n   var container = new Sqimitive.Async)\n   container.nest(new Sqimitive.Async)\n   container.nest(new Sqimitive.Async)\n   container.whenSuccess(...)\n]\n Nesting like that can be shortened if `[Sqimitive.Async`] is the default\n class (`@Base._childClass`@) for `'container (as it is by default):\n[\n   container.nest({})\n]\n\n Other notes:\n* Child `#Async-s may be `#nest'ed at any time and their `'status may be any\n  (loading, failed or succeeded) - the parent's `'status will be updated\n  accordingly and `#success/`#error/`#complete may arise on it.\n* These three events are first fired on the `#Async itself (distance 0),\n  then on its immediate parent (1), then on that parent's parent (2) and so\n  on. In case of multiple parents of the same distance (one\n  `@Base._owning`@, others not), events first occur on the one that had the\n  child nested first, then second and so on.\n* The operation may start at any time: usually from `@Base.init()`@ if\n  you're subclassing `#Async, or by a method like `'start() called from the\n  outside, or for \"ad-hoc\" `#Async-s - some time after `'new.\n\n? A subclass that wraps around JavaScript's `'Image (representing the\n  `[<img>`] tag) for preloading graphical resources.\n  `[\n   var AsyncImage = Sqimitive.Async.extend({\n     _opt: {\n       src: null,   // relative to current location\n       img: null,   // JavaScript's Image\n     },\n\n     events: {\n       init: function () {\n         var img = new Image\n         img.onload  = () => this.set('status', true)\n         img.onerror = () => this.set('status', false)\n         this.set('img', img)\n         img.src = this.get('src')\n       },\n\n       // Stops image loading (if supported by the browser).\n       abort: function () {\n         this.img() && (this.img().src = 'javascript:void 0')\n       },\n     },\n\n     img: function () {\n       return this.get('img')\n     },\n\n     width: function () {\n       return this.img() && this.img().width\n     },\n\n     height: function () {\n       return this.img() && this.img().height\n     },\n   })\n  `]\n  Using `'AsyncImage to load a single image:\n  `[\n    ;(new AsyncImage({src: 'pic.jpg'})\n      .whenSuccess(async => alert(async.width()))\n\n    // Similar to:\n    var img = new Image\n    img.src = 'pic.jpg'\n    img.onload = () => alert(img.width)\n  `]\n  Loading multiple `'AsyncImage-s:\n  `[\n    var container = new Sqimitive.Async\n    container.nest(new AsyncImage({src: 'foo.png'}))\n    container.nest(new AsyncImage({src: 'bar.bmp'}))\n    container.whenSuccess(function () {\n      alert('Loaded ' + container.invoke('get', 'src').join())\n    })\n    container.whenError(function () {\n      // Since Async is the usual Sqimitive.Base, we have all the utility\n      // methods:\n      var failed = this.reject(a => a.isSuccessful())\n      alert('Failed to load: ' + failed.map(a => a.get('src')).join())\n    })\n  `]\n  The above `'container in turn could be part of another `#Async:\n  `[\n    var resourcePreloader = new Sqimitive.Async\n    resourcePreloader.nest(imagePreloader)\n    resourcePreloader.nest(dataPreloader)\n    resourcePreloader.whenSuccess(() => game.start())\n  `]\n  ...With `'dataPreloader defined \"ad-hoc\" (without a specialized class):\n  `[\n    var dataPreloader = new Sqimitive.Async\n\n    $.loadJSON('map.json', function (data) {\n      dataPreloader.set('data', data)\n      dataPreloader.set('status', true)\n    })\n\n    dataPreloader.whenSuccess(function () {\n      var data = dataPreloader.get('data')\n      // ...\n    })\n  `]\n\n# Event order and nesting\n Often you want to call `[when...()`] on a child being `'nest()'ed, such as\n when wrapping an `#Async. In this example API calls are delayed but the\n caller receives an `#Async immediately. It might be tempting to write\n something like this:\n[\n    var queue = []\n    var timer\n\n    function callAPI(args) {\n      var result = new Sqimitive.Async\n      queue.push([args, result])\n\n      timer = timer || setTimeout(function () {\n        timer = null\n\n        for (var task; task = queue.shift(); ) {\n          task[1].nest(_callAPI(task[0]))\n            .whenSuccess(function () { task[1].result = this.result })\n        }\n      }, 100)\n\n      return result\n    }\n\n    function _callAPI(args) {\n      var internal = new Sqimitive.Async\n      _.ajax({\n        url: '/api',\n        data: _.toArray(args),\n        success: function (xhr) {\n          internal.result = xhr.response\n          internal.set('status', true)\n        },\n      })\n      return internal\n    }\n]\n The `#Async returned to the caller is nested an internal `#Async object\n returned by `'_callAPI(); when the latter succeeds or fails, the caller's\n `#Async automatically finishes and `'callAPI() copies response data\n (`'result) to the wrapper - but running into the same pitfall described in\n `#_opt.`'ignoreError, namely that `'whenSuccess() is called after nesting,\n allowing the caller's hooks to execute first.\n[\n    // wrapper is the result Async in callAPI().\n    var wrapper = callAPI('foo')\n    wrapper.whenSuccess(function () { console.log(this.result) })\n      // logs undefined because wrapper succeeds (internal Async is nested)\n      // before callAPI()'s whenSuccess() runs\n]","start":{"line":42,"column":2,"offset":1447},"end":{"line":791,"column":2,"offset":29866},"forced":true,"modifiers":[],"file":"async.js"},"825":{"type":"const","id":825,"name":"MAX_PRIORITY","comment":" The maximum number (absolute, i.e. positive) accepted by `#whenComplete()\n and others; out of range priority is clamped to the nearest value.\n\n? Use `'-Infinity and `'Infinity to specify minimum and maximum priority.\n  `[\n   // This function is called before listeners to 'success' with a larger\n   // priority (which is 0 by default).\n   async.whenSuccess(function (async) { ... }, this, -Infinity)\n  `]","start":{"line":265,"column":4,"offset":10003},"end":null,"forced":null,"modifiers":[],"file":"async.js"},"828":{"type":"var","id":828,"name":"_opt","comment":" New standard options (`@Base._opt`@):\n> status operation null not started or not finished`,\n  true operation succeeded`, false operation failed\n  `- reflects both this instance's own status and status of its children\n\n  When an operation wrapped by this `#Async finishes and assuming it has\n  no `#_children, `#set() `'status to either `'true (`#isSuccessful) or\n  `'false. This instance will stop being `#isLoading(); this should be a\n  permanent condition - don't change `'status once it's becomes\n  non-`'null, until you call `#clear().\n\n> ignoreError bool `- if set, this instance will be considered succeeded\n  by `#isSuccessful() even if `'status is `'false\n\n  Don't change this value when this instance is no longer `#isLoading()\n  because the expected handlers won't be called:\n  `[\n    async.set('status', false)\n    async.whenSuccess(...)\n    async.set('ignoreError', true)\n      // whenSuccess' func is not executed despire isSuccessful()\n      // returning true\n\n    // Best practice is to give ignoreError to the constructor:\n    var async = new Sqimitive.Async({ignoreError: true})\n    // ...or to extend():\n    var MyAsync = Sqimitive.Async.extend({\n      _opt: {ignoreError: true},\n    })\n  `]\n\n  Remember that nesting an already failed `#Async fails the parent\n  immediately if there are no other `#isLoading children or if\n  `'immediateError is set. Change `'ignoreError before nesting:\n  `[\n    var parent = new Sqimitive.Async\n    parent.nest( new Sqimitive.Async({status: false}) )\n      .set('ignoreError', true)\n    // parent is !isSuccessful().\n    parent.nest( (new Sqimitive.Async({status: false}))\n      .set('ignoreError', true) )\n    // parent is isSuccessful(); observe the braces.\n  `]\n\n> immediateError bool `- if set, this instance will be considered failed\n  as soon as any child fails, even if there is an `#isLoading() child\n\n  This value affects the next child status check so it's best changed when\n  there are no children.\n\n  The default (disabled) is safe because it ensures completion of all\n  children before completing the parent, avoiding any orphan processes.\n  But it is often wasteful to wait when you already know the process in\n  general has failed. Enabling `'immediateError helps but it becomes your\n  job to `#abort() or `#clear() all sub-tasks, and to ignore or otherwise\n  handle events fired on sub-tasks after completion of the parent with\n  `'immediateError.\n\n  `[\n    var parent = new Sqimitive.Async\n    parent.whenError(func)\n    var loading = parent.nest(new Sqimitive.Async)\n      // parent.isLoading() == true\n    loading.whenComplete(func2)\n    parent.nest(new Sqimitive.Async({status: false}))\n      // parent.isLoading() == true\n    loading.set('status', true)\n      // func2, then func called; loading.isLoading() == false\n\n    var parent = new Sqimitive.Async({immediateError: true})\n    parent.whenError(func)\n    var loading = parent.nest(new Sqimitive.Async)\n      // parent.isLoading() == true\n    loading.whenComplete(func2)\n    loading.on('abort', () => loading.set('status', false))\n    parent.nest(new Sqimitive.Async({status: false}))\n      // func called; loading.isLoading() == true\n    parent.clear()\n      // func2 called; loading.isLoading() == false\n  `]","start":{"line":350,"column":4,"offset":13817},"end":{"line":354,"column":4,"offset":13904},"forced":null,"modifiers":["protected"],"file":"async.js"},"834":{"type":"func","id":834,"name":"toString","comment":"! +fn=toString\n Returns a debugger-friendly summary of this object:\n[\n   The.Class.Name [length] ~ STATUS\n]\n   `&sup1 `'~ is output if the `'ignoreError `#_opt is set.\n\n   `&sup2 `[STATUS`] is either \"LOADING\", \"DONE\" or \"ERROR\"\n\n For example:\n[\n   AsyncImage [2]  DONE\n]","start":{"line":396,"column":6,"offset":15692},"end":{"line":408,"column":6,"offset":16060},"forced":true,"modifiers":[],"file":"async.js"},"839":{"type":"func","id":839,"name":"whenComplete","comment":" Fire `'func whenever this instance stops being `#isLoading() - see\n `#complete.\n\n?`[\n   $('#spinner').show()\n   var async = new MyAsync({...})\n   async.whenComplete(function (async) {\n     $('#spinner').hide()\n   })\n\n   // As if:\n   $('#spinner').show()\n   try {\n     do_async()\n   } finally {\n     $('#spinner').hide()\n   }\n `]\n\n#completeDesc\n= this\n\n Unlike with a simple `[on('event')`] (`#on()) `'func gets called\n immediately if the condition is already met (then `'priority is ignored).\n Otherwise, `'func is executed before all handlers registered with a\n larger `'priority, among (in any order) those with the same and after\n those with a lower. The value is clamped to the `#MAX_PRIORITY range. In\n any case, `'func is given `'this (the `#Async instance).\n\n Warning: the following is incorrect use because `'func may be called\n immediately, before the result is assigned to `'req:\n[\n   var req = (new Sqimitive.Async).whenComplete(function () {\n     // WRONG: req may be undefined:\n     req.foo()\n   })\n\n   // CORRECT: assign to the variable first:\n   var req = new Sqimitive.Async\n   req.whenComplete(function () { ... })\n\n   // CORRECT: or use the passed \"this\":\n   ;(new Sqimitive.Async)\n     .whenComplete(function (req) { ... })\n]","start":{"line":541,"column":4,"offset":20709},"end":{"line":543,"column":4,"offset":20834},"forced":null,"modifiers":[],"file":"async.js"},"840":{"type":"func","id":840,"name":"whenError","comment":" Fire `'func whenever this instance's operation has failed - see `#error.\n\n?`[\n   async.whenError(function (async) {\n     alert(\"Met an error :'(\")\n   })\n `]\n\n#-completeDesc","start":{"line":554,"column":4,"offset":21070},"end":{"line":556,"column":4,"offset":21200},"forced":null,"modifiers":[],"file":"async.js"},"841":{"type":"func","id":841,"name":"whenSuccess","comment":" Fire `'func whenever this instance's operation has succeeded - see\n `#success.\n\n?`[\n   async.whenSuccess(app.start)\n `]\n\n#-completeDesc","start":{"line":566,"column":4,"offset":21393},"end":{"line":568,"column":4,"offset":21526},"forced":null,"modifiers":[],"file":"async.js"},"842":{"type":"func","id":842,"name":"doneIfEmpty","comment":" Sets the `'status `#_opt to `'true if have no `#_children and is still\n `#isLoading().\n\n= undefined if not empty or is not loading`, true\n\n?`[\n   _.each(filesToLoad, function (url) {\n     async.nest(new MyAsync({src: url}))\n   })\n\n   async.whenComplete(allLoaded)\n\n   async.doneIfEmpty()\n     //=> true\n     // if there were no filesToLoad then mark async as complete right\n     // away\n\n   async.doneIfEmpty()\n     //=> undefined - already complete, call ignored\n `]","start":{"line":590,"column":4,"offset":22123},"end":{"line":595,"column":4,"offset":22261},"forced":null,"modifiers":[],"file":"async.js"},"843":{"type":"func","id":843,"name":"clear","comment":" Prepares this instance for new use.\n\n It's recommended to create a new `#Async instance for every new batch of\n tasks to avoid induced effects. However, `#clear() may improve\n performance when thousands of objects need to be created but some could\n be reused. `#clear() can be also seen as \"hard\" `#abort().\n\n Removes event listeners for `#success/`#error/`#complete (but not for\n `#exception), calls `#abort() on self and on `#_children (recursively),\n calls `@Base.remove()`@ on children if `#_owning or `#unlist() if not,\n and sets `'status (`#_opt) to `'null (`#isLoading()).","start":{"line":608,"column":4,"offset":22916},"end":{"line":614,"column":4,"offset":23143},"forced":null,"modifiers":[],"file":"async.js"},"844":{"type":"func","id":844,"name":"nestDoner","comment":" Nests a new child and returns a function that sets the child's `'status\n to `'true.\n\n The returned function has an `'error method that sets the child's\n `'status to `'false.\n\n? Use `#nestDoner() to interface with callback-style functions:\n  `[\n  $('div').fadeOut(async.nestDoner())\n\n  var done = async.nestDoner()\n  fs.appendFile('foo.txt', 'Hello World!', function (err) {\n    err ? done.error() : done()\n  })\n\n  async.whenSuccess(function () {\n    var $ = require('jquery')\n    // ...\n  })\n  var done = async.nestDoner()\n  require(['jquery'], done, done.error)\n  `]\n\n `'status is not changed after `#abort() was called on the child (this\n usually happens because of `'sink() or `#clear() on the parent since\n `#nestDoner() doesn't return the child it creates).","start":{"line":642,"column":4,"offset":24071},"end":{"line":650,"column":4,"offset":24368},"forced":null,"modifiers":[],"file":"async.js"},"845":{"type":"func","id":845,"name":"isSuccessful","comment":"= null when still `#isLoading()`, true if `'status `#_opt is `'true or\n  `'ignoreError `#_opt is set`, false\n\n `'ignoreError affects all methods using `#isSuccessful(), in particular\n `#whenSuccess() and `#whenError():\n[\n   async.set('status', false)   // fail it\n   async.isSuccessful()         //=> false\n   async.set('ignoreError', true)\n   async.isSuccessful()         //=> true\n   async.whenSuccess(() => alert('fired!'))\n     // alerts\n]\n\n However, changing `'ignoreError on run-time is not recommended - see\n `#_opt.","start":{"line":668,"column":4,"offset":24996},"end":{"line":671,"column":4,"offset":25126},"forced":null,"modifiers":[],"file":"async.js"},"846":{"type":"func","id":846,"name":"isLoading","comment":"= true when still loading (`'status `#_opt is `'null)`,\n  false when failed or succeeded (`#isSuccessful)","start":{"line":675,"column":4,"offset":25252},"end":{"line":677,"column":4,"offset":25321},"forced":null,"modifiers":[],"file":"async.js"},"847":{"type":"func","id":847,"name":"success","comment":"! +fn=success:this +ig\n\n Called when this instance and children have succeeded.\n\n#sec\n ` `#success, `#error and `#complete are called when this and nested\n operations have finished (resources loaded, etc.). Consider this analogy\n with exception handling:\n[\n   try {\n     ...                    // Async.success()\n   } catch (exception) {\n     ...                    // Async.error()\n   } finally {\n     ...                    // Async.complete()\n   }\n]\n\n But note that \"real\" exceptions thrown by listeners are handled by\n `#exception() outside of the normal pipeline (`#error-s are expected\n conditions, exceptions are not).\n\n Each handler is called at most once as if it was bound with `#once(). If\n a handler changes the `'status `#_opt, others are skipped and events are\n re-fired.\n\n? In most cases you need to use `#whenSuccess(), `#whenError() and\n  `#whenComplete() rather than subscribing via `#on() because if the\n  instance's status changes between its construction and your subscription\n  - your handler will not be called:\n  `[\n   var async = new MyAsync({...})\n   // If async is already complete before we call on() - our handler will\n   // not be triggered:\n   async.on('success', function (async) { ... })\n   // So you want to do this:\n   async.whenSuccess(function (async) { ... })\n  `]\n\n The call order of handlers is deterministic (`#Async's `#nest() acts as\n `#on() because of `#_childEvents/`#_forward()) but it's usually more\n convenient to use specific priority levels to not depend on the order of\n `#nest()/`#on() calls: `[on('success')`] is guaranteed to be called after\n `[success-3`] but before `[success2`].","start":{"line":679,"column":4,"offset":25329},"end":{"line":722,"column":4,"offset":27183},"forced":true,"modifiers":[],"file":"async.js"},"848":{"type":"func","id":848,"name":"error","comment":"! +fn=error:this +ig\n\n Called when this instance or one of its children has failed.\n\n By default, `#Async doesn't store any error information because it is\n operation-agnostic; you may use `#_opt for this.\n\n#-sec","start":{"line":725,"column":4,"offset":27264},"end":{"line":732,"column":4,"offset":27513},"forced":true,"modifiers":[],"file":"async.js"},"849":{"type":"func","id":849,"name":"complete","comment":"! +fn=complete:this +ig\n\n Called when this instance stops being `#isLoading().\n\n#-sec","start":{"line":735,"column":4,"offset":27558},"end":{"line":739,"column":4,"offset":27662},"forced":true,"modifiers":[],"file":"async.js"},"850":{"type":"func","id":850,"name":"exception","comment":" Called when an exception was thrown during `#success, `#error or\n `#complete.\n\n?`[\n  async.on('exception', e => console.error(e.message))\n `]\n\n In contrast with JavaScript's `'Promise an error in handling the\n \"promise\" (`#Async) doesn't mark that promise failed if its underlying\n action (e.g. an AJAX call) has succeeded.\n\n If an exception is thrown during an `#error or `#success handlers then\n remaining handlers are skipped, `#complete is triggered and the exception\n is re-thrown. An exception during `#complete also skips remaining\n handlers of `#complete and is re-thrown unless there was an exception\n during `#error or `#success.\n\n Other notes:\n* `#exception's event listeners are not affected by `#clear().\n* `#Async replaces the `#exception() handler of its children so that the\n  exception is thrown on the top-level `#Async (whose `#_parent is not\n  another `#Async).\n* The above also means that it's enough to override just the top-level\n  `#exception() to affect the entire tree.\n* The usual events have \"whenXXX()\" (`#whenComplete(), etc.) but there's\n  no \"whenException()\" because no info about already occurred errors is\n  stored (like `'status is stored in `#_opt). Only future exceptions can\n  be listened to, with the usual `#on().\n* Unlike `#success/`#error/`#complete, `#exception doesn't receive `'this\n  as an argument.\n* `#exception isn't called on request failure unless you throw an\n  exception from `#error (because `#Async doesn't know about your\n  operation's details).\n* The default implementation throws the argument.","start":{"line":776,"column":4,"offset":29468},"end":{"line":778,"column":4,"offset":29512},"forced":null,"modifiers":[],"file":"async.js"},"851":{"type":"func","id":851,"name":"abort","comment":"! +fn=abort +ig\n Aborts the operation of this instance.\n\n? `#abort() doesn't affect own `#_children - call `#sink() or `#clear() to\n  abort everything recursively:\n  `[\n     async.sink('abort')\n  `]\n\n The default implementation does nothing (is a `#stub).","start":{"line":780,"column":4,"offset":29520},"end":{"line":789,"column":4,"offset":29774},"forced":true,"modifiers":[],"file":"async.js"},"852":{"type":"class","id":852,"name":"Sqimitive.Async.Fetch","comment":"! +ig +cl=Sqimitive.Async.Fetch:Sqimitive.Async\n Wrapper around a compatible `#_opt.`'function performing a single\n asynchronous request to a remote resource.\n\n?`[\n   var async = new Sqimitive.Async.Fetch({\n     function: fetch,\n     url: '//api.moe/v1/',\n     method: 'POST',\n     body: new URLSearchParams({moe: 'please!'}),\n   })\n\n   async.whenSuccess(function () {\n     this.response.json().then(console.dir)\n   })\n `]\n\n Other notes:\n* Fetching starts as soon as `#Fetch is created (in `'init()).\n* A single instance (`'this) can be used to issue only one request.","start":{"line":793,"column":2,"offset":29872},"end":{"line":1016,"column":46,"offset":38045},"forced":true,"modifiers":[],"file":"async.js"},"853":{"type":"var","id":853,"name":"request","comment":"#-readOnly\n Available after `'init(). Result of `#_fetch(): native or wrapped\n `'XMLHttpRequest (as returned by `'ajax()) or `'Promise (`'fetch()).","start":{"line":817,"column":4,"offset":30745},"end":null,"forced":null,"modifiers":[],"file":"async.js"},"854":{"type":"var","id":854,"name":"requestError","comment":"#-readOnly\n Available once not `#isSuccessful(). For `'ajax() this is whatever was\n given to the `'error callback (may be even unset/falsy). For (`'fetch())\n this is either `'Response (request completed successfully but with HTTP\n status outside of 200-299; `[!requestError.ok`]) or `'Error (request\n didn't complete).\n\n Not to be confused with the `@Async.error`@ event/method.","start":{"line":827,"column":4,"offset":31192},"end":null,"forced":null,"modifiers":[],"file":"async.js"},"855":{"type":"var","id":855,"name":"response","comment":"#-readOnly\n Available once `#isSuccessful(). Value of `'request's `[response...`]\n property (`'ajax()) or `'Response (`'fetch()).","start":{"line":832,"column":4,"offset":31365},"end":null,"forced":null,"modifiers":[],"file":"async.js"},"856":{"type":"var","id":856,"name":"_opt","comment":"> function function`, null = `#defaultFunction `- the backend doing actual\n  fetching (e.g. `@jq:ajax`@() or browser's `'fetch())\n> * `- options given to `'function\n\n  Usually you want to set at least `'url (required by both `'ajax() and\n  `'fetch()).\n\n  `'method/`'body (`'fetch()-style) default to values of `'type/`'data\n  (`'ajax()-style).\n\n  Don't set `'context (always `'this), `'success/`'error (use\n  `#whenSuccess(), etc.), `'signal (use `#abort()).","start":{"line":850,"column":4,"offset":32012},"end":{"line":853,"column":4,"offset":32080},"forced":null,"modifiers":["protected"],"file":"async.js"},"860":{"type":"func","id":860,"name":"abort","comment":"! +fn=abort:[reason]\n Aborts the request and fails this `#Async or does nothing if not\n `#isLoading().\n> reason mixed`, omitted `- used by `'fetch(), defaults to `'AbortError\n= this","start":{"line":860,"column":6,"offset":32172},"end":{"line":864,"column":6,"offset":32379},"forced":true,"modifiers":[],"file":"async.js"},"861":{"type":"func","id":861,"name":"readyStateText","comment":" Returns a symbolic value for `#request.`'readyState if using `'ajax().\n= string like `'LOADING`, empty `'fetch() provides no such info","start":{"line":888,"column":4,"offset":33221},"end":{"line":891,"column":4,"offset":33401},"forced":null,"modifiers":[],"file":"async.js"},"871":{"type":"func","id":871,"name":"_fetch","comment":" Fires off the request using `'options. Must either set `#response or\n return its new value.\n\n Base implementation calls `#_opt.`'function or `#defaultFunction, giving\n it `'options. If result has `'then function (`'Promise), hooks it in\n order to call `'options' `'success/`'error. `'error is also called if\n `'Promise fulfills with `[Response.ok`] of `'false.\n\n? If using `'fetch(), `#request is `'Promise by default. You can replace\n  it with a more useful `'Request by changing `#_opt.`'function or\n  `#defaultFunction like so:\n  `[\n    Async.Fetch.defaultFunction = function (options) {\n      return fetch(options.context.request = new Request(options))\n    }\n  `]","start":{"line":952,"column":4,"offset":35430},"end":{"line":961,"column":4,"offset":35779},"forced":null,"modifiers":["protected"],"file":"async.js"},"873":{"type":"func","id":873,"name":"_assign","comment":" Sets `#response value based on properties of `'obj when `'this is about\n to become `#isSuccessful().\n\n Base implementation is suitable for supported `#defaultFunction-s.\n\n If overriding `#_assign(), avoid reading response data of the same\n (`'XMLHttpRequest) request multiple times because browsers parse it on\n every access. For example, 100 reads on `[xhr.response`] are 100 times\n slower than reading `[xhr.response`] once and using that copy for\n subsequent access. This is especially noticeable on huge JSONs where each\n read may take seconds.","start":{"line":974,"column":4,"offset":36403},"end":{"line":999,"column":4,"offset":37265},"forced":null,"modifiers":["protected"],"file":"async.js"},"876":{"type":"var","id":876,"name":"defaultFunction","comment":"! +prop=defaultFunction\n The function used by `#_fetch() when `#_opt.`'function is unset.\n\n Defaults to `'ajax() of the global jQuery, Zepto or `[_`] (`[nodash/extra`]\n provides `@no@Extra.ajax`@()) or the native `'fetch(), whichever is\n available (in this order). This makes `#Fetch suitable for use in a web\n browser with zero configuration. In other environments client must either\n set `#defaultFunction (provided nobody else does so and the value fits all\n other clients) or supply `#_opt.`'function to every instance of `#Fetch.\n\n Changes to `#defaultFunction take effect on next request (new `#Fetch).","start":{"line":1004,"column":2,"offset":37289},"end":{"line":1014,"column":2,"offset":37865},"forced":true,"modifiers":["static"],"file":"async.js"},"902":{"type":"anchor","id":902,"name":"jqex","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"jquery.js"},"881":{"type":"class","id":881,"name":"Sqimitive.jQuery.MixIn","comment":"! +cl=Sqimitive.jQuery.MixIn\n A `#mixIn to map Sqimitive onto a DOM representation via the jQuery\n interface.\n\n See `#jQuery for details.\n\n Use `@Sqimitive\\jQuery`@ if you just want a standard `#Base with jQuery\n features.\n\n?`[\n    var jQueryInMyClass = MyClass.extend({\n      mixIns: [Sqimitive.jQuery.MixIn]\n    })\n\n    new jQueryInMyClass({el: $('#log')})\n `]","start":{"line":41,"column":2,"offset":1442},"end":null,"forced":true,"modifiers":[],"file":"jquery.js"},"882":{"type":"class","id":882,"name":"Sqimitive.jQuery","comment":"! +cl=Sqimitive.jQuery:Sqimitive.Base:Sqimitive.jQuery.MixIn\n A Sqimitive with a DOM representation via the jQuery interface (`@jq:`@).\n\n ` `@Sqimitive\\jQuery`@ is the base class used in a typical web application.\n It turns `#el into a jQuery node, keeps it attached to `#_parent's `#el,\n maintains `#el's event listeners in DOM, etc.\n\n This class can also work with libraries imitating jQuery API like Zepto\n since this is a thin interface to jQuery and very few of its features are\n actually used.\n\n See the included sample To-Do application for a \"real-world\" example.\n\n ` `@Sqimitive\\jQuery\\MixIn`@ can be used to add this functionality into a\n sqimitive whose superclass is different from `#Base, possibly even on\n run-time.\n\n#jqex\n? `[\n     var Task = Sqimitive.jQuery.extend({\n       el: {tag: 'li'},\n\n       _opt: {\n         // Keep el appended to the parent's el.\n         attachPath: '.',\n         // Define the default attributes of Task:\n         caption: '',\n         done: false,\n       },\n\n       events: {\n         // Update the visual presentation whenever any _opt changes:\n         change: 'render',\n\n         render: function () {\n           this.el.text(this.get('caption'))\n             .toggleClass('done', this.get('done'))\n         },\n       },\n\n       elEvents: {\n         // Listen for double clicks on this.el to change the done state:\n         dblclick: function () {\n           this.set('done', !this.get('done'))\n         },\n       },\n     })\n\n     // Create a parent container for our to-do items (Task's) which\n     // is placed into the DOM at $('#tasks'):\n     var list = new Sqimitive.jQuery({el: '#tasks'})\n\n     // Create a new item, add it to list's _children:\n     list.nest( new Task({caption: 'Ready steady go!'}) )\n     // ...append to list's el and render for the first time:\n       .attach().render()\n\n     // Double click on Task's element in the window to change its\n     // className.\n  `]","start":{"line":58,"column":2,"offset":1870},"end":{"line":488,"column":83,"offset":19200},"forced":true,"modifiers":[],"file":"jquery.js"},"884":{"type":"var","id":884,"name":"$","comment":" Holds reference to the global `'$ object.\n\n[\n   var body = Sqimitive.jQuery.$('body')\n   var p = Sqimitive.jQuery.$('<p class=text>')\n]\n\n A similar global property `[Sqimitive._`] holds reference to the\n utility library in use.","start":{"line":131,"column":6,"offset":4405},"end":null,"forced":null,"modifiers":["static"],"file":"jquery.js"},"885":{"type":"func","id":885,"name":"is$","comment":" Determines if `'obj is a `'$ node (`@jq:jQuery`@ or Zepto).\n\n[\n   Sqimitive.jQuery.is$(document.rootElement)   //=> false\n   Sqimitive.jQuery.is$($('html'))    //=> true\n   Sqimitive.jQuery.is$($('<p>'))     //=> true\n   Sqimitive.jQuery.is$($())          //=> true\n   Sqimitive.jQuery.is$(null)         //=> false\n]","start":{"line":142,"column":6,"offset":4808},"end":{"line":144,"column":6,"offset":4901},"forced":null,"modifiers":["static"],"file":"jquery.js"},"886":{"type":"func","id":886,"name":"canWrap","comment":" Determines if `'obj should be wrapped in `'$ for storing as `#el.\n\n Returns `'true if `'obj is a native DOM `'Element, `'Document or\n `'Window. Returns `'false if other, including `[is$()`].\n\n[\n   Sqimitive.jQuery.canWrap(document.head)  //=> true\n   Sqimitive.jQuery.canWrap(null)           //=> false\n   Sqimitive.jQuery.is$($('<p>'))           //=> true\n   Sqimitive.jQuery.canWrap($('<p>'))       //=> false\n   _.isElement(window)                      //=> false\n   Sqimitive.jQuery.canWrap(window)         //=> true\n   Sqimitive.jQuery.canWrap(document)       //=> true\n]","start":{"line":160,"column":6,"offset":5601},"end":{"line":162,"column":6,"offset":5718},"forced":null,"modifiers":["static"],"file":"jquery.js"},"887":{"type":"var","id":887,"name":"_opt","comment":" New standard options (`@Base._opt`@):\n\n> attachPath: string selector, object DOM or jQuery `- Default root to\n  where this `#el is appended, resolved via `#_parent's `'$() or, if\n  there's no parent, via global `[$()`]. Used when `#attach() is called\n  without arguments (happens when `#_parent's `#attach() or `#render() is\n  called).\n\n  Usually the value is a string selector like `[form > .filters`] or a\n  period `'. (special case when have a `#_parent, gets its `#el).\n\n> el: false`, string`, object `- There is no such option but if `'el is\n  given to `'new as part of `'options then it replaces the\n  declaration-time value of the `#el property - see `#el for details.","start":{"line":181,"column":4,"offset":6511},"end":{"line":181,"column":11,"offset":6518},"forced":null,"modifiers":["protected"],"file":"jquery.js"},"888":{"type":"var","id":888,"name":"el","comment":"! +prop=el +ig=3\n\n#-setOnDecl\n\n Holds a DOM node assigned to this object or `'null.\n\n? `[\n     // Set this.el by selector; becomes $(document.body):\n     new Sqimitive.jQuery({el: 'body'})\n     // Set this.el to a jQuery node:\n     new Sqimitive.jQuery({el: $('body')})\n     // Set this.el by a DOM node; becomes wrapped into $() by init():\n     new Sqimitive.jQuery({el: document.body})\n     // Create new element via string specification for $():\n     new Sqimitive.jQuery({el: '<p class=text>'})\n     // Create new element <p class=\"text\"> by object:\n     new Sqimitive.jQuery({el: {tag: 'p', className: 'text'}})\n     // Cancel node creation, el becomes null:\n     new Sqimitive.jQuery({el: false})\n\n     // WRONG: when changing after construction el must always be a\n     // jQuery node, only and ever:\n     sqim.el = '<p class=text>'\n     // WRONG: result is a DOM node, not a jQuery node:\n     sqim.el = document.createElement('p')\n     // CORRECT: result is a jQuery node:\n     sqim.el = $('<p class=text>')\n  `]\n\n ` `#el's value is special during construction: first, `'init() takes the\n value of either the `'el key from `'new's `'options or, if missing, of\n this property, then sets `#el's property value according to it:\n> false `- assumes `'null `#el; no DOM node is created or assigned -\n  useful for pure data structures aka \"models\" (but then you might not\n  need `@Sqimitive\\jQuery`@ at all, use the lighter `#Base)\n> string `- a `[se #lec > .tor`] (errors if no node matched) or a `[<new\n  node=spec>`] as handled by the global `'$()\n> object that passes `[is$()`] or `#canWrap() `- assumes this ready-made\n  DOM or jQuery node\n> object other `- Creates a new DOM node with these HTML attributes and\n  calls `[el.data('sqimitive', this)`]. Special keys: `'tag (defaults to\n  `'div) and `'className (overrides `'class unless falsy to work around\n  the reserved word).\n\n  `'data() allows you to reverse-lookup a Sqimitive instance from its DOM\n  node. However, not only this is a generally deplorable practice but also\n  not supported by some builds of Zepto.\n\n In any case, `#el after `'init() is either `'null or a jQuery node with a\n non-zero `'length.\n\n ` `#el is not automatically attached anywhere after construction, nor are\n its `#elEvents bound - call `#attach() for this. `@Base.render()`@ also\n calls `#attach() but it does nothing if the `'attachPath `#_opt'ion is\n not set.\n\n This property is not advised to change directly after `'init() but if you\n do then only set it to an `[is$()`] object.\n\n See Views overview (`#vw) for the high-level idea.","start":{"line":183,"column":4,"offset":6526},"end":{"line":242,"column":4,"offset":9405},"forced":true,"modifiers":[],"file":"jquery.js"},"889":{"type":"var","id":889,"name":"_invokeAttach","comment":"#-settable\n\n Specifies if `#attach() should call `'attach() on `#_children when it\n changed the parent of `#el.\n\n According to default Sqimitive's lifecycle (see `#render), `#jQuery's\n `#attach() propagates recursively while `#render() happens only when\n explicitly called. This is because `#attach() is fairly fast and often\n nearly no-op while `#render() may repopulate the entire `#el.\n\n If your application's lifecycle is different, use `#_invokeAttach to\n disable the inherited `#attach() propagation without overriding `'=attach\n entirely.","start":{"line":258,"column":4,"offset":10125},"end":null,"forced":null,"modifiers":["protected"],"file":"jquery.js"},"890":{"type":"var","id":890,"name":"_removeEl","comment":"#-settable\n\n Specifies if `#el should be `@jq:remove`@()'d from DOM when this\n sqimitive is `#remove()'d.\n\n If disabled, `#remove() only unbinds `#elEvents and other listeners from\n `#el but doesn't notify `#_children so their nodes and listeners remain\n unchanged, nor does it `'empty() `#el's contents produced by `#render()\n or children.\n\n Use `#_removeEl when you need special behaviour in `#remove() but don't\n want to override it entirely (`'=remove) in order to keep `#jQuery's\n behaviour.","start":{"line":273,"column":4,"offset":10726},"end":null,"forced":null,"modifiers":["protected"],"file":"jquery.js"},"891":{"type":"var","id":891,"name":"elEvents","comment":"! +prop=elEvents\n\n#-baseElEvents\n\n See also the `'attachPath `#_opt.\n\n?`[\n   var MyView = Sqimitive.jQuery.extend({\n     el: {tag: 'form'},\n\n     elEvents: {\n       // Attach listener to this object's el:\n       submit: function (e) {\n         return false\n           // as with regular jQuery event handlers, returning false\n           // implies e.stopPropagation() and e.preventDefault()\n       },\n\n       // React on change originating from an element with specific name\n       // attribute:\n       'change [name=\"login\"]': function () {\n         this.$('[name=\"password\"]').val('')\n       },\n\n       // Call render() whenever value of an element with the name\n       // attribute changes:\n       'change [name]': 'render',\n\n       // Masked callback - only gives first argument to _linkClicked():\n       'click a': '_linkClicked.',\n\n       // Similar but the '.zyx' namespace creates a second handler,\n       // avoiding key collision with 'click a':\n       'click.zyx a': 'track',\n     },\n   })\n\n   var MyView2 = MyView.extend({\n     elEvents: {\n       // Overrides the '_linkClicked.' handler but keeps 'track'.\n       'click a': ...,\n     },\n   })\n `]","start":{"line":276,"column":4,"offset":10768},"end":{"line":319,"column":4,"offset":12182},"forced":true,"modifiers":[],"file":"jquery.js"},"896":{"type":"func","id":896,"name":"attach","comment":"!`,+fna=function ( [parent] )\n\n Appends `#el to a DOM node and binds `#elEvents if changed parents.\n\n> parent string selector`, object DOM or jQuery node`,\n  no argument use the `'attachPath `#_opt`, null only bind events\n\n First, unless `'parent is `'null, `#attach() resolves `'parent with\n `#_parent's `'$() or global `'$() (if no `#_parent) and, if the found\n parent is a node and `#el's current direct parent is different, calls\n `@jq:appendTo`@() on own `#el and `#attach() on all children of self to\n let them rebind their DOM listeners (but see `#_invokeAttach). Doesn't\n un-attach `#el if no parent was found. Doesn't call `#render().\n\n Second, `#attach() clears all existing `#el event listeners and binds\n those defined in `#elEvents under the `[.sqim-`] + `#_cid jQuery\n namespace (ignoring `'.ns possibly present in `#elEvents keys - that\n one is to avoid key collisions during inheritance, not for jQuery).\n This happens even if parent didn't change (above).\n\n If `#el is `'null then `#attach() does nothing.\n\n?`[\n   sqim.attach('#nav')   //= sqim.el.appendTo('#nav')\n   sqim.attach('<div>')  //= appends to a new <div> node\n   sqim.attach(null)     // re-binds elEvents only\n   sqim.attach('#unk')   // the same\n   sqim.attach()         // uses sqim._opt.attachPath, if set\n   sqim.attach(sqim.get('attachPath'))   // the same\n `]\n\n Note: if `#_parent is set then `#attach() uses its `[$()`]. Hence even\n if `'parent is a globally-reachable selector (like `[html,head,body`])\n it will never match if `#_parent's `#el is unset or if it's not a\n parent of that node. For example, `#el must be `[$('html')`] in order\n to match `'head:\n[\n  var parent = new Sqimitive.jQuery({el: 'p'})\n  var child = parent.nest(new Sqimitive.jQuery).attach('body')\n    //=> child.el.parent() is []\n]\n Work around this by setting `'attachPath or `#el to a DOM or `'$ node\n or by giving one to `'el after construction:\n[\n   var MyView = Sqimitive.jQuery.extend({\n     el: window,\n     el: document.rootElement,    // for <html>\n     el: document.head,           // for <head>\n     el: document.body,           // for <body>\n  })\n\n  // Or, on run-time by class' user:\n  new Sqimitive.jQuery({attachPath: document.rootElement})\n  new Sqimitive.jQuery({el: window})  // binds elEvents only\n  sqim.attach(document)               // binds elEvents only\n]\n Warning: `[document.body`] is not available if the current script is\n executing from `[<head>`].\n\n#-baseAttach","start":{"line":401,"column":6,"offset":15803},"end":{"line":423,"column":6,"offset":16660},"forced":null,"modifiers":[],"file":"jquery.js"},"897":{"type":"func","id":897,"name":"remove","comment":"! +fn=remove\n\n Removes own `#el from DOM and `#unnest()-s `'this from `#_parent.\n\n If `#el is set, `#remove() calls either `@jq:remove`@() to drop it from\n DOM (if `#_removeEl is set) or `@jq:off`@() to unbind all own events.\n Then the inherited `@Base.remove()`@ calls `#unnest() to remove this\n sqimitive from its `#_parent (if any).\n\n ` `#remove() doesn't recursively `#remove() all nested `#_children as\n it might be undesired and slow (in DOM removing the parent node\n automatically unbinds events of all children). If children do need to\n perform some clean-up actions when their parent is removed - call\n `[this.sink('remove')`] (`#sink() is recursive) or let them subscribe\n to `#_parent's `'remove when `#owned.\n\n#-baseRemove","start":{"line":425,"column":6,"offset":16670},"end":{"line":441,"column":6,"offset":17520},"forced":true,"modifiers":[],"file":"jquery.js"},"898":{"type":"func","id":898,"name":"$","comment":" Finds node(s) within own `#el.\n\n= object `- a `@jq:jQuery`@ node\n\n Possible `'path's:\n> object that is `[is$()`] to return the `'path itself`,\n  a DOM node (`#canWrap()) to wrap and return `[$(path)`]\n  `- returned collection may be empty or its members may be outside of\n  `[this.el`]\n> string empty or just `'. to return own `#el`,\n  selector to return `[this.el.find(path)`] - see `@jq:find`@()\n  `- if `'this.`#el is unset then always returns a jQuery node with zero\n  `'length\n\n?`[\n   this.$()                //=> $(this.el) - but better use this.el\n   this.$('')              //=> $(this.el)\n   this.$('.')             //=> $(this.el)\n   this.$('a[href]')       //=> $([A, A, ...])\n   this.$(document.body)   //=> $('body')\n   this.$($('body'))       // same\n   this.$('body')          // empty collection unless this.el is <html>\n\n   this.el = null\n   this.$('')              //=> $()\n   this.$('body')          //=> $()\n   this.$(document.body)   //=> $('body')\n `]","start":{"line":477,"column":4,"offset":18843},"end":{"line":485,"column":4,"offset":19109},"forced":null,"modifiers":[],"file":"jquery.js"},"1048":{"type":"anchor","id":1048,"name":"trc","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1049":{"type":"anchor","id":1049,"name":"mergePropsExtend","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1050":{"type":"anchor","id":1050,"name":"es6this","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1051":{"type":"anchor","id":1051,"name":"maskerPattern","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1052":{"type":"anchor","id":1052,"name":"deepclonebase","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1053":{"type":"anchor","id":1053,"name":"mixInDesc","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1054":{"type":"anchor","id":1054,"name":"mixInDoes","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1055":{"type":"anchor","id":1055,"name":"elEventsMixIn","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1056":{"type":"anchor","id":1056,"name":"fireOverride","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1057":{"type":"anchor","id":1057,"name":"fireAll","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1058":{"type":"anchor","id":1058,"name":"onOnce","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1059":{"type":"anchor","id":1059,"name":"evtref","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1060":{"type":"anchor","id":1060,"name":"evtpf","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1061":{"type":"anchor","id":1061,"name":"argDanger","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1062":{"type":"anchor","id":1062,"name":"post","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1063":{"type":"anchor","id":1063,"name":"naor","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1064":{"type":"anchor","id":1064,"name":"skb","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1065":{"type":"anchor","id":1065,"name":"parentAndKey","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1066":{"type":"anchor","id":1066,"name":"classref","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1067":{"type":"anchor","id":1067,"name":"chevaoff","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1068":{"type":"anchor","id":1068,"name":"rtobase","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1069":{"type":"anchor","id":1069,"name":"elstub","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1070":{"type":"anchor","id":1070,"name":"baseElEvents","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1071":{"type":"anchor","id":1071,"name":"initonce","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1072":{"type":"anchor","id":1072,"name":"renderAttach","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1073":{"type":"anchor","id":1073,"name":"baseAttach","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1074":{"type":"anchor","id":1074,"name":"getmul","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1075":{"type":"anchor","id":1075,"name":"normopt","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1076":{"type":"anchor","id":1076,"name":"normiseq","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1077":{"type":"anchor","id":1077,"name":"changeAndOpt","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1078":{"type":"anchor","id":1078,"name":"setoptpropag","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1079":{"type":"anchor","id":1079,"name":"ifSetSet","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1080":{"type":"anchor","id":1080,"name":"getnset","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1081":{"type":"anchor","id":1081,"name":"optpropag","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1082":{"type":"anchor","id":1082,"name":"nestExDesc","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1083":{"type":"anchor","id":1083,"name":"nestdup","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1084":{"type":"anchor","id":1084,"name":"plainstub","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1085":{"type":"anchor","id":1085,"name":"unnestedoff","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1086":{"type":"anchor","id":1086,"name":"parentkeyowning","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1087":{"type":"anchor","id":1087,"name":"nestedslice","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1088":{"type":"anchor","id":1088,"name":"baseRemove","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1089":{"type":"anchor","id":1089,"name":"rmvsunn","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1090":{"type":"anchor","id":1090,"name":"assignchre","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1091":{"type":"anchor","id":1091,"name":"assignoprop","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1092":{"type":"anchor","id":1092,"name":"assignname","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1093":{"type":"anchor","id":1093,"name":"assignrespvs","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1094":{"type":"anchor","id":1094,"name":"bubsin","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1095":{"type":"anchor","id":1095,"name":"poskey","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"1096":{"type":"anchor","id":1096,"name":"posh","comment":null,"start":null,"end":null,"forced":null,"modifiers":[],"file":"main.js"},"906":{"type":"class","id":906,"name":"Sqimitive","comment":"! +cl=Sqimitive\n Root object for framework's classes (`#Base, `#jQuery, etc.) with several\n constants.","start":{"line":73,"column":2,"offset":2598},"end":{"line":87,"column":2,"offset":3081},"forced":true,"modifiers":[],"file":"main.js"},"907":{"type":"var","id":907,"name":"version","comment":" Version of the core Sqimitive library in use.","start":{"line":78,"column":4,"offset":2788},"end":null,"forced":null,"modifiers":[],"file":"main.js"},"908":{"type":"var","id":908,"name":"_","comment":" Reference to the utility library in use.\n\n Particularly useful with modular frameworks like npm and Require.js so\n that it's possible to access `'_ by requiring Sqimitive alone).\n\n= NoDash `@no@`@`, Underscore `@un:`@`, LoDash","start":{"line":86,"column":4,"offset":3073},"end":null,"forced":null,"modifiers":[],"file":"main.js"},"909":{"type":"class","id":909,"name":"Sqimitive.Core","comment":"! +cl=Sqimitive.Core\n\n Implements inheritance and event system without any other Sqimitive\n (`#Base) functionality.\n\n In a typical scenario you don't need to use `#Core directly - use\n `[Sqimitive.Base`] instead.\n\n In special cases, since `'Core lacks any specialized functionality it can\n be used as a base class for your classes that need better inheritance\n and/or events (like a more elaborate alternative to\n `@https://github.com/primus/eventemitter3`@)...\n[\n   var MyEventAwareClass = Sqimitive.Core.extend({\n     doFoo: function () {\n       this.fire('beforeFoo', ['arg', 'arg'])\n       // ...\n       this.fire('afterFoo', ['...'])\n     }\n   })\n\n   // Now clients can subscribe to its events:\n   myEventAwareObject.on('beforeFoo', function () {\n     alert('Boo!')\n   })\n\n   // ...\n\n   myEventAwareObject.doFoo()    //=> Boo!\n]\n\n ...Or as an instance object held in an internal property if you want to\n avoid exposing any Sqimitive functionality at all:\n[\n   var MyEventAwareClass = function () {\n     var _events = new Sqimitive.Core\n\n     this.on   = function() { _events.on.apply(_events, arguments) }\n     this.off  = function() { _events.off.apply(_events, arguments) }\n     this.fire = function() { _events.fire.apply(_events, arguments) }\n\n     // Just like in the above example:\n     this.doFoo = function () { ... }\n   }\n\n   myEventAwareObject.on('beforeFoo', ...)\n   myEventAwareObject.doFoo()\n]","start":{"line":93,"column":2,"offset":3147},"end":{"line":4257,"column":2,"offset":167299},"forced":true,"modifiers":[],"file":"main.js"},"910":{"type":"func","id":910,"name":"constructor","comment":"! +fn=constructor\n Assigns new unique `#_cid (a string: `'p + unique positive number) and\n clones all instance properties of self that are not listed in\n `#_shareProps. Cloning puts a stop to accidental static sharing of\n properties among all instances of a class where those properties are\n defined.","start":{"line":142,"column":2,"offset":4752},"end":{"line":147,"column":2,"offset":5063},"forced":true,"modifiers":["constructor"],"file":"main.js"},"911":{"type":"var","id":911,"name":"trace","comment":" Stores the stack trace at the time this instance was `#constructor'ed, if\n `#::trace was on.\n\n#-trc","start":{"line":153,"column":19,"offset":5277},"end":null,"forced":null,"modifiers":[],"file":"main.js"},"914":{"type":"var","id":914,"name":"trace","comment":" Enables tracing of certain events to aid in debugging. Can be changed on\n run-time.\n\n#trc\n Sometimes you find yourself wondering why a hook was called or who caused\n a property to be updated. Given that hooks often point to generic\n functions or that `'_opt changes are `#batch()'ed, finding initiators can\n be a tricky business.\n\n Effects of `#::trace:\n* Every sqimitive stores `#constructor()-time stack trace in `#.trace\n* Last bunch of `#fire()'d event hooks is recorded under `#lastFired (in\n  form of their `'eobj, cloned, with `'self set to call context)\n* Objects of `'_events (`'eobj) hold stack trace of their registration\n  (`#fuse()) under `'trace\n* `#batch()'ed events receive new `'trace field in `'options, along with\n  `'batchID and others\n* Various wrapper functions (`#picker(), `#firer(), `#once(), etc.) store\n  their arguments under `'trace\n\n All added properties are meant for inspection in debugger.\n\n?`[\n  var sq1 = new Sqimitive.Core\n  alert(sq1.trace)      //=> undefined\n  Sqimitive.Core.trace = true\n  var sq2 = new Sqimitive.Core\n  alert(sq2.trace)      //=> 'Error\\n  at ...'\n `]\n\n Note: setting `'trace on subclasses of `'Core will have no effect.\n\n By default, Chrome limits trace depth to 10 which usually prevents you\n from seeing actually important frames. One way to increase it is:\n[\n  Error.stackTraceLimit = 100\n]\n Other ways: `@https://stackoverflow.com/questions/9931444`@.","start":{"line":246,"column":4,"offset":8974},"end":null,"forced":null,"modifiers":["static"],"file":"main.js"},"915":{"type":"var","id":915,"name":"lastFired","comment":" Holds recently `#fire()'d event hooks (cloned `'eobj-s with `'self set to\n call context) if `#::trace is on.\n\n#-trc","start":{"line":252,"column":4,"offset":9134},"end":null,"forced":null,"modifiers":["static"],"file":"main.js"},"916":{"type":"var","id":916,"name":"_mergeProps","comment":"#+tag_Extension\n* `@Core::_mergeProps`@\n\n#-setOnDeclViaPush\n\n Specifies which instance properties are to be merged rather than\n overwritten when redefined in a subclass.\n\n= array of string `- property names\n\n Properties must be of these types:\n> array `- Merged using `[Array.concat(baseClass[prop],\n  childClass[prop])`]. Subclass' values are added after parents' values:\n  `[['a', 'b'] + ['c'] = ['a', 'b', 'c']`].\n> object `- Merged using `[_.extend(baseClass[prop], childClass[prop])`].\n  Keys defined in parents are kept unless also defined in a subclass:\n  `[{a: 1, b: 2} + {a: 3, c: 4} = {a: 3, b: 2, c: 4}`].\n\n? `[\n   var MyParent = Sqimitive.Base.extend({\n     _objectProperty: {key1: 'value1', key2: 'value2'},\n     _arrayProperty: ['item1', 'item2'],\n   })\n\n   MyParent._mergeProps.push('_objectProperty', '_arrayProperty')\n\n   var MyChild = MyParent.extend({\n     _objectProperty: {key2: 'CHILD1', key3: 'CHILD2'},\n     _arrayProperty: ['item3', 'item4'],\n   })\n\n   // MyChild._objectProperty is now\n   // {key1: 'value1', key2: 'CHILD1', key3: 'CHILD2'}\n\n   // MyChild._arrayProperty is now ['item1', 'item2', 'item3', 'item4']\n]\n\n#mergePropsExtend\n ` `*Warning:`* when passing `#_mergeProps or `#_shareProps inside\n `'staticProps (second argument of `#extend()) all inherited items will be\n removed. The correct way to add your properties while keeping those in\n the base classes is this:\n[\n   var MySqimitive = Sqimitive.Base.extend({\n     // Define instance fields...\n   }, {\n     // Define static fields if you need, else don't pass this parameter.\n   })\n\n   // extend() has copied the inherited _mergeProps list which we can now\n   // append to or modify using regular Array functions.\n   MySqimitive._mergeProps.push('prop1', 'prop2', ...)\n   // Same with _shareProps.\n   MySqimitive._shareProps.push('prop1', 'prop2', ...)\n]\n\n These are `*wrong`* ways to append to these properties:\n[\n   var MySqimitive = Sqimitive.Base.extend({\n     // WRONG: _mergeProps is static so it won't be read from here.\n     _mergeProps: ['prop'],\n   }, {\n     // WRONG: technically fine but will entirely replace base class'\n     // merge list.\n     _mergeProps: ['prop'],\n   })\n\n   // WRONG: works but once again will replace all the inherited items.\n   MySqimitive._mergeProps = ['prop']\n\n   // CORRECT:\n   MySqimitive._mergeProps.push('prop')\n]\n\n#\n\n Other notes:\n* `#extend() always clones `#_mergeProps and `#_shareProps.\n* By default, `#Base class adds `@Base._opt`@, `@Base.elEvents`@ and\n  `#_respToOpt to this list.\n* See instance `#.mixIn() for the implementation.\n* Removing a parent-of-parent's property from `'_mergeProps doesn't\n  \"un-merge\" it since merging happens in `#extend() (`#mixIn()) so after\n  `#extend() the new class already has merged properties of all of its\n  ancestors. However, removal does affect new subclasses: `[\n    var ClassA = Sqimitive.Base.extend({array: ['in A']})\n    ClassA._mergeProps.push('array')\n      // (new ClassA).array is ['in A']\n\n    var ClassB = ClassA.extend({array: ['in B']})\n      // (new ClassB).array is ['in A', 'in B']\n\n    var ClassC = ClassB.extend({array: ['in C']})\n    ClassC._mergeProps = []\n      // (new ClassC).array is ['in A', 'in B', 'in C']\n\n    var ClassD = ClassC.extend({array: ['in D']})\n      // (new ClassD).array is ['in D'] - not merged!\n  `]\n\n# Complex inherited value modification\n `'_mergeProps doesn't allow deleting members or otherwise changing the\n value. However, in some contexts `'null or `'undefined does the job for\n objects (in contrast with `'delete such properties still appear when\n using `[for..in`], etc.):\n[\n   var MyParent = Sqimitive.Base.extend({\n     _objectProperty: {key1: 'value1', key2: 'value2'},\n   })\n\n   MyParent._mergeProps.push('_objectProperty')\n\n   var MyChild = MyParent.extend({\n     _objectProperty: {key1: null},\n   })\n\n   // MyChild._objectProperty is now {key1: null, key2: 'value2'}\n\n   for (var key in new MyChild) { alert(key) }\n     //=> key1\n     //=> key2\n]\n\n Use `@Base.init()`@ or `#postInit() to modify inherited values in other\n ways:\n[\n   var MyParent = Sqimitive.Base.extend({\n     _objectProperty: {key1: 'value1', key2: 'value2'},\n   })\n\n   var MyChild = MyParent.extend({\n     events: {\n       init: function () {\n         // MyParent's _objectProperty is unaffected, see _shareProps.\n         delete this._objectProperty.key1\n         this._objectProperty.key2 += 'foo'\n       },\n     },\n   })\n\n   // MyChild._objectProperty is now {key2: 'value2foo'}\n\n   for (var key in new MyChild) { alert(key) }\n     //=> key2\n]\n\n#-inBB\n In Backbone, when you extend a parent class with a property that it\n already has you end up with a completely new property. This doesn't\n always make sense - for example, if a class has its own\n `@bb:View-events`@ then what you really need is merge its own (base)\n events with the events of new subclass. Same thing with\n `@bb:Model-attributes`@ and `@bb:Model-defaults`@, `@bb:Router-routes`@\n and others. Example (`@http://jsfiddle.net/Proger/u2n3e6ex/`@):\n[\n   var MyView = Backbone.View.extend({\n     events: {\n       'click .me': function () { alert('You clicked it!') },\n     },\n   })\n\n   var MyOtherView = MyView.extend({\n     // This object entirely replaces MyView's event map.\n     events: {\n       'keypress .me': function () {\n         alert('Oh noes, we broke the button :(')\n       },\n     },\n   })\n]","start":{"line":429,"column":4,"offset":15651},"end":null,"forced":null,"modifiers":["static","protected"],"file":"main.js"},"917":{"type":"var","id":917,"name":"_shareProps","comment":"#+tag_Extension\n* `@Core::_shareProps`@\n\n#-setOnDeclViaPush\n\n Specifies which instance properties are not to be cloned upon\n construction. They will be shared by all instances of a class (where the\n property was defined, i.e. where given to `#extend()).\n\n= array of string `- property names\n\n Unlisted instance properties are cloned (using `#deepClone()) upon new\n object instantiation (in `#constructor). If using a complex object\n (`'Date, `'Node, etc. - not just `[{}`]) then assign it in\n `@Base.init()`@ or `#postInit(). If using an instance property as if it\n were static, either list it in `#_shareProps or move to `'staticProps\n (`#extend()) and access as `[this.constructor.foo`] (yes, JavaScript\n makes it pretty inconvenient).\n\n? One particular case when the default cloning causes problem is when you\n  are assigning \"classes\" to properties - recursive copying of such a\n  value not just breaks it (`[MyClass === myObj._model`] no longer works)\n  but is also very heavy.\n\n  Either use `#_shareProps...\n  `[\n    var MyView = Sqimitive.Base.extend({\n      _model: MyApp.MyModel,\n    })\n\n    // _shareProps is a static property.\n    MyView._shareProps.push('_model')\n  `]\n\n  ...Or assign the value after instantiation, which is less declarative:\n  `[\n    var MyView = Sqimitive.Base.extend({\n      _model: null,   // MyApp.MyModel\n\n      events: {\n        init: function () {\n          this._model = MyApp.MyModel\n        },\n      },\n    })\n  `]\n    `&sup1 It's customary in Sqimitive to leave a comment with the type's\n    name next to such property.\n\n#-mergePropsExtend\n\n Other notes:\n* By default, `#Base class adds `#_childClass to this list.\n* See instance `#.mixIn() for the implementation.\n\n#-inBB\n In Backbone, values of all properties inherited by a subclass are shared\n among all instances of the base class where they are defined. Just like\n in Python, if you have `[...extend( {array: []} )`] then doing\n `[this.array.push(123)`] will affect all instances where `'array wasn't\n overwritten with a new object. This poses a typical problem in day-to-day\n development.\n\n Example (`@http://jsfiddle.net/Proger/vwqk67h8/`@):\n[\n   var MyView = Backbone.View.extend({foo: {}})\n   var x = new MyView\n   var y = new MyView\n   x.foo.bar = 123\n   alert(y.foo.bar)\n]\n\n Can you guess the alert message? It's `'123!","start":{"line":504,"column":4,"offset":18435},"end":null,"forced":null,"modifiers":["static","protected"],"file":"main.js"},"918":{"type":"func","id":918,"name":"extend","comment":"! `, +fna=function ( [name,] [protoProps [, staticProps]] )\n\n#+tag_Extension\n* `@Core::extend()`@\n#\n\n Creates a subclass of the class on which `#extend() is called.\n\n> name string `- Optional convenience string displayed in the debugger (as\n  the function/constructor - \"class\" name). Defaults to name of base\n  class.\n  `[\n    var MyClass = Sqimitive.Base.extend('My.Class')\n    MyClass.name                      //=> 'My.Class'\n    ;(new MyClass).constructor.name   //=> 'My.Class'\n  `]\n> protoProps object `- New instance fields (properties or methods). May\n  contain special non-field keys (see `#mixIn()).\n> staticProps object `- New static fields.\n\n `'protoProps fields become accessible as `[(new MyClass).instanceSomething()`]\n while `'staticProps - as `[MyClass.staticSomething()`].\n\n Any argument may be `'null or omitted. If all are such then you get a\n copy of the base class (and yet `[BaseClass !== SubClass`]).\n\n Other notes:\n* In Sqimitive, subclassing is a special case of mix-ins (multi-parent\n  inheritance in OOP). `#extend() simply creates a new \"blank\" class and\n  mixes the base class into it. Therefore most of the job is performed by\n  `#mixIn() (which also allows changing particular object's prototype\n  after class construction on run-time).\n* `#extend() creates a new prototype, sets its parent, assigns `'__super__\n  (a static property pointing to the base class), calls `#::mixIn() and\n  resolves `#_childClass if it's a string (since it can't be done before\n  the prototype is created).\n#-mixInDoes\n* If `'staticProps argument is given, it replaces\n  `[protoProps.staticProps`]. As expected, this key (or argument) is\n  applied by `#mixIn() after applying `'staticProps of `'mixIns.\n  `[\n    var MixIn = {\n      staticProps: {sp: 'm'}\n    }\n    var Class = Sqimitive.Base.extend({\n      mixIns: [MixIn]\n    }, {\n      sp: 'c'\n    })\n    // Equivalent:\n    var Class = Sqimitive.Base.extend({\n      staticProps: {sp: 'c'},\n      mixIns: [MixIn]\n    })\n    // Above, Class.sp is 'c'. However, if mixing-in later, it'd be 'm':\n    Class.mixIn(MixIn)\n  `]\n\n? In case of duplicated field names, subclass' fields take precedence and\n  overwrite fields in the parent class except for fields listed in\n  `#_mergeProps: `[\n    // First we extend a base Sqimitive class with our own properties.\n    var MyBase = Sqimitive.jQuery.extend({\n      _somethingBase: 123,\n      _somethingNew: 'foo',\n\n      el: {tag: 'nav', id: 'nav'},\n\n      _opt: {\n        baseOption: 'boo',\n        baseMore: 'moo',\n      },\n    })\n\n    // Now if we extend MyBase...\n    var MySubclass = MyBase.extend({\n      _somethingSub: 'bar',\n      _somethingBase: 987,\n\n      el: {tag: 'footer'},\n\n      _opt: {\n        subOption: 'sub',\n        baseMore: 'bus',\n      },\n    })\n\n    /*\n      ...we get the following class, after merging with its parent:\n\n        MySubclass = {\n          // Got new value - overridden in MySubclass.\n          _somethingBase: 987,\n          // Retained old value from MyBase.\n          _somethingNew: 'foo',\n          // New property - introduced in MySubclass.\n          _somethingSub: 'bar',\n\n          // Got new value in MySubclass.\n          el: {tag: 'footer'},\n\n          // Unlike el, _opt is listed in _mergeProps by default so its\n          // keys are merged and not entirely replaced.\n          _opt: {\n            // Retained.\n            baseOption: 'boo',\n            // Introduced.\n            subOption: 'sub',\n            // Overridden.\n            baseMore: 'bus',\n          },\n        }\n    */\n  `]","start":{"line":637,"column":4,"offset":23410},"end":{"line":683,"column":4,"offset":25467},"forced":null,"modifiers":["static"],"file":"main.js"},"920":{"type":"func","id":920,"name":"mixIn","comment":"#+tag_Extension\n* `@Core::mixIn()`@\n#\n\n Extends this class with a behaviour of another \"class\" (a \"mix-in\").\n\n The instance `#.mixIn() works the same way but allows extending a\n particular object instance on run-time. Its description follows.\n\n#-mixInDesc","start":{"line":695,"column":4,"offset":25791},"end":{"line":697,"column":4,"offset":25886},"forced":null,"modifiers":["static"],"file":"main.js"},"921":{"type":"func","id":921,"name":"stub","comment":" Simply an empty function that returns `'undefined.\n\n ` `#stub() is similar to `@un:noop`@() in Underscore and LoDash.\n\n? Use `#stub() or `'undefined in places where you don't want to supply any\n  implementation - this lets Sqimitive optimize things when it knows that\n  a function (acting as a method or an event handler) can be simply\n  discarded or overridden.\n  `[\n     var MySqim = Sqimitive.Base.extend({\n       success: Sqimitive.Base.stub,\n       error: Sqimitive.Base.stub,\n       // Equivalent:\n       success: undefined,\n       error: undefined,\n     })\n\n     var my = new MySqim\n     // Replaces the empty handler entirely.\n     my.on('success', function () { alert('Good!') })\n       //=> my._events.success.length is 1\n  `]\n\n Otherwise, if you are not a performance purist you can just use\n `[function () {}`] or `[new Function`]:\n[\n   var MySqim = Sqimitive.Base.extend({\n     success: function () { },\n   })\n\n   var my = new MySqim\n   my.on('success', function () { alert('Good!') })\n     //=> my._events.success.length is 2\n]\n\n Special values `#stub() and `'undefined are only recognized in\n properties, not `#events:\n[\n   var MySqim = Sqimitive.Base.extend({\n     events: {\n       // Registers new hook that is called but has no effect on anything.\n       success: Sqimitive.Base.stub,\n       // Itself does nothing but previously registered hooks are removed.\n       '=success': Sqimitive.Base.stub,\n       // Simply wrong, undefined is not callable.\n       success: undefined,\n     },\n   })\n\n   var my = new MySqim\n   my.on('success', function () { alert('Good!') })\n     //=> my._events.success.length is 2 (existing stub handler kept)\n   my.on('success', Sqimitive.Base.stub)\n     //=> my._events.success.length is 3 (new stub handler added)\n   my.on('success', undefined)\n     // simply wrong, undefined is not callable\n]","start":{"line":756,"column":4,"offset":28081},"end":{"line":756,"column":38,"offset":28115},"forced":null,"modifiers":["static"],"file":"main.js"},"922":{"type":"func","id":922,"name":"unique","comment":"! `, +fna=function ( [prefix] )\n\n#+tag_Utilities\n* `@Core::unique()`@\n#\n\n Returns a sequential number starting from `[1`] that is guaranteed to be\n unique among all calls to `#unique() with the same `'prefix during this\n session (page load, etc.).\n\n ` `#_cid receives one such value in `#constructor.\n\n ` `#unique() is similar to `@un:uniqueId`@() in Underscore and LoDash.\n\n?`[\n    unique('my')    //=> 3\n    unique()        //=> 87\n    unique('my')    //=> 4\n    unique('some')  //=> 21\n    unique('my')    //=> 5\n `]\n\n Well-known `'prefix'es:\n> p `- used in `#_cid (sqimitive's ID)\n> e `- used in `#on() (event handler's ID)\n> o `- used in `#set() (operation's ID)\n> b `- used in `#batch() (batch's ID - group of operations)\n> bg `- used in `#batchGuard() (guard's instance)","start":{"line":786,"column":4,"offset":29069},"end":{"line":788,"column":4,"offset":29169},"forced":null,"modifiers":["static"],"file":"main.js"},"923":{"type":"func","id":923,"name":"picker","comment":"! `, +fna=function ( prop [, args] )\n\n#+tag_Utilities\n* `@Core::picker()`@\n#\n\n Returns a function accepting an object and returning value of the\n property at `'prop, accessible via that object.\n\n> prop string dotted property path`, array already split path, empty array\n  to return the `'a'rgument itself (or result of calling it)`, other\n  stringified and split\n> args array`, mixed = `[[[args]]`]`, omitted = `'[] `- list of argument\n  lists for `'function-type properties\n\n The returned function (`'f) expects one argument (`'a). When called, `'f\n walks `'prop, treating each item as a key (\"own\" or not) in the \"current\"\n object (which starts as `'a) and returns the last \"current\" object.\n\n If there is a `'function at that key (or `'a itself is one) and its\n `'name is not a string starting with a capital letter (i.e. not a class\n constructor), `'f calls it in previous \"current\" object's context\n (`'undefined if calling `'a) with the next unused member of `'args (`'[]\n if none) and stores the result as the new \"current\" object.\n\n `'f returns `'undefined when trying to descend into `'undefined/`'null\n \"current\" value.\n\n ` `#picker() is similar to `@un:result`@() in Underscore and LoDash.\n\n? `[\n      var obj = {\n        one: 1,\n        two: function () { return 2 },\n        some: function (a, b) { return a + '--' + b },\n      }\n\n      var picker = Sqimitive.Base.picker\n      picker('one')(obj)                  //=> 1\n      picker('two')(obj)                  //=> 2\n      picker('some', [['A', 'B']])(obj)   //=> 'A--B'\n\n      var collection = ['foo', null, ['bar'], obj]\n      _.map(collection, picker('one'))\n        //=> [undefined, undefined, undefined, 1]\n\n      'toString' in obj           //=> true\n      _.has(obj, 'toString')      //=> false\n      picker('toString')(obj)     //=> '[object Object]'\n\n      picker([])(obj)             //=> obj\n      picker([])('foo')           //=> 'foo'\n      picker([])(() => 123)       //=> 123\n      // typeof Date is 'function' but Date.name[0] is upper-case.\n      picker([])(Date)            //=> Date\n      picker(0)('foo')            //=> 'f'\n      picker('0.0.0')('foo')      //=> 'f'\n      picker([])(null)            //=> null\n      picker(0)(null)             //=> undefined\n  `]\n\n? Usually `#picker()'s result is given to some filtering function\n  (`#util). Example from `#chld: `[\n    getIncomplete: function () {\n      return this.reject(MyToDoList.picker('get', 'isCompleted'))\n    },\n  `]\n\n? `'args is a list of multiple argument lists, not a single argument list.\n  This enables `#picker() to call methods of objects returned by other\n  methods. However, `'prop often references just one property which is\n  either not a method or a method taking nothing (so you can omit `'args),\n  or a method taking one scalar argument (so you can pass that value\n  directly):\n  `[\n    picker('remove')(sqim)        //= sqim.remove()\n    picker('get')(sqim)           //= sqim.get()\n    picker('get', 'opt')(sqim)    //= sqim.get('opt')\n\n    picker('nested.get', [['ch1'], ['opt']])(sqim)\n    // Same as:\n    sqim.nested('ch1').get('opt')\n\n    picker('nested.get', [['ch1']])(sqim)\n    // Same as:\n    picker('nested.get', 'ch1')(sqim)\n    // Same as:\n    sqim.nested('ch1').get()\n\n    // WRONG, will fail:\n    picker('nested.get', ['ch1', 'opt'])(sqim)\n    picker('nested.get', ['ch1'])(sqim)\n  `]","start":{"line":883,"column":4,"offset":33098},"end":{"line":914,"column":4,"offset":33811},"forced":null,"modifiers":["static"],"file":"main.js"},"924":{"type":"func","id":924,"name":"expandFunc","comment":"! `, +fna=function ( func [, obj] )\n\n Expands a function reference `'func of object `'obj (`'this if not given)\n into a real `'Function.\n\n ` `#expandFunc() is used in `#on(), `#events and others to\n short-reference the instance's own methods.\n\n If `'func is a string and contains a dot or a dash (`[.-`]) - returns\n masked (`#masker()) version of this method (`'mask starts with the first\n such character). If it's a string without them - returns a function that\n calls the method named `'func on `'obj (or `'this if omitted). In other\n cases returns `'func as is (if `'obj is omitted) or `[_.bind(func, obj)`]\n (if `'obj is given).\n\n?`[\n    var func = Sqimitive.Base.expandFunc('meth')\n      // returned function will call this.meth(arguments, ...)\n\n    var obj = {meth: function (s) { alert(s) }}\n    func.call(obj, 123)\n      // alerts 123\n\n    var func = Sqimitive.Base.expandFunc('meth-.', obj)\n      // this function works in obj context, calling meth with just one\n      // argument (2nd it was given) - see masker()\n\n    _.each({k1: 1, k2: 2}, func)\n      // each() calls func(1, 'k1') and func(2, 'k2')\n      // func calls obj.meth('k1') and obj.meth('k2')\n      // alerts twice: 'k1' and 'k2'\n\n    _.each({k1: 1, k2: 2}, _.bind(func, obj))\n      // if we didn't give obj to expandFunc() previous example would\n      // fail - func() would be called on window which has no 'meth'\n      // method\n `]","start":{"line":953,"column":4,"offset":35450},"end":{"line":969,"column":4,"offset":35983},"forced":null,"modifiers":["static"],"file":"main.js"},"925":{"type":"func","id":925,"name":"masker","comment":"! `, +fna=function ( func[, mask[, cx[, args]]] )\n\n#+tag_Utilities\n* `@Core::masker()`@\n#\n\n Returns a version of `'func with arguments reordered according to `'mask.\n\n> mask number to skip that many leading arguments alike to `@no@rest`@()`,\n  null/omitted to assume the number `'1 (skip first argument)`, string\n  pattern `#maskerPattern\n> func string method name`, function `- called on `'cx\n> cx object`, null/omitted use `'this `- the context for `'func\n> args array `- extra left-side arguments to `'func\n\n ` `#masker() is similar to LoDash's `'rearg().\n\n Masking is a way to work around `#argDanger and avoid writing callback\n function wrappers that only ignore or reorder arguments. It's implicitly\n used in string `#events values since they are passed to `#expandFunc().\n\n#es6this\n? ES6 arrow functions could be useful for this but they are ill-suited for\n  use as handlers when `#extend()'ing because of their permanent `'this.\n\n  `[\n    var MyClass = Sqimitive.Base.extend({\n      events: {\n        // WRONG: will pass res as s, value as chars and break clean():\n        '+normalize_caption': 'clean',\n        // WRONG: this is window/self, not an instance of MyClass:\n        '+normalize_caption': (res, value) => this.clean(value),\n        // CORRECT:\n        '+normalize_caption': function (res, value) { return this.clean(value) },\n        // CORRECT: skip first argument, give second:\n        '+normalize_caption': 'clean-.',\n      },\n\n      clean: function (s, chars) {\n        chars = chars || ' \\t\\r\\n'\n        while (s.length && chars.indexOf(s[0]) != -1) {\n          s = s.substr(1)\n        }\n        while (s.length && chars.indexOf(s[s.length - 1]) != -1) {\n          s = s.replace(/.$/, '')\n        }\n        return s\n      },\n    })\n  `]\n\n?`[\n   $.ajax({\n     url: 'api/route',\n     dataType: 'json',\n     context: sqim,\n\n     // WRONG: success' second argument is textStatus which gets assigned\n     // as assignResp(data, options) breaking the latter (textStatus is\n     // not options):\n     success: sqim.assignResp,\n\n     // CORRECT: we indicate that we are only interested in the first\n     // argument which is passed through to assignResp():\n     success: Sqimitive.Base.masker('assignResp', '.'),\n   })\n `]\n\n? It is customary to alias `#masker() with a shorter name and use the\n  alias in the code:\n  `[\n    var m = Sqimitive.Base.masker\n\n    var MyModel = Sqimitive.Base.extend({\n      // Note that it's different from the first example: normalize_OPT\n      // is a method, not an event handler, so no need for '+...' - but\n      // no automatic masking too (string value can be used only in\n      // events, in properties it must be a function).\n      //\n      // Unmasked, _.trim() takes two arguments: (str, chars).\n      // normalize_OPT() is passed: (value, options).\n      // As we see, options is given as chars which is incorrect.\n      normalize_caption: m(_.trim, '.'),\n    })\n  `]\n\n? `[\n    // Giving an explicit cx, the context object (col):\n    _.each(arrayOfSqims, m('nest', '21', col))\n      // here we call col.nest() on each item in arrayOfSqim with swapped\n      // arguments, effectively nesting each member into the col object.\n      // _.each() calls the iterator as (value, key) while nest() takes\n      // (key, sqim)\n\n    m('nest', 1)\n      // returns a function that preserves all but the first argument:\n      // function () { return this.nest.apply(this, _.rest(arguments)) }\n\n    m('nest')\n      // the same - omitted mask defaults to number 1\n\n    m('nest', 0, cx)\n      // doesn't change arguments at all (_.rest(a, 0) == a) but binds\n      // function to cx\n\n    m('nest', 0, null, ['left', 'left2'])\n      // doesn't bind result but pushes 'left' and 'left2' arguments\n      // before all given arguments: nest('left', 'left2', other args...)\n\n    m(function (a1, a2) { alert(a1 + ' ' + a2) }, '')\n      //=> always 'undefined undefined'\n  `]\n\n#maskerPattern Mask pattern\n In a string `'mask, each symbol maps arguments given to the masked\n function (returned by `#masker) to arguments for the original `'func (the\n argument to `#masker). Each symbol represents a particular argument and\n can be one of these:\n\n> dot: `'. `- gets argument at index of this dot in the `'mask string\n  (`[-..-.`] equals to `[-23-5`])\n> dash: `'- `- ignores argument (doesn't give to `'func); trailing dashes\n  are meaningless (arguments past the end of `'mask are never given unless\n  `'mask is a number)\n> number: `[1-9`] `- gets argument by index: `'1 gets the first masked\n  argument, etc.\n\n For example, if the wrapped function received arguments `[arg1, arg2,\n arg3`] then the `'mask of `[-.1`] (same as `[-21`]) gives the original\n `'func arguments `[arg2, arg1`].\n\n Empty `'mask passes zero arguments (as do `[-`], `[--`], etc.).\n\n Note: the `'mask of `['3'`] (string) is different from `[3`] (number) -\n `['3'`] passes 3rd wrapper's argument as the first `'func's argument\n while `[3`] skips first 3 arguments and passes all others.","start":{"line":1107,"column":4,"offset":41795},"end":{"line":1133,"column":4,"offset":42618},"forced":null,"modifiers":["static"],"file":"main.js"},"926":{"type":"func","id":926,"name":"deepClone","comment":"#+tag_Utilities\n* `@Core::deepClone()`@\n#\n\n Returns a version of the argument with recursively-copied arrays and `'{}\n objects so that any modification to either `'obj or the returned value\n (`'obj's copy) won't affect its counterpart.\n\n#deepclonebase\n ` `#deepClone() is used in `@Core.constructor`@ to copy non-shared\n properties (`#_shareProps). Think of it as of recursively calling\n `@un:clone`@() or `@jq:extend`@() or using LoDash's `'cloneDeep(). It's\n deliberately dumb to remain simple and will attempt to copy everything,\n even classes like `'Date, `'RegExp, DOM nodes, etc. (resulting in invalid\n objects).\n\n Use `#deepClone() when need to clone an object just once or twice. Use\n `#deepCloner() when doing this often (such as upon new object\n instantiation) - it's faster by 8-9 times and produces code close to what\n you'd have written by hand.\n\n?`[\n    var obj = {array: [{sub: 'prop'}]}\n    var obj2 = obj\n    var obj3 = Sqimitive.Base.deepClone(obj)\n\n    obj2.array.push('new')\n      // obj.array is now [{sub: 'prop'}, 'new']\n      // obj3.array is still [{sub: 'prop'}]\n\n    delete obj3.array[0].sub\n      // obj3.array is now [{}]\n      // obj.array is still [{sub: 'prop'}, 'new']\n\n    var cloner = Sqimitive.Base.deepCloner(obj)\n    cloner.toString()   //=> return {\"array\":[{\"sub\":\"prop\",},],}\n    var objClone = cloner()\n `]","start":{"line":1173,"column":4,"offset":44203},"end":{"line":1186,"column":4,"offset":44539},"forced":null,"modifiers":["static"],"file":"main.js"},"927":{"type":"func","id":927,"name":"deepCloner","comment":"! `, +fna=function ( [obj [, options]] )\n\n#+tag_Utilities\n* `@Core::deepCloner()`@\n#\n\n Returns a function constructing `'obj with recursively-copied arrays and\n `'{} objects - compiled version of `#deepClone().\n\n> obj mixed\n> options missing create new cloner`, object merge multiple cloners `-\n  non-scalar values are held in `'shared array, passed to the returned\n  function via `'s variable\n= function returning `'obj copy`, object if no arguments or if `'options\n  given, call its `'compile() to get the function\n\n#-deepclonebase","start":{"line":1205,"column":4,"offset":45183},"end":{"line":1254,"column":4,"offset":46568},"forced":null,"modifiers":["static"],"file":"main.js"},"933":{"type":"func","id":933,"name":"parseEvent","comment":" Extracts portions of the given event identifier as recognized by `#on().\n\n Returns an object with keys: `'batch (leading `[^`]), `'priority (number\n before `[^`]), `'prefix (like `[+`], see `#evtpf), `'args (number of\n trailing `[_`] or null), `'event (event name, everything else) and\n `'trace (`'null if `#::trace is off).\n\n Errors if `'str doesn't look like a proper event reference.\n\n?`[\n    Sqimitive.Core.parseEvent('foo.bar')\n      //=> {batch: true, priority: 0, prefix: '', event: 'foo.bar', args: null}\n\n    Sqimitive.Core.parseEvent('^-3^+foo.bar___')\n      //=> {batch: false, priority: -3, prefix: '+', event: 'foo.bar', args: 3}\n `]","start":{"line":1272,"column":4,"offset":47320},"end":{"line":1281,"column":4,"offset":47862},"forced":null,"modifiers":["static"],"file":"main.js"},"940":{"type":"func","id":940,"name":"fire","comment":"! `, +fna=function ( funcs [, args [, inBatch]] )\n\n Invokes event handlers in response to firing an event (see instance\n `#.fire()).\n\n `'funcs is an array of event registration objects of an internal format.\n `#::fire() calls each handler in order according to its type (such as\n expecting a fixed number of arguments, accepting current result value,\n affecting return value, etc. according to `'prefix in `#on(), see\n `#evtref) while giving it `'args (array or `'Arguments).\n\n If a handler returns something other than `'undefined and it's eligible\n for changing return value (as it's the case for `'+event and `'=event,\n see `#evtpf), then current result is replaced by that handler's return\n value. Returns the ultimate return value after calling every handler,\n unless stopped by any `'eobj.`#post callback setting `[eobj.stop`] to\n `'true (see the example in `#post).\n\n Other notes:\n* This is an internal method and there is no reason to call it directly.\n* Hook order (priority; `#evtref) is maintained by `#fuse(), not `'fire().\n* `'funcs can be non-`'isArray, in this case `'undefined is returned.\n* `'funcs is cloned; members added or removed while `#::fire() is running\n  are ignored; changes to a member (`'eobj) affect the call only if that\n  member wasn't yet called.\n* In `#Core, a removed hook that was not yet called still isn't called\n  (because `'_unregHandler() clears `[eobj.func`]). See the second example\n  below.\n\n?`[\n   var funcs = [\n     // The event object (eobj) stored within sqim._events:\n     {func: function () { ... }, cx: window, res: true}\n   ]\n   var res = Sqimitive.Core.fire(funcs, [5, 'foo'])\n     // same as: var res = func.call(window, 5, 'foo')\n `]\n\n? Removing hooks from within `#::fire():\n  `[\n    var sqim = new Sqimitive.Core\n    var ev1 = sqim.on('evt', () => console.log(1))    // to be called first\n    sqim.on('evt', () => sqim.off(ev1).off(ev2))      // to be called second\n    var ev2 = sqim.on('evt', () => console.log(2))    // to be called last\n    sqim.fire('evt')\n      // console logs 1 but not 2\n  `]","start":{"line":1330,"column":4,"offset":50211},"end":{"line":1386,"column":4,"offset":52413},"forced":null,"modifiers":["static"],"file":"main.js"},"942":{"type":"func","id":942,"name":"firer","comment":"! `, +fna=function ( event [, args [, cx]] )\n\n#+tag_Events\n* `@Core::firer()`@\n#\n\n Returns a function that `#fire()-s an `'event with arguments of its call.\n\n The returned function calls `[fire(event, ...firerArgs, ...givenArgs)`]\n in context of `'cx.\n\n> event string `- like `[change_caption`]\n> args array `- push some parameters in front of the function's arguments\n  (`'firerArgs)\n> cx object `- if not given then context is unchanged\n\n? `#firer() is used by `'on() to \"convert\" method calls into events making\n  it unnecessary to directly call `#fire() in most cases (see `#evt): `[\n    var MyClass = Sqimitive.Base.extend({\n      upper: function (s) { return s.toUpperCase() },\n    })\n\n    var obj = new MyClass\n      // obj.upper is the function given to extend(), not an event\n    var res = obj.upper('booh!')\n      //=> 'BOOH!'\n\n    obj.on('+upper', () => 'baah!')\n      // now obj.upper is the result of firer() and yet it's called as if\n      // it was a regular method\n    var res = obj.upper('booh!')\n      //=> 'baah!'\n    // Same as writing:\n    var res = obj.fire('upper', ['booh!'])\n      //=> 'baah!'\n  `]\n\n Essentially, using `#firer() is just a short way of writing:\n[\n   (function () { return this.fire(event, args.concat(arguments)) }).bind(cx)\n]","start":{"line":1429,"column":4,"offset":53936},"end":{"line":1442,"column":4,"offset":54360},"forced":null,"modifiers":["static"],"file":"main.js"},"943":{"type":"func","id":943,"name":"batchGuard","comment":"! `, +fna=function ( index, func [, options] )\n\n#+tag_Options\n* `@Core::batchGuard()`@\n#\n\n Returns a function for use as a `#change or compatible hook that calls\n `'func only once per `#batch (`'batchID).\n\n= function returning `'undefined if skipping `'func due to `'batchID\n\n> index int index in returned function's arguments of the `'options object\n  with `'batchID key (`#_batchOptions())`, str calculate by pattern: `'c\n  (for `#change) or `'c_ (for `#change_OPT) preceded by any number of\n  `[. + =`] (event prefixes `#evtpf that prepend extra arguments)\n> func `- subject to `#expandFunc()\n> options missing`, object\n Possible `'options keys (all optional):\n> seen Set `- Give the same value in `'seen (or the same `'options object)\n  to link several `#batchGuard-s together (to call `'func once across all\n  guards, not once per guard). you can set `'seen to a `'Set or give `'{}\n  to the first `#batchGuard() and then read the value it has written to\n  this key. Treat `'Set as a blackbox (it conceals multiple nuances\n  explained in `#skb).\n> cx object `- If not given then context is unchanged.\n> skip function `- Called when skipping a `'seen batch. Useful when\n  figuring why `'func isn't getting called when it should be.\n\n?`[\n    function titleChanged(task, now) {\n      console.log('New title of ' + task._cid + ' is ' + now)\n    }\n\n    tasks.on('.change_title', Sqimitive.Core.batchGuard('.c_', titleChanged))\n    tasks.on('.change_title', Sqimitive.Core.batchGuard(3, titleChanged))\n `]\n\n Do not use `#batchGuard() in class declaration (functions given to\n `#extend()) unless you want all instances of the class to share the same\n guard:\n[\n  var Class = Sqimitive.Core.extend({\n    events: {\n      change: batchGuard(0, () => alert('Called')),\n    },\n  })\n  var o1 = new Class\n  var o2 = new Class\n  o1.batch([o2], function () {\n    o1.set('foo', 123)    // alerts\n    o2.set('foo', 123)    // doesn't\n  })\n]\n Instead, assign such a property or hook in `'init:\n[\n  var Class = Sqimitive.Core.extend({\n    events: {\n      init: function () {\n        this.fuse('change', batchGuard(...))\n      },\n    },\n  })\n]\n\n Remember that `'func is called once per batch, not per batch per object.\n This matters if using `#batchGuard() to handle events originating from\n different objects:\n[\n  var Collection = Sqimitive.Base.extend({\n    _childEvents: ['change'],\n  })\n  var col = new Collection\n  col.on('.change', batchGuard('.c', function ...))\n  var child1 = col.nested(1)\n  var child2 = col.nested(2)\n  child1.batch([child2], function () {\n    child1.set('foo', 1)\n    child2.set('bar', 2)\n  })\n]\n In the above example, `#batchGuard() calls `'func just once and `'options\n that `'func receives may come from either of the batched sqimitives which\n means `[options.batch`] is arbitrary and does not list all queued events\n (it has either `'change_foo or `'change_bar). In case multiple origins\n are possible, instead of `'batch read `[options.batched[i][1]`] - but\n only process objects (`[...[0]`]) that you expect:\n[\n  col.on('.change', batchGuard('.c', function (child, name, now, old, options) {\n    // WRONG:\n    options.batch.forEach(...)\n  }))\n  col.on('.change', batchGuard(4, function (child, name, now, old, options) {\n    // WRONG:\n    options.batched.forEach(function ([child, batch]) {\n      batch.forEach(...)\n    })\n  }))\n  col.on('.change', batchGuard('.c', function (child, name, now, old, options) {\n    // CORRECT:\n    options.batched.forEach(function ([child, batch]) {\n      if (col.nested(child)) {    // or: child instanceof ..., etc.\n        batch.forEach(...)\n      }\n    })\n  }))\n]\n Checking objects is important because a `#batch may include unrelated\n sqimitives:\n[\n  child1.batch([child2, unrelated], function () {\n    child1.set('foo', 1)\n    child2.set('bar', 2)\n    unrelated.set('quux', 3)  // not part of col, must ignore in our guard\n  })\n]","start":{"line":1559,"column":4,"offset":58942},"end":{"line":1603,"column":4,"offset":60302},"forced":null,"modifiers":["static"],"file":"main.js"},"944":{"type":"func","id":944,"name":"toArray","comment":"#+tag_Utilities\n* `@Core::toArray()`@\n#\n\n Attempts to cast `'value into a native `'Array object.\n\n The `'Arguments object becomes an array, `'Array (`@no@isArray`@()) is\n returned as is while anything else is wrapped into an array to become its\n sole member. This means that `'false, `'null and `'undefined all result\n in `[[value]`], not in `[[]`].\n\n?`[\n   ;(function () {\n     Sqimitive.Core.toArray(arguments)   //=> [5, 'foo']\n   })(5, 'foo')\n\n   Sqimitive.Core.toArray([5, 'foo'])    //=> [5, 'foo']\n   Sqimitive.Core.toArray(5)             //=> [5]\n   Sqimitive.Core.toArray()              //=> [undefined]\n `]\n\n Note: `#toArray() does not clone the result:\n[\n   var a = [5]\n   Sqimitive.Core.toArray(a).push('foo')\n     // a is now [5, 'foo']\n]","start":{"line":1632,"column":4,"offset":61224},"end":{"line":1640,"column":4,"offset":61431},"forced":null,"modifiers":["static"],"file":"main.js"},"945":{"type":"var","id":945,"name":"_cid","comment":"#-readOnly\n\n An identifier of this object. Unique among all instances of\n `[Sqimitive.Core`] or its subclasses created during this session (page\n load).\n\n Currently begins with \"p\" for \"primitive\" followed by a positive number\n as generated by `#unique(). This is unlikely to change but in any case\n it's guaranteed to remain a valid identifier of only Latin symbols, i.e.\n begin with a letter followed by zero or more letters, digits and\n underscores.\n\n Can be used to namespace DOM events as in `[this.el.on('click.' +\n this._cid)`] (`@jQuery.attach()`@ does this).\n\n Historically \"cid\" stands for \"`[c`]lient `[id`]entifier\" - a term\n originating from Backbone (`@bb:Model-cid`@) but probably not holding\n much meaning at this point.\n\n?`[\n   ;(new Sqimitive.Core)._cid      //=> 'p1'\n   ;(new Sqimitive.Base)._cid      //=> 'p2'\n   ;(new Sqimitive.Core)._cid      //=> 'p3'\n   ;(new Sqimitive.jQuery)._cid    //=> 'p4'\n `]","start":{"line":1671,"column":4,"offset":62603},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"946":{"type":"var","id":946,"name":"events","comment":"! +prop=events\n\n#+tag_Events\n* `@Core.events`@\n#\n\n There is no such property per se but this key can be passed to `#extend()\n and `#mixIn() to set up new event handlers of a \"subclass\".\n\n Giving `'events is the same as calling `[this.on({events})`] after\n `#extend()/`#mixIn() so see `#on() (with an object argument) for details.\n\n Since in Sqimitive everything is an event (`#evt) this is the way you do\n inheritance, override methods, etc. Such events are \"fused\" into the new\n class declaration so there is no overhead of applying them on each class\n instantiation.\n\n See the Events overview (`#evt) for examples.\n\n#-es6thiswarn\n\n P.S: again, `'events is private to `#extend()/`#mixIn() and does not\n become `[this.events`].","start":{"line":1675,"column":4,"offset":62643},"end":{"line":1697,"column":4,"offset":63478},"forced":true,"modifiers":[],"file":"main.js"},"947":{"type":"func","id":947,"name":"mixIn","comment":"#+tag_Extension\n* `@Core.mixIn()`@\n#\n\n Extends this object instance with a behaviour of another \"class\" (a\n \"mix-in\").\n\n The static `#::mixIn() exists which affects all objects of a class.\n\n#mixInDesc\n\n> this `- The object receiving new \"mixed-in\" fields (for static\n  `#::mixIn() `'this is the \"child\" class).\n> newClass object `- The mix-in, the object \"mixed into\" `'this.\n> options `- An arbitrary value (usually an object) given to\n  `'newClass.`'finishMixIn(), allowing creation of parametrized mix-ins\n  (basically, generics).\n\n Possible `'newClass keys:\n\n> staticProps object `- static fields made available as\n  `[newClass.something`]\n> events object `- event listeners (see `#events)\n\n  Because this is not a real field, keys in `[newClass.events`] do not\n  override keys in `[this.events`]. If both `'this and `'newClass have the\n  `'foo event key (i.e. if both listen to this event) then two listeners\n  are set up, not one. Compare with `@Base.elEvents`@ overriding\n  (`#elEventsMixIn).\n\n> finishMixIn function `- called before returning\n\n  `'this = `'newClass. arguments = `[child, options`] where `'child is the\n  prototype of the updated class\n\n> mixIns array `- each item is either a mixed-in class or an array:\n  `[[class, options]`]\n\n> * `- other keys represent instance fields (the `'protoProps argument of\n  `#extend())\n\n  ` `#_mergeProps is respected, but of `'this (not of `'newClass).\n\n  A string form of `#_childClass is only allowed in `#extend(), not here;\n  other forms (array, object) are allowed in both places.\n\n?`[\n   var MixIn = {\n     staticProps: {\n       staticMethod: function () { ... },\n     },\n     events: {\n       '-init': function () {\n         // (1) Define a property only if it's not defined yet.\n         this._someProp = this._someProp || 'buzz'\n       },\n     },\n     finishMixIn: function (targetProto) {\n       alert(\"I'm now mixed into \" + targetProto.toString())\n\n       // (2) Or could do it here, more performance-efficient since ran\n       // only once for each mixed-in class, not once for each such class\n       // instantiation:\n       //targetProto._someProp = targetProto._someProp || 'buzz'\n       //targetProto.constructor.someStatic = 123\n     },\n     _opt: {\n       correctly: 'merged',\n     },\n     instanceMethod: function () { ... },\n   }\n\n   var Base1 = Sqimitive.Base.extend({})\n\n   var Base2 = Sqimitive.Base.extend({\n     _opt: {\n      a: 'base',\n    },\n     // Not overridden by MixIn.\n     _someProp: 123,\n   })\n\n   Base1.mixIn(MixIn)   // alerts\n     //=> _someProp = 'buzz'\n     //=> opt = {correctly: 'merged'}\n\n   Base2.mixIn(MixIn)   // alerts again\n     //=> _someProp = 123\n     //=> opt = {a: 'base', correctly: 'merged'}\n]\n\n ` `*Warning:`* `'this is modified in-place; no new class is created\n (`'mixIn() returns no value). If you want a base class without a given\n mix-in and a subclass with that mix-in - first `#extend() the base class\n and then mix into the new sub-class:\n[\n   // CORRECT:\n   var Base = Sqimitive.Base.extend()\n   var Sub = Base.extend({mixIns: [SomeMixIn]})\n\n   // WRONG: will modify Base, not return a new subclass:\n   var Base = Sqimitive.Base.extend()\n   var Sub = Base.mixIn(SomeMixIn)\n]\n\n? There is no way to determine if a class or object has some `#mixIn or\n  not. For example, listing a mix-in in `#_childClass is useless because\n  `@Base.nestEx()`@ is using `'instanceof and it works on real classes\n  only. You can add a field to work around this - static (only for mix-ins\n  applied to declarations) or instance (for mix-ins applied on run-time):\n  `[\n    var MyMixIn = {staticProps: {myMixInIsMixedIn: true}}\n    var instanceofMyMixIn = 'myMixInIsMixedIn' in myObj.constructor\n\n    var sqim1 = new Sqimitive.Core\n    var sqim2 = new Sqimitive.Core\n    sqim1.mixIn(MyMixIn)\n    sqim2.constructor.myMixInIsMixedIn    //=> true (!)\n\n    var MyMixIn = {myMixInIsMixedIn: true}\n    var sqim3 = new Sqimitive.Core\n    var sqim4 = new Sqimitive.Core\n    sqim3.mixIn(MyMixIn)\n    sqim4.myMixInIsMixedIn                //=> false\n  `]\n\n Other notes:\n* `#mixIn() is doing most of `#extend()'s job, which is just creating a\n  special form of a mix-in.\n* Hooking `#init and similar events for a mix-in applied on run-time is\n  useless since they will be never invoked.\n##mixInDoes\n* `#mixIn() applies \"sub mix-ins\" (calls `'mixIn() if `'newClass contains\n  the `'mixIns key; this is recursive), overwrites fields of `'this with\n  `#deepClone-s of those in `'newClass (or merges according to\n  `#_mergeProps), adds `'staticProps, hardwires events into class\n  definition (`#fuse()) and calls `'finishMixIn().\n##\n* Not to be confused with Underscore's `@un:mixin()`@. However, LoDash's\n  `'mixin() is of a similar purpose.\n\n##elEventsMixIn Merging of `'elEvents\n\n ` `#Base lists `@Base.elEvents`@ in `#_mergeProps so the former are\n merged but unlike with `[newClass.events`] keys (which can never have a\n conflict and be dropped), keys in `'elEvents get overridden on name\n collisions. This is sometimes desirable (to override the parent's\n handler), sometimes not (then use a unique `'.ns suffix):\n[\n   var Base = Sqimitive.Base.extend({\n     elEvents: {\n       click: function () { alert(\"Click-click-click!') },\n     },\n   })\n\n   var ChildA = Base.extend({\n     elEvents: {\n       click: function () { alert(\"Overridden!') },\n     },\n   })\n\n   var ChildB = Base.extend({\n     elEvents: {\n       'click.new-in-child-B': function () { alert(\"Combined!') },\n     },\n   })\n\n   // in ChildA, 'click' has 1 listener (Base's dropped)\n   // in ChildB, 'click' has 2 listeners (Base's and ChildB's)\n]\n\n## Mix-in inheritance\n\n `'mixIns is applied before setting other properties which allows\n extending mix-ins themselves (later mix-ins override preceding just like\n with normal inheritance on classes). For example:\n[\n   var ParentMixIn = {\n     someEvent: function () { /* parent */ },\n   ]\n\n   var ChildMixIn = {\n     mixIns: [ParentMixIn],\n     events: {\n       someEvent: function () { /* child */ },\n     },\n   }\n\n   var myClass = Sqimitive.Base.extend({\n     mixIns: [ChildMixIn],\n   })\n\n   // myClass had ParentMixIn added, then ChildMixIn, and now has two\n   // listeners on someEvent\n]\n `'ParentMixIn could also have the `'mixIns property to specify its own\n parent.\n\n In the above example, the mix-in specified its parent, which is usually\n intuitive. Still, it could be specified in the final class' `'mixIns\n alone:\n[\n   var ParentMixIn = {\n     someEvent: function () { /* parent */ },\n   ]\n\n   var ChildMixIn = {\n     // mixIns property is missing.\n     events: {\n       someEvent: function () { /* child */ },\n     },\n   }\n\n   var myClass = Sqimitive.Base.extend({\n     // Added ParentMixIn in front of ChildMixIn.\n     mixIns: [ParentMixIn, ChildMixIn],\n   })\n\n   // or (equivalent, no mixIns property, mixIn() calls instead):\n   var myClass = Sqimitive.Base.extend()\n   myClass.mixIn(ParentMixIn)\n   myClass.mixIn(ChildMixIn)\n\n   // or (equivalent for a particular object instance):\n   var myClass = Sqimitive.Base.extend()\n   var obj = new myClass\n   obj.mixIn(ParentMixIn)\n   obj.mixIn(ChildMixIn)\n\n   // in any case, MyClass (or obj) has 'someEvent' firer() with\n   // 2 listeners: of ParentMixIn and of ChildMixIn\n]\n\n ` `*Warning:`* calling `'mixIn() in `'finishMixIn() would have a\n different effect. If `'ChildMixIn were defined as follows then `'MyClass\n or `'obj would have `'someEvent not as a `#firer() but as the\n `'ParentMixIn's function (because it was mixed-in after `'ChildMixIn and\n overrode its `'events handler):\n[\n   var ChildMixIn = {\n     finishMixIn: function (newClass) {\n       newClass.mixIn(ParentMixIn)\n     },\n     events: {\n       someEvent: function () { /* child */ },\n     },\n   }\n]\n\n This will override the handler introduced in the declaration of `'Class\n for the same reason - `'MixIn is added to `'Class after `'Class' own\n fields:\n[\n   var MixIn = {\n     some: function () { ... },\n   }\n\n   var Class = Sqimitive.Base.extend({\n     events: {\n       some: function () { ... },\n     }\n   })\n\n   Class.mixIn(MixIn)\n]\n This is the correct way (using `'mixIns property when `#extend()'ing\n `'Class):\n[\n   var MixIn = {\n     some: function () { ... },\n   }\n\n   var Class = Sqimitive.Base.extend({\n     mixIns: [MixIn],\n     events: {\n       some: function () { ... },\n     }\n   })\n]\n\n## Edge cases\n See the source code for details.\n* Given a base class `'B and subclass `'C, adding mix-ins to `'B after `'C\n  has been `#extend()'ed from `'B when `'C declares `#events will lead to\n  `'C not having `#events of the newly mixed-in objects of `'B.\n* Declaration-time `#events of `'B are `#fuse()'d and their `'eobj-s are\n  shared among all subclasses of `'B and should not be changed (list of\n  events may change, just not properties of inherited handlers): `[\n    var ClassB = Sqimitive.Core.extend({\n      events: {change: 'render'},\n    })\n\n    ClassB.prototype._events.change[0].post    //=> undefined\n\n    var ClassC = ClassB.extend()\n    ClassC.prototype._events.change[0].post = function () { ... }\n    ClassB.prototype._events.change[0].post    //=> Function\n\n    // In this version instances' _events are deepClone()'d so changing it\n    // (not the prototype) doesn't affect other classes/objects:\n    var obj = new ClassC\n    obj._events.change[0].post = 'foo'\n    ClassB.prototype._events.change[0].post    //=> still Function\n  `]","start":{"line":2128,"column":4,"offset":79537},"end":{"line":2236,"column":4,"offset":84243},"forced":null,"modifiers":[],"file":"main.js"},"948":{"type":"func","id":948,"name":"fire","comment":"! `, +fna=function ( event [, args [, inBatch]] )\n\n#+tag_Events\n* `@Core.fire()`@\n#\n\n Triggers an event giving `'args as parameters to all registered\n listeners. Returns result of the last called listener that was eligible\n for changing it.\n\n The actual event processing is performed by static `#::fire().\n\n It's safe to add/remove new listeners while `#fire() is executing - they\n will be in effect starting with the next `#fire() call (even if it's\n nested).\n\n#fireOverride\n ` `*Warning:`* to override `#fire, `#fuse and `#on, don't use the usual\n `[on('fire')`] as it will lead to recursion (even the `'=fire form,\n `#evtpf). Use the old-school prototype overriding (`'__super__ is set up\n by `#extend()) - see `#Async's source code for an example:\n[\n   fire: function (event, args) {\n     // Do your stuff...\n     return MyClass.__super__.fire.apply(this, arguments)\n   },\n]\n\n#fireAll The `'all event\n ` `#fire() first triggers the special `'all event. If `'all's return\n value is anything but `'undefined - `#fire() returns it bypassing the\n actual handlers of `'event.\n\n `'all's handlers get `'event put in front of other `'args (e.g.\n `[['eventName', 'arg1', 2, ...]`]).\n\n Note that the `'all event is only triggered for actual events so if, for\n example, `#render() isn't overridden then it will be called as a regular\n member function without triggering `'all or any other event:\n[\n   var ClassA = Sqimitive.Base.extend({\n     events: {\n       render: function () { return this },\n     },\n   })\n\n   ;(new ClassA)\n     .on({all: () => alert('booh!')})\n     .render()\n       // alert() happens, render is a firer\n\n   var ClassB = Sqimitive.Base.extend({\n     render: function () { return this },\n   })\n\n   ;(new ClassB)\n     .on({all: () => alert('booh!')})\n     .render()\n       // no alert(), render of extend() is not an event handler but a\n       // method\n\n   ;(new ClassB)\n     .on({all: () => alert('booh!')})\n     .on({render: function () { return this }})\n     .render()\n       // alert() happens because of on('render') which converted\n       // the render function from ClassB's declaration to a\n       // firer('render') which when called triggers fire('render') which\n       // in turn triggers 'all'\n]","start":{"line":2317,"column":4,"offset":87270},"end":{"line":2326,"column":4,"offset":87686},"forced":null,"modifiers":[],"file":"main.js"},"949":{"type":"func","id":949,"name":"logEvents","comment":"! `, +fna=function ( [enable] )\n\n#+tag_Events\n* `@Core.logEvents()`@\n#\n\n A debug method for logging all triggered events to the console.\n\n ` `#logEvents() allows enabling event logging as well as acts as an event\n handler for `'all. The handler can be used on its own, without enabling\n logging with `[logEvents(true)`].\n\n> true `- enable logging; do nothing if browser doesn't provide\n  `[console.log()`]\n> - no arguments `- same as `'true (enable logging)\n> false `- disable logging, if enabled\n> string event name `- log this event; other arguments are the event's\n  arguments\n\n= this if `'enable is bool`, undefined if string\n\n?`[\n   sqim.logEvents(true)   // enable logging\n   sqim.logEvents()       // same as above\n   sqim.logEvents(false)  // disable\n `]\n\n Note: `#logEvents logs only events passing through the instance\n `#.fire(). This means that only real event calls are tracked, not calls\n of non-overridden methods (i.e. of regular functions, not `#firer). See\n `#fireAll.\n\n# Extending default logger\n You can override or extend the default logging behaviour by testing the\n argument for string:\n[\n   var MyLoggee = Sqimitive.Base.extend({\n     events: {\n       logEvents: function (event) {\n         // logEvents() calls itself when an event occurs and the first\n         // argument is the event name - a string. In other cases it's\n         // not the logger being called.\n         if (typeof event == 'string') {\n           console.log('el.' + this.el[0].className)\n         }\n       },\n     },\n   })\n\n   // Logs both standard logEvents() info and our class name line.\n   ;(new MyLogger).logEvents().fire('something')\n]\n\n Note: returning non-`'undefined from the `'all handler prevents calling\n real event handlers (see `#.fire()). In the above example it never\n happens since `'logEvents event is hooked with no prefix (`#evtpf)\n meaning the handler's return value is ignored (even if it does return\n anything). However, not in this example:\n[\n   events: {\n     '=logEvents': function (sup, event) {\n       if (typeof event == 'string') {\n         console.log(this.el[0].className)\n       } else {\n         sup(this, arguments)\n       }\n       return 'break!'\n         // returning non-undefined from an 'all' handler bypasses real\n         // event handlers\n     },\n   },\n]","start":{"line":2400,"column":4,"offset":90420},"end":{"line":2426,"column":4,"offset":91250},"forced":null,"modifiers":[],"file":"main.js"},"952":{"type":"func","id":952,"name":"on","comment":"! `, +fna=function ( event(s) [, func] [, cx] )\n\n#+tag_Events\n* `@Core.on()`@\n#\n\n Registers a single event handler and returns its ID or permanently\n hardwires multiple events and/or handlers.\n\n> event string to register one handler and return ID that can be used to\n  unregister it with `#off()`, object to `#fuse() one or multiple handlers\n  and return `'this `- Object keys are event references (`#evtref), values\n  are handlers.\n\n  If an object, keys can contain multiple event references separated with\n  `[,`] - this is identical to multiple `#on() calls but shorter. Note: a\n  space after the comma is mandatory (unlike with `#jQuery selectors).\n\n#onOnce\n> cx object`, null/omitted use `'this `- Context in which the handler(s)\n  are called. `'this is the object on which `#on() was called so\n  `[on('e', 'h')`] will call `'h() on the object where the event occurs\n  (and in that object's context).\n\n The handler (`'func or `'event object value) can be either a (masked)\n method reference (see `#expandFunc()) or function. Strings are resolved\n when the event is fired so their handlers are always up-to-date and don't\n even have to exist by the time `#on() is called.\n\n Errors if an event reference can't be parsed.\n\n#\n\n? Object form - `[on( {events} [, cx] )`]:\n  `[\n     sqim.on({'-get_, nest': 'render'})\n       //=> this (handlers cannot be unbound)\n       // call render() on sqim when get() and nest() happen\n\n     // WRONG: no space, seen as a single event name \"get_,nest\":\n     sqim.on({'-get_,nest': 'render'})\n  `]\n\n   String form - `[on( 'event', func [, cx] )`]:\n   `[\n     var id = sqim.on('change', this.render, this)\n       //=> 12345\n       // handler called in a different context (this, not sqim)\n     sqim.off(id)\n\n     // WRONG: comma notation only accepted by on({events}):\n     sqim.on('change, nest', this.render, this)\n   `]\n\n? Object-`'event form is used behind the scenes when `#extend()'ing or\n  `#mixIn() a class and supplying the `'events key in `'protoProps,\n  therefore `#events format is exactly the `'events argument of `#on().\n\n  Warning: when giving `#extend() or `#mixIn() a method (as a property,\n  not as an `'events member) which name is already used for an event it\n  will conceal existing handlers and generally misbehave - see `#evtconc.\n\n  Warning: this semantics does not apply to `@Base.elEvents`@!\n\n  `[\n     var MyClass = Sqimitive.Base.extend({\n       events: {\n         // Calls render() after 'name' option change and before\n         // 'birthday' change.\n         'change_name, -change_birthday': 'render',\n\n         // Calls fadeOut() when 'close' gets fired.\n         close: function () {\n           this.el.fadeOut(_.bind(this.remove, this))\n         },\n       },\n     })\n\n     obj.set('name', 'miku')   // render() called\n     obj.close()               // fadeOut() called\n  `]\n\n#-fireOverride\n\n Other notes:\n* To register one-time handlers use `#once() instead of `#on() + `#off().\n* `#on() with an object `'event is like `#fuse() but with added comma\n  notation in `'event keys.\n* Treat event ID as an opaque scalar value. Its type and format may change\n  but not its meaning in regards to `#off() and other methods.\n* Fusing is a bit more efficient since no tracking information about\n  handlers is stored. If your handler is meant to stay with the object for\n  its lifetime - use `[on({event: func}, cx)`] or `#fuse() (this also\n  clearly conveys your intention of keeping it forever).\n* Specifically, `#fuse() affects one internal value (the list of hooks),\n  single-handler `#on() - two (+ list of event IDs) or three (+ list of\n  events by context if `'cx is not `'null), `#off() - also two or three.\n\n#evtref Event reference format\n An event reference is a string with four parts:\n `[[priority^][prefix]event[args]`].\n\n> priority `- Optional; an integer ending on `'^ determining the order of\n  calling hooks of the same event (defaults to `'0, may be negative),\n  lower called first. If begins with `'^ or is `'^ alone, marks the\n  handler out-of-batch: when due for calling in response to `#batch()'ed\n  events, it is called immediately after `'func returns - without draining\n  accumulated batches (see `#naor).\n> prefix `- Optional; changes the way event handler is bound and called as\n  explained in `#evtpf.\n> event `- Event name - exactly what is given to `#fire() when triggering\n  an event.\n> args `- Zero or more underscores (`'_); if present, the handler gets\n  called only if `'event was given that exact number of arguments (it's\n  not possible to match zero arguments).\n\n  For example, `'eve__ registers a handler that is called for\n  `[fire('eve', [1, 2])`] but is not called for `[fire('eve', [1])`] or\n  `[fire('eve', [1, 2, 3])`].\n\n  In case of `'=event (overriding handler), if argument count differs then\n  all handlers superseded by this one get called while the superseding\n  handler itself is not called (as if the superseding handler was just\n  `[return sup(this, arguments)`]).\n\n  Generally, usage of `'args is frowned upon because of its unintuitive\n  nature - see `#argDanger.\n\n##evtpf Event prefixes\n\n> none evArgs... `- Add new handler `*after`* existing handlers. It\n  neither receives the current event result nor it can change it (the\n  handler's return value is ignored). This form is used most often and\n  it's perfect for \"attaching\" extra behaviour to the end of the original\n  code, retaining the original result.\n> - evArgs... `- Add new handler `*before`* existing handlers of the same\n  priority, otherwise identical to \"no prefix\".\n> + `*res`*, evArgs... `- Add new handler after existing handlers. It\n  receives the current `*event return value`* (`'res) and can change it if\n  the handler returns anything but `'undefined.\n> = `*sup`*, evArgs... `- `*Wrap around`* existing handlers - they are\n  removed, regardless of their priority (own priority of `'= sorts it in\n  relation to non-`'= handlers added later). It receives a callable `'sup\n  of form `[function (this, args)`] which it may call or not (alike to\n  calling `'super in Java). `[sup.name`] equals plain event name, handy\n  with comma notation. If it returns `'undefined the current event return\n  value is unchanged.\n\n  First argument of `'sup is the context (normally the object that\n  initiated the event, i.e. the handler's own `'this). Second argument is\n  an array of arguments the overridden handlers receive. The handler may\n  change these arguments to trick the underlying (wrapped) handlers into\n  believing the event received a different set of data or it can pass the\n  `'arguments object that the handler itself has received - in this case\n  `[args[0]`] (which is `'sup) is removed and the rest is given to the\n  underlying handlers.\n\n  `? `[\n       // sup.name == 'someEvent'.\n       '=someEvent': function (sup, a1, a2) {\n         // Passes original context and arguments unchanged.\n         return sup(this, arguments)\n         // Identical to above but longer - sup() removes itself from the\n         // first argument.\n         return sup(this, _.rest(arguments))\n         // Not identical to above - if event was given >2 arguments they\n         // will be omitted here but passed as is by above.\n         return sup(this, [a1, a2])\n         // Changes first argument and omits 3rd and other arguments (if\n         // given).\n         return sup(this, [1, a2])\n         // Gives no arguments at all to the underlying handlers.\n         return sup(this)\n         // Passes sup verbatim because removal doesn't happen for array.\n         return sup(this, [sup])\n       },\n     `]\n\n  Note: old handlers are not technically \"removed\" - they are kept around\n  and restored if the `'=wrapping handler is removed so treat this prefix\n  like any other. It can be even used with `#once():\n  `[\n    sqim.once('=update', function () { alert('Holding tight!') })\n    sqim.update()   // alerts\n\n    // Old 'update' handlers are now restored.\n\n    sqim.update()   // no more alerts\n  `]\n\n  This works even if more handlers were added to the event after wrapping:\n  `[\n   sqim.on('-update', ...)\n     // 1 handler\n   var id = sqim.on('=update', ...)\n     // 1 handler - '-update' superseded\n   sqim.on('update', ...)\n     // 2 handler2: ['=update', 'update']\n   sqim.off(id)\n     // 2 handler2: ['-update', 'update'] - '=update' removed\n  `]\n\n  Warning: don't pass a wrong `'this by accident, as when `'=overriding\n  from an outside object using `#on()/`#fuse() with a `'cx:\n  `[\n    sqim.on('=foo', function (sup) {\n      // Likely an error: this in '=foo' is not sqim.\n      sup(this, arguments)\n    }, this)   // <- note explicit context\n  `]\n\n  Wrapped handlers are sorted by their priorities, as usual. However,\n  their out-of-batch marks (leading `[^`]) have no use because the main\n  handler determines when/if they are called.\n  `[\n    sqim.on('foo', ...)       // (1)\n    sqim.on('^=foo', ...)     // (2)\n      // (1) is never called by itself; if (2) calls its sup() immediately\n      // then (1) will be processed out-of-batch\n\n    sqim.on('^foo', ...)      // (3)\n    sqim.on('=foo', ...)      // (4)\n      // the opposite: (4) forces (3) to be called in-batch, if called at all\n  `]\n\n It's impossible for a handler to set the event's result to `'undefined as\n it is considered a \"keep current result\" marker. This can be worked\n around using `'eobj.`#post whose result is taken literally:\n[\n   sqim.fuse('event', new Function)\n     .post = function (eobj, res, args) { return undefined }\n]\n\n#argDanger The danger of ev__\n\n In JavaScript, functions accept extra arguments with ease; often you\n would provide an iterator and only care for some of its arguments.\n However, if using the `'ev__ form (underscores are the `'args part of\n `#evtref) then the event must have been given that `*exact`* number of\n arguments even if none of its handlers uses the rest:\n[\n   var MySqimitive = Sqimitive.Base.extend({\n     accessor: function (prop, value) {\n       if (arguments.length == 1) {\n         return this._foo[prop]\n       } else {\n         this._foo[prop] = value\n         return value\n       }\n     },\n   })\n\n   var sqim = new MySqimitive\n   // This handler should always be called when a property is being\n   // set... right?\n   sqim.on('accessor__', function (prop, value) {\n     alert('Now ' + prop + ' is ' + value)\n   })\n\n   // Alerts \"Now name is val\". So far so good.\n   sqim.accessor('name', 'val')\n\n   var propsToSet = {prop: 'foo', bar: 123}\n   // map() calls sqim.accessor() for every key in propsToSet and\n   // properties are indeed properly set - but no alerts appear! This is\n   // because map() passes 3 arguments to the iterator: value, key and\n   // the list itself (object in our case). Therefore even if accessor()\n   // uses just 2 of these arguments (like it does above) the actual\n   // event fired is \"accessor___\" (3 underscores), not \"accessor__\" (the\n   // one we've hooked).\n   _.map(_.invert(propsToSet), sqim.accessor, sqim)\n]","start":{"line":2700,"column":4,"offset":103841},"end":{"line":2714,"column":4,"offset":104315},"forced":null,"modifiers":[],"file":"main.js"},"953":{"type":"func","id":953,"name":"once","comment":"! `, +fna=function ( event, [retainer,] func[, cx] )\n\n#+tag_Events\n* `@Core.once()`@\n#\n\n Regsiters a single one-shot event handler that removes itself as soon as\n `'func returns non-`'retainer (or after the first call).\n\n In all other aspects `#once() is identical to `#on() with the string\n argument, i.e. `[on(event, func, cx)`]. Returns new event ID suitable for\n `#off() so you can unregister it before it's called (or during or after -\n nothing will happen). Doesn't allow registering multiple events/handlers\n in one call.\n\n?`[\n   sqim.once('+normalize_foo', () => 123, this)\n   sqim.off(this)   // removes the above hook, along with others of this\n   sqim.once('=render', () => { /* skips one call, keeps event's result */ })\n\n   sqim.once('change_visible', null, now => now ? this.update() : null)\n     // Returns null until sqim._opt.visible becomes truthy, retaining\n     // the handler. Then returns result of update() and unhooks.\n     // In any case, the hook's result is ignored because of no event prefix.\n `]\n\n> event string\n> retainer mixed except string, function, NaN (not comparable)`, omitted\n  `- compared using `[===`], acts as event result if returned; typical\n  choices are `'undefined, `'null, `'true and `'false\n> func string`, function\n#-onOnce\n\n If the handler somehow gets called again after it should not have been,\n or if `'event occurs again while running (reenters), or if `'func throws\n - the handler returns `'undefined without calling `'func and unbinds.\n This is in line with `@no@once`@().","start":{"line":2753,"column":4,"offset":106074},"end":{"line":2782,"column":4,"offset":106815},"forced":null,"modifiers":[],"file":"main.js"},"955":{"type":"func","id":955,"name":"autoOff","comment":"! `, +fna=function ( [sqim [, events [, cx]]] | func [, cx] )\n\n#+tag_Events\n* `@Core.autoOff()`@\n#\n\n A utility method for tracking object connections.\n\n[\n  this.autoOff(sqim, {})          // add sqim to the list\n  this.autoOff(sqim, {foo: ...})  // ...and hook some events; cx = this\n  this.autoOff(sqim, ['foo', ...])        // equivalent\n  this.autoOff(sqim, {foo: ...}, null)    // ...cx = sqim\n  this.autoOff(sqim, {foo: ...}, other)   // ...cx = other\n\n  this.autoOff()      // off() all sqims tracked so far and clear the list\n  this.autoOff(sqim)  // off() and un-list sqim, only if it was tracked\n  this.autoOff(sqim, true)  // just un-list sqim, keep hooks on it\n\n  // Iterate over tracked objects:\n  var found = this.autoOff(sqim => sqim.get('foo'))\n]\n\n ` `#autoOff() has three main forms - tracking, untracking and iterating:\n* Adding `'sqim (an object) to this object's `'Set of tracked objects\n  (`'_autoOff), optionally hooking `'events on it - returns `'sqim.\n* Removing all objects from this list and hooks of `'this on them -\n  returns `'this.\n* Removing one object, optionally with hooks of `'this on it - returns\n  `'sqim.\n* Iterating over objects in this list - calls `'func for every object\n  until it returns a value that is not `'undefined or `'null; `#autoOff()\n  returns this value, or last `'func's result, or `'undefined if the list\n  was empty.\n\n The list is not used by Sqimitive but your application can use it to\n unbind all listeners added by this object to other objects in one go. For\n example, you can do `[this.autoOff()`] when `'this is about to be\n destroyed so that events on other objects to which `'this had any\n connections won't trigger its handlers.\n\n `'events, if given and non-`'true, is an object in `#on() format (keys\n are comma-separated event references and values are their handlers -\n `#expandFunc()) or an array (hooked in order): `[['evt', func, 'evt2',\n func2, ...]`]. Commas in event references are allowed even though `#on()\n only accepts them when `#fuse'ing.\n\n With `'events, `'cx sets the context in which handlers will be called. If\n `'cx is `'null then `'sqim is used, if no `'cx argument is given then\n `'this is used (i.e. the object on which `#autoOff() was called).\n `'sqim's `#on() always receives `'cx of `'this.\n\n Other notes:\n* `#autoOff() can be called multiple times for one object. This will cause\n  problems only if supplying the same `'events (hooks will be added\n  twice); doing just `[autoOff(sqim, {})`] twice is fine, and duplicates\n  won't inflate the list because it's a `'Set.\n* The form `[autoOff(sqim)`] doesn't call `#off() if `'sqim wasn't tracked\n  (better for performance). This works if the code doesn't manually set up\n  hooks (`#on()) on objects-to-be-`#autoOff'd, which is recommended. If it\n  does, do `[this.autoOff(sqim).off(this)`] or `[this.autoOff(sqim, {})`]\n  and later `[this.autoOff(sqim)`].\n* It's safe to call `#autoOff() from within `'func to track or untrack\n  objects - `'func will receive each object exactly once. Re-tracking the\n  same object until the iterating `#autoOff() returns will call `'func\n  twice for that object (`'Set's behaviour). From `'func, calling\n  `#autoOff() without arguments will call `'func for every object\n  remaining to be iterated over before that call to `#autoOff() was made,\n  regardless of subsequent `#autoOff() calls.\n#-chevaoff\n\n?`[\n   // Track sqim and hook sqim.remove (calls this.remove):\n   this.autoOff(sqim, {remove: this.remove})\n\n   // Equivalent:\n   this.autoOff(sqim, {remove: 'remove'})\n\n   // Track and hook 2 events (both call sqim.render - not this.render!):\n   this.autoOff(sqim, {'change_foo, change_bar': 'render'}, null)\n\n   // Set up a one-time listener that is removed either when sqim fires\n   // 'loaded' or this calls autoOff() (typically happens in remove()):\n   var ev = this.autoOff(sqim, {}).once('loaded', 'render', this)\n   // ...It's also possible to stop listening at any time:\n   this.cancel = () => sqim.off(ev)\n\n   // Be sure to pass correct cx to on/once for autoOff's off() to work:\n   autoOff(sqim, {}).once('loaded', 'render')         // WRONG\n   autoOff(sqim, {}).once('loaded', 'render', sqim)   // CORRECT\n\n   // Unbind this instance's events from all sqimitives previously\n   // enlisted by this.autoOff(sqim, {}) and clear the tracking list:\n   this.autoOff()\n\n   // Unbind from and unlist just one sqimitive:\n   this.autoOff(sqim)\n\n   // Conditionally untrack some objects:\n   this.autoOff(function (sqim) { sqim.get('foo') && this.autoOff(sqim) })\n\n   // Build an array from tracked objects:\n   var filtered = []\n   this.autoOff(function (sqim) {\n     if (sqim.get('foo')) {\n       filtered.push(sqim)\n     }\n   })\n `]\n\n? Array form of events is convenient when keys are not constants:\n  `[\n    this.autoOff(sqim, ['change_' + prop, 'render', name, 'update'])\n\n    // Could be done with computed names in ES6 but it's often longer:\n    this.autoOff(sqim, {['change_' + prop]: 'render', name: 'update'})\n\n    // Equivalent to manual object construction:\n    var events = {}\n    events['change_' + prop] = 'render'\n    events[name] = 'update'\n    this.autoOff(sqim, events)\n  `]\n\n? Canonical usage:\n  `[\n   var MyNotifyBar = Sqimitive.Base.extend({\n     events: {\n       owned: function () {\n         this.autoOff(new View.LoginForm, {\n           loggedIn: function () { alert('Hi there!') },\n           '-multiple, events': ...,\n         })\n       },\n\n       // WRONG: if unnest() is called with any arguments (for whatever\n       // the reason) then autoOff()'s behaviour would change and it will\n       // not untrack objects. See the note on ev__ danger in on().\n       //'-unnest': 'autoOff',\n\n       // WRONG: ES6 'this' is bound to whatever context is calling\n       // extend(), see #es6this:\n       '-unnest': () => this.autoOff(),\n\n       // CORRECT:\n       '-unnest': function () {\n         this.autoOff()\n       },\n\n       // CORRECT: masked version:\n       '-unnest': 'autoOff-',\n     },\n   })\n  `]\n\n  Gotcha with the above usage: if you hook using `#autoOff() in `'init()\n  then those hooks will be removed as soon as the sqimitive is nested\n  anywhere because `@Base.nestEx()`@ calls `#unnest(). Consider hooking in\n  `#owned() if the class is guaranteed to become nested prior to actual\n  usage, or check for set `#_parent in `'-unnest before calling\n  `#autoOff().\n\n As a general rule, `#autoOff() is not used for permanently connected\n objects, i.e. ones that are destroyed at the same time as `'this. Such\n objects are typically set to \"_protected\" properties and `#init'ialized\n during construction:\n[\n   var MyGame = Sqimitive.Base.extend({\n    // Created together with MyGame and only referenced by MyGame:\n     _timer: null,\n\n     events: {\n       init: function () {\n         this._timer = new MyTimer({interval: 1000})\n         this._timer.on({expired:  () => alert(\"Time's up!\")})\n           // on() instead of autoOff({expired: ...})\n       },\n     },\n   })\n]\n\n? `#autoOff() only really calls `'on and `'off methods on `'sqim and can\n  be used with non-sqimitives if their signatures are compatible. For\n  example, jQuery's are partially compatible: `@jq:on`@() is usable (it\n  ignores `'cx but you can `'bind() or use ES6 arrow functions) while\n  `@jq:off()`@ is not:\n  `[\n    // Tracking:\n    this.autoOff($('body'), [\n      'onclick.' + this._cid,\n      // Need to bind() or use => as jQuery doesn't accept context object.\n      function (e) {\n        this.clicked(e.target)\n      }.bind(this),\n    ])\n\n    // Untracking:\n    this.autoOff(function (el) {\n      if (el instanceof $) {\n        el.off('.' + this._cid)\n        // Giving true removes object from the list without calling off().\n        this.autoOff(el, true)\n      }\n\n      // Or, one-liner:\n      ;(el instanceof $) && this.autoOff(el, true).off('.' + this._cid)\n    })\n  `]\n\n#-unnestedoff\n Because of this, there's no need to track and explicitly unsubscribe from\n children (regardless of `#_owning):\n[\n   var MyClass = Sqimitive.Base.extend({\n     events: {\n       init: function () {\n         var child = this.nest(new MyClass.Child)\n         this.autoOff(child, {changed: 'recalc'})\n       },\n\n       unnested: function (sqim) {\n         this.autoOff(sqim)\n       },\n     },\n\n     recalc: ...\n   })\n]\n The above is redundant and can be simplified, provided that the context\n given to `'on() is `'this as below:\n[\n   var MyClass = Sqimitive.Base.extend({\n     events: {\n       init: function () {\n         var child = this.nest(new MyClass.Child)\n         // this (_parent) will call off(this) on child when child is unnested().\n         child.on('changed', 'recalc', this)\n       },\n     },\n\n     recalc: ...\n   })\n]\n If you are hooking all children then use `#_childEvents to further\n simplify the task:\n[\n   var MyGame = Sqimitive.Base.extend({\n     _childEvents: ['changed'],\n\n     events: {\n       '.changed': 'recalc',\n     },\n\n     recalc: ...\n   })\n]\n\n# Garbage collection\n ` `#autoOff() prevents `'sqim from being garbage-collected by creating a\n reference from `'this to `'sqim. (`'WeakSet would be a solution if only\n it supported enumeration.)\n\n Normally, `[sqim.on(..., this)`] results in a reference to `'this being\n stored in `'sqim so that if `'sqim is not referenced anywhere else (e.g.\n it is not `#nest'ed) then it will be freed even if `'this remains alive.\n\n However, `#autoOff() additionally lists `'sqim in the `'_autoOff `'Set of\n `'this, creating a two-way link; now both `'sqim and `'this may only be\n freed together. Imagine a long-term \"server\" object (`'this) and\n short-term \"clients\" (`'sqim): `'this-server `#autoOff()-s (tracks) new\n `'sqim-client, then `#unnest()-s the latter at some point. Even though\n clients are not referenced anywhere except server's `'_autoOff, they will\n be kept alive until the server itself is destroyed.\n\n Addressing this is application-specific but one common way is to hook\n `'sqim's `#unnest (or `@Base.remove()`@) and remove it from `'_autoOff\n (`'this = server):\n[\n  this.autoOff(client, {\n    ...,\n    remove: function () {\n      this.autoOff(client)\n    },\n  })\n]","start":{"line":3069,"column":4,"offset":118652},"end":{"line":3125,"column":4,"offset":120295},"forced":null,"modifiers":[],"file":"main.js"},"959":{"type":"func","id":959,"name":"fuse","comment":"! `, +fna=function ( event, func[, cx] )\n\n#+tag_Events\n* `@Core.fuse()`@\n#\n\n Registers a single permanent event handler.\n\n Unlike with `#on() and `#once(), this handler cannot be removed with\n `#off().\n\n> event string `- a single event reference (no comma notation)\n> func function`, string `- masked method name (`#expandFunc())\n> cx object`, null/omitted use `'this `- the context for `'func\n\n= object `- an internal event registration object (`'eobj) that should be\n  discarded\n\n ` `#fuse() is a low-level method. You are advised to call `#on({event})\n instead.\n\n?`[\n   sqim.on({\n     something: function () { ... },\n     someone: function () { ... },\n   })\n\n   // Identical to the above:\n   sqim.fuse('something', function () { ... })\n   sqim.fuse('someone', function () { ... })\n\n   // A masked callback - receives (a1, a2, a3), passes (a3, a1, a1, a1)\n   // to sqim.meth().\n   sqim.fuse('somewhere', 'meth-3111', sqim)\n `]\n\n#post The `'post callback\n One case when `'eobj can be accessed is to assign its `'post key (this is\n considered advanced usage). If set to a function, `#::fire() calls\n `[post(eobj, res, args)`] after executing the handler (`'func), within\n the handler's `'cx. `'post must return the new result (replaces `'res in\n any case - even if `'undefined and regardless of `#evtpf). `'args is the\n event's arguments, an array-like object (possibly `'Arguments). If `'post\n sets `[eobj.stop`] to `'true then remaining handlers are skipped. `'post\n is only called along with its associated handler and not called, for\n example, if it was attached to a `'=wrapped hook that was `#off'ed, or to\n a hook with mismatching arguments (`'ev__, see `#argDanger).\n\n?  See the source code of `@Sqimitive\\Async`@ for a practical example on\n   `'post.\n\n  `[\n    var sqim = new Sqimitive.Base\n\n    sqim.on('+event', function () {\n      console.log(1)\n      return 'test'\n    })\n\n    var eobj = sqim.fuse('event', function () {\n      console.log(2)\n    }, this)\n\n    eobj.post = function (eobj, res, args) {\n      console.log(3)\n      eobj.stop = true\n      return res.toUpperCase()    // res is 'test', args is []\n    }\n\n    sqim.on('event', function () {\n      console.log(4)\n    })\n\n    sqim.fire('event')      //=> 'TEST'\n      // console logs: 1, 2, 3 but not 4\n  `]\n\n#-fireOverride","start":{"line":3205,"column":4,"offset":123065},"end":{"line":3252,"column":4,"offset":124968},"forced":null,"modifiers":[],"file":"main.js"},"962":{"type":"func","id":962,"name":"off","comment":"#+tag_Events\n* `@Core.off()`@\n#\n\n Removes non-`#fuse()'d event listener(s).\n\n= this\n\n `'key can be one of:\n> string event name `- like \"render\"; removes all listeners to that event\n> number listener ID `- as returned by `#on(); removes that particular\n  listener from that particular event\n> object context `- the `'cx to which listeners were registered; removes\n  all listeners to all events with that context\n> array `- containing any of the above values including more sub-arrays;\n  identical to multiple `#off() calls\n\n Does nothing if no matching events, contexts or listeners were found\n (thus safe to call multiple times).\n\n When unregistering a wrapping handler (`'=event, see `#evtpf) its\n underlying handlers are reinserted into the list of handlers (\"undoing\"\n method override) maintaining priority (`#evtref) but not necessary the\n original order (calls to `#on()).\n\n See `#evt for a nice example on this subject and `#once() for attaching\n one-shot listeners.\n\n?`[\n   // key = 'evtname' | 12345 | {cx} | [key, key, ...]\n\n   var id = sqim.on('=superseded', function () { ... }, this)\n   sqim.off(id)\n   sqim.off('superseded')\n   sqim.off(this)\n\n   // Just like the above 3 calls:\n   sqim.off([id, 'superseded', this])\n `]\n\n#-unnestedoff","start":{"line":3386,"column":4,"offset":130082},"end":{"line":3411,"column":4,"offset":130863},"forced":null,"modifiers":[],"file":"main.js"},"965":{"type":"func","id":965,"name":"_forward","comment":"#+tag_Events\n* `@Core._forward()`@\n#\n\n Forwards `'events occurring on `'sqim to `'this, with arguments\n `'prepend'ed.\n\n= `'sqim\n\n Forwarding is done by firing \"prefix + event_name\" on `'this (the object\n on which `#_forward() is called) with `'prepend (`[[sqim]`] if omitted)\n pushed in front of original event's arguments. `'event_name is a complete\n reference string as given to `#parseEvent(), e.g. `[=foo_`].\n\n ` `#_forward() is used to set up `#_childEvents, with the `'prefix of\n `[.`].\n\n?`[\n   d._forward('.', ['render'], o)\n   d.on('.render', function (o) { alert(o._cid) })\n    // now whenever 'render' is fired on o, '.render' is fired on d where\n    // it shows the _cid of the object where the original 'render' occurred\n `]\n\n?`[\n   destination._forward('dlg-', ['change', '-render'], origin, [])\n `]\n  This example fires `[dlg-change`] and `[dlg--render`] events on\n  `'destination (a Sqimitive) whenever `'change and `'render are fired on\n  `'origin, keeping original arguments. `'-render simply means the\n  forwarded events occur on `'destination before other handlers of\n  `'origin are executed, as per `#evtpf.","start":{"line":3510,"column":4,"offset":134815},"end":{"line":3522,"column":4,"offset":135248},"forced":null,"modifiers":["protected"],"file":"main.js"},"966":{"type":"func","id":966,"name":"_batchOptions","comment":"! `, +fna=function ( id [, options] )\n\n#+tag_Options\n* `@Core._batchOptions()`@\n#\n\n Returns information about currently active `#batch() for use in batched\n events.\n\n= object cloned `'options with extra keys\n> id number `- active batch's identifier as given to `#batch()'s `'func\n> object object `- optional keys to merge into result (batch-specific keys\n  override them)\n\n Call `#_batchOptions() once for each \"operation\" when adding custom\n `#batch events, then pass the result to all operation's events (e.g.\n `#ifSet() gives both `#change_OPT and `#change the same options object).\n\n You may pass the same object to all events of the same operation (to\n allow clients persist data across related events) or you may clone it (to\n avoid interference) - but never pass it to events of different operations\n or batches.","start":{"line":3546,"column":4,"offset":136208},"end":{"line":3585,"column":4,"offset":138036},"forced":null,"modifiers":["protected"],"file":"main.js"},"972":{"type":"func","id":972,"name":"batch","comment":"! `, +fna=function ( sqims, func [, cx] )\n\n#+tag_Options\n* `@Core.batch()`@\n#\n\n Calls `'func and defers certain events it has produced on `'this and\n `'sqims until `'func returns.\n\n ` `#batch() is the backend used in Sqimitive to defer `#change and\n `#change_OPT events produced by `#ifSet() (and its `#set() wrapper).\n Clients may use it for other events.\n\n= mixed as returned by `'func\n> sqims null`, array `- sqimitives to defer and to share the same batch ID\n  with. If array, fails if `'this or any `'sqims has an active batch.\n  First member is ignored if it's `'this. If you need several sqimitives\n  to be batched but don't require special effects of having them in one\n  batch, do nested `#batch() calls with `'sqims of `'null.\n> func `- Receives current batch `'id. May push to `[sqim._batch`].\n> cx object`, null/omitted use `'this `- the context for `'func\n\n Some options may be related so that changing one causes a refresh based\n on values of other options. For example, 2D coordinates consist of `'x\n and `'y; `#set()'ing them one by one (e.g. first `'x, then `'y) will\n cause multiple refreshes but only the last will use actual (new) values\n and others may use partially updated state (resulting in an object moving\n from `'x1/`'y1 to `'x2/`'y1, then to `'x2/`'y2 rather than straight to\n `'x2/`'y2). `#batch() groups `#change events and fires them after setting\n all values instead of after setting each value.\n\n Once `'func returns, the batch ends and `#batch() starts dispatching the\n events. During this process, if a hook on a `#change event (generated by\n `'func) creates a new batch, that batch's events will be dispatched after\n events of the current batch. Therefore, `#batch() may return much later\n than `'func as there may be numerous pending batches.\n\n Special fields in `'options of batched events (added by\n `#_batchOptions()):\n> batch array `- events in the batch being dispatched, in `[this._batch`]\n  format; custom `'eventIndex property points to the entry handled by the\n  current `'^ handler (`#naor); for regular non-`'^ handlers it's `'null\n  and `'batch itself omits already fired events (current event is the\n  first member hence `'batch is never empty); can be mutated except for\n  the current member (`'eventIndex'th if `'^, else 0); doesn't include\n  events of the later pending batches\n> batchID int `- a `#unique batch ID; tells if two `#change events\n  originated from the same `'func\n> batched array of [sqim, batch] `- `'this and `'sqims given to the \"main\"\n  `#batch(), with their respective `'batch arrays\n\n  From inside a `#change listener, each `'batched member can be classified\n  as a sqimitive that:\n  `* ...is currently firing batched events (always exactly one such member\n     per `'batched; its batched array is `[=== options.batch`])\n  `* ...has finished firing events of this `'batchID (batched array is\n     empty; do not change it, the batch won't \"resume\")\n  `* ...is yet to start firing batched events (after the current\n     `[options.batch`] becomes empty)\n> operationID int `- a `#unique identifier of the event group; tells if\n  events originated from the same `#ifSet() call\n> trace str`, null `- set to the stack trace of the batch entry's creation\n  if `@Core.trace`@ was enabled\n\n Other notes:\n* Given two members (`'sqims) of the same batch, `[options.batchID`] of\n  their `#change events are equal but `[sqim._batch`] are equal only for\n  events of the same sqimitive (IDs are shared but `'_batch instances are\n  not).\n* Any combination of recursive `#set()/`#batch() is allowed. `#batch()\n  inside a `#batch() just calls `'func (or fails depending on `'sqims).\n  `#batch() after `'func (i.e. by a hook on a `#change) defers events to a\n  new group dispatched after the original `'func's events are done.\n* An exception in any `#change handler drops all pending events, both of\n  the same batch and of pending batches.\n* Batched events across multiple `'sqims are dispatched not in order of\n  their operation calls (e.g. `'O1 on `'sqim1, `'O2 on `'sqim2, `'O3 on\n  `'sqim1) but in groups per each member of `'sqims, starting from the\n  last one (`'O2 on `'sqim2, `'O1 on `'sqim1, `'O3 on `'sqim1). Order\n  within a group is guaranteed but order of groups is an internal detail\n  that should not be relied upon.\n\n? Consider an object with `'width and `'height `@Base._opt`@'ions bound to\n  a DOM node:\n  `[\n  var Rect = new Sqimitive.jQuery.extend({\n    _opt: {width: 0, height: 0},\n    events: {\n      change_width: '_recalc',\n      change_height: '_recalc',\n    },\n    _recalc: function () {\n      var w = this.get('width')\n      var h = this.get('height')\n      this.el.css({width: w, height: h})\n    },\n  })\n  `]\n  Calling `#set() would trigger two pairs of events:\n  `[\n  var obj = new Rect\n  obj.set('width', 10)\n    // fires change_width and change\n    // obj's options = {width: 10, height: 0}\n    // el's size = 10*0\n  obj.set('height', 20)\n    // fires change_height and change\n    // obj's options = {width: 10, height: 20}\n    // el's size = 10*20\n  `]\n  As seen, `'el would undergo two dimension changes of which the first is\n  redundant because after `'width the caller immediately supplies\n  `'height. In contrast, doing so in a `#batch:\n  `[\n   obj.batch(null, function () {\n     obj.set('width', 10)\n     obj.set('height', 20)\n   })\n     // fires change_width, change, change_height, change - all after\n     // the batch'ed function returns; change_width sets el's size to\n     // 10*20, as does change_height\n  `]\n  There are still two dimension changes (`'_recalc calls) but the second\n  sets the same size and is optimized by the browser.\n\n  If `'_recalc were doing heavy calculations, it could skip them by using\n  an internal option like so:\n  `[\n  var Rect = new Sqimitive.jQuery.extend({\n    _opt: {width: 0, height: 0, _recalced: ''},\n    events: {\n      change_width: '_ifRecalc',\n      change_height: '_ifRecalc',\n      change__recalced: '_recalc',\n    },\n    _ifRecalc: function () {\n      this.set('_recalced', this.get('width') + '*' + this.get('height'))\n    },\n    _recalc: function () { /* as above */ },\n  })\n  `]\n\n? Demonstration of batch ID:\n  `[\n    me.on('change', function (name, now, old, options) {\n      console.log(name + ' during batch ' + options.batchID)\n    })\n\n    me.set('foo', 123)      //=> foo during batch 1 (implicit batch)\n    me.set('foo', 456)      //=> foo during batch 2 (implicit batch)\n\n    me.batch(null, function () {\n      me.set('foo', 789)    //=> foo during batch 3\n      me.set('bar', 123)    //=> bar during batch 3\n    })\n\n    me.batch(null, function () {\n      me.set('bar', 456)    //=> bar during batch 4\n    })\n  `]\n  Batch-after-batch:\n  `[\n    me.on('change_foo', function () {\n      me.set('bar', 456)\n    })\n\n    me.batch(null, function () {\n      me.set('foo', 123)    //=> foo during batch 1\n    })\n      // Logged after func returns but before batch() returns:\n      //=> bar during batch 2\n  `]\n  Nested `#batch() vs `'sqims and `'null `'sqims vs array:\n  `[\n    me.batch(null, function () {\n      you.batch(null, function () {\n        me.set('foo', 123)    // options.batchID == 1\n        you.set('bar', 456)   // options.batchID == 2 (different)\n      })\n    })\n\n    me.batch([you], function () {\n      me.set('foo', 123)      // options.batchID == 3\n      you.set('bar', 456)     // options.batchID == 3 (same)\n    })\n\n    me.batch([], function () {\n      me.batch([], ...)       // throws - a batch already active on me\n    })\n  `]\n\n#naor \"Natural\" order\n Normally, `#batch() calls accumulated events in order of changes so that\n last change dispatches its events last while events in response to a\n batch (by hooks on events it's dispatched) are fired after that batch's\n own events.\n\n To illustrate the issue, consider this class:\n[\n    Sqimitive.Base.extend({\n      _opt: {\n        original: '123',\n        linked: null,\n      },\n\n      events: {\n        change_original: function (now) { this.set('linked', now) },\n        change: function (opt) { console.log('change of ' + opt) },\n      },\n    })\n]\n\n When calling `[set('original', 'new')`] on such an object, logically you\n would expect these events: `'change_original, `'change of `'original,\n `'change_linked, `'change of `'linked. However, with a naive\n implementation handling `'change_original would trigger `'change_linked,\n then `'change of `'linked and only then - `'change of `'original.\n\n This would be also a problem if changing the same option from within its\n own event handler because `'change with the new value would be fired\n first (since `#set() was called last), then when the original `#set()\n returns it would also fire `'change but this time with the original (now\n old!) value.\n\n Notwithstanding, rarely a handler must be notified of the change\n immediately (sort of \"out of band data\"). `#batch() calls listeners whose\n event name starts with `'^ immediately after `'func returns, even if\n there are events of earlier-created batches yet to be dispatched. While\n normal listeners can be seen as an asynchronous event bus, `'^ are closer\n to direct function calls.\n\n For example, let's assume two objects: one an array of 2D points, another\n its index (array of points on the given Y axis). The index must be kept\n in sync so that clients accessing it at any point in time see no\n discrepancies with the main array (the only exception we allow is inside\n the same `#batch() `'func).\n\n[\n    var Points = Sqimitive.Base.extend({\n      points: [],\n\n      add: function (point) {\n        this.points.push(point)\n        this.batch(null, id => this._batch.push(['added', point]))\n      },\n\n      added: Sqimitive.Core.stub,\n    })\n\n    var Index = Sqimitive.Base.extend({\n      byY: {},\n\n      events: {\n        init: function (opt) {\n          this.autoOff(opt.points, {\n            added: '_added',\n            //'^added': '_added',\n          })\n        },\n      },\n\n      _added: function (point) {\n        (this.byY[point.y] || (this.byY[point.y] = [])).push(point)\n      },\n    })\n\n    var points = new Points\n    var index = new Index({points})\n    points.add({x: 0, y: 0})\n      // index.byY = {0: [{...}]}\n    points.add({x: 1, y: 1})\n      // index.byY = {0: [{...}], 1: [{...}]}\n]\n\n The above implementation works but at the first glance only:\n[\n    var points = new Points\n    var index = new Index({points})\n\n    points.on('change_foo', function () {\n      console.dir(index.byY)      // (1)\n      points.add({x: 2, y: 2})\n      console.dir(index.byY)      // (2)\n    })\n\n    points.add({x: 0, y: 0})\n    points.set('foo', 123)\n    console.dir(index.byY)        // (3)\n]\n\n Both (1) and (2) output the same result: `[{0}`] while (3) outputs\n `[{0, 2}`]. Why output of (2) is the same as of (3)? Because `#ifSet()\n uses `#batch, it delays dispatching events of other batches (`'added in\n our case) until its own events are finished. `'change_foo calls `'add()\n which creates a `#batch (queued after the currently executing `#ifSet's\n batch) and pushes `'added to it (to be dispatched after `[set('foo')`]\n returns, hence (3) showing expected result). In contrast, if `'Index\n hooks `['^added'`] then it becomes exempt from this delay and causes\n `'_added() to be called after `[points.add({x: 2, y: 2})`] returns (or,\n precisely, upon returning from `'func `[id => ...`] given to `'batch()\n inside `'add()) and the index to be updated.\n\n `'^ makes it \"closer\" to direct function call but not exactly that: such\n handler is called once the batch closes (`'func returns), not once a\n corresponding event if queued (\"function is called\"). Below, `'add() runs\n inside an already active batch so no index update takes place then:\n[\n    points.batch(null, function () {\n      points.add({x: 3, y: 3})\n        // points._batch = [['added', {x: 3, y: 3}]]\n      console.dir(index.byY)\n        //=> {}\n    })\n    console.dir(index.byY)\n      //=> {3: [{...}]}\n]\n\n `'^ has no special meaning for dispatching initiated by `#fire() and,\n consequently, in `[=`]wrapped handlers (`#evtpf; compare `'eventIndex\n with `'null to determine the phase).\n\n `'^ separates firing into two groups which are then ordered by priority.\n This means that in response to a `#batch, `[^0^event`] will run before\n `[-1^event`] even though the latter has lower priority.\n[\n    sqim.on('^0^event', () => console.log(0))\n    sqim.on('-1^event', () => console.log(-1))\n\n    sqim.fire('event')      // outputs -1, 0\n\n    sqim.batch(null, function () {\n      this._batch.push(['event'])\n    })    // outputs 0, -1\n]\n\n# Custom events\n You can defer arbitrary events from within `'func by pushing an array to\n `[sqim._batch`], with first member being event name and others being its\n arguments. Because `'sqims is rarely used, `'sqim here is typically\n `'this.\n\n For consistency with Sqimitive's `#ifSet(), provide hooks with\n information (`#_batchOptions()) about the current batch.\n\n[\n  this.batch(function (id) {\n    this._batch.push(['firstOff', 'pa', 'ra', 'ms'])\n    // Or, better:\n    var options = {batch: this._batch, batchID: id, operationID: Core.unique('o')}\n    this._batch.push(['firstOff', 'pa', 'ra', 'ms', options])\n    // Or, best:\n    this._batch.push(['firstOff', 'pa', 'ra', 'ms', this._batchOptions(id)])\n  })\n    // does fire('firstOff', ['pa', 'ra', 'ms'...]) when func returns\n]\n\n Once batched events start firing, the batch is considered \"closed\". This\n typically means that `'_batch will no longer change, allowing heavy\n update functions to process all batched events as one unit in response to\n the first event such a function is interested in, remembering its batch\n ID and ignoring subsequent events with the same ID. Remembering the ID\n might be simpler than maintaining a hash of current state (`'_recalced)\n as in the earlier `'Rect example:\n `[\n  var Rect = new Sqimitive.jQuery.extend({\n    _opt: {width: 0, height: 0},\n    _lastBatch: 0,\n    events: {\n      change_width: '_ifRecalc',\n      change_height: '_ifRecalc',\n    },\n    _ifRecalc: function (now, old, options) {\n      if (this._lastBatch != options.batchID) {\n        this._lastBatch = options.batchID\n        this._recalc()\n      }\n    },\n    _recalc: function () {\n      var w = this.get('width')\n      // ...\n    },\n  })\n `]\n Or the ID itself may be seen as a kind of hash:\n `[\n  var Rect = new Sqimitive.jQuery.extend({\n    _opt: {width: 0, height: 0, _lastBatch: 0},\n    events: {\n      change_width: '_ifRecalc',\n      change_height: '_ifRecalc',\n      change__lastBatch: '_recalc',\n    },\n    _ifRecalc: function (now, old, options) {\n      this.set('_lastBatch', options.batchID)\n    },\n    _recalc: function () { /* as above */ },\n  })\n `]\n\n#skb Skipping known batches\n Things get hairy if your \"`'_ifRecalc\" handler is attached to multiple\n sqimitives and processes all batched sqimitives as one, rather than each\n batched sqimitive's events as one:\n[\n  function update(options) {\n    if (!skip(options)) {    // read below\n      _.each(options.batched, function (item) {\n        // item[0] is a sqimitive.\n        _.each(item[1], function (event) {\n          // Any change must cause an update. Or can check event[1] if\n          // only some _opt'ions cause it. Don't use event[0] == 'change_OPT'\n          // as it will never match since change_OPT is fired prior to\n          // change and is already removed from batched by the time update()\n          // runs.\n          if (event[0] == 'change') {\n            // ...\n    }\n  }\n\n  sqim1.on('change', (name, now, old, options) => update(options))  // (1)\n  sqim2.on('change', (name, now, old, options) => update(options))  // (2)\n  sqim3.on('change', (name, now, old, options) => update(options))  // (3)\n]\n\n Now, `'update() should ignore batches that it has seen. Previously used\n `'!= fails short since there may be events of other sqimitives fired\n between batched events of one sqimitive, as below:\n[\n  var lastBatch = 0\n  function skip(options) {\n    if (lastBatch != options.batchID) {\n      lastBatch = options.batchID\n    } else {\n      return true\n    }\n  }\n\n  sqim3.on('change', function () {    // (4)\n    sqim2.set('quux', 789)\n  })\n  sqim1.batch([sqim3], function () {  // (5)\n    sqim1.set('foo', 123)\n    sqim3.set('bar', 456)\n  })\n    // When batch()'s func returns, first event to be fired happens to be\n    // sqim3 change_bar, handled by (3). skip() receives options.batchID\n    // of N, storing it in lastBatch. Then, change_bar is handled by (4),\n    // which starts another batch (N + 1) that is closed immediately after\n    // set() in (4). This triggers (2), where skip() stores N + 1 in\n    // lastBatch. But now, the pending sqim1 change_foo from (5) triggers\n    // (1) where skip() sees options.batchID of N and considers this batch\n    // to be \"new\", even though it was already processed in response to (3).\n]\n\n Another incorrect solution would be to skip all batches with the same or\n lower ID than previously seen. After all, `'batchID is guaranteed to be\n `#unique and growing. However, the ID is generated when a batch starts\n (before calling `'func), not when the first batched event is dispatched:\n[\n  var lastBatch = 0\n  function skip(options) {\n    if (lastBatch < options.batchID) {\n      lastBatch = options.batchID\n    } else {\n      return true\n    }\n  }\n\n  sqim1.batch(null, function () {\n    sqim1.set('foo', 123)\n    sqim3.set('bar', 456)   // not part of sqim1's batch!\n  })\n    // batch() has allocated the batchID of N before calling func.\n    // Then, before batch()'s func returns, sqim3 change_bar is fired\n    // since this time sqim3 is not part of batch()'s sqims list (the\n    // batchID for change_bar is N + 1). This triggers (3), where\n    // skip() stores N + 1 in lastBatch. Then sqim3.set() returns, then\n    // sqim1.batch()'s func returns and fires the delayed sqim1 change_foo,\n    // to which (1) responds. skip() compares lastBatch of N + 1 with\n    // options.batchID of N and decides this batch is not \"new\".\n]\n\n To summarize, a handler hooked onto multiple objects must store the\n actual list of `'batchID-s it has seen. Most straightforward approach is\n to have a round-robin array holding up to N last IDs but choosing N is\n not trivial - make it too large and you will be wasting memory; make it\n too small and you will be identifying old batches as new.\n\n Instead of hardcoding any such value, we may rely on the fact that a\n given `'batchID can never reappear after the batch ends and that\n `[options.batched`] may not change after the batch has started. We can\n keep only as many IDs in the list as there are currently active batches.\n On the first event, push `'batchID to the list and push an internal event\n to each of the batched sqimitive's current batch. When the event fires N\n times, we pop that `'batchID (N = count of batched sqimitives, except\n ones with empty - already drained - batches).\n[\n  var seenBatches = new Set\n  function skip(options) {\n    if (seenBatches.size == seenBatches.add(options.batchID).size) {\n      // Already saw this batchID.\n      return true\n    } else {\n      // Event is firing in the batch for the first time, across all\n      // batched sqimitives. Wait for all sqimitives to drain this batch.\n      var event = 'mySkip' + Core.unique('mySkip')\n      var remaining = 0\n      _.each(options.batched, function (item) {\n        if (item[1].length) {\n          remaining++\n          item[1].push([event])\n          item[0].once(event, function () {\n            --remaining || seenBatches.delete(options.batchID)\n          })\n        }\n      })\n      // Instead of hooking every batched sqimitive, we could hook only\n      // batched[0] since it will fire its events last. However, the order\n      // in which batched sqimitives are processed is an internal detail.\n    }\n  }\n]\n\n Use `#batchGuard() that implements this algorithm in a generalized form.\n\n# Listening for batch end\n Occasionally you need to do some clean-up when all batched events finish\n but before the next batch starts firing. One way would be to override\n `'batch() itself, tap into `'func and push some internal event into\n `'_batch as the client-provided `'func returns. This is the only option\n when you need to react to every batch, but usually the clean-up is\n necessary only if certain events occurred during a batch, similarly to\n `'try/`'finally (except an exception breaks the batch). In this case you\n can push the internal event to `[options.batch`] or `[options.batched`]\n from within a listener as done in the example in `#skb.\n\n? With the above `'Rect class, we know that `'change_width and\n  `'change_height may trigger a lengthy synchronous process (as a result\n  of the `'_ifRecalc listener) and we want to show hourglass cursor to the\n  user until `'_recalc returns, i.e. the batch ends:\n  `[\n  var rect = new Rect\n  var sym = Symbol()\n  var waiting = 0\n  rect.on('-change_width, -change_height', function (now, old, options) {\n    if (!options.batch[sym]) {\n      $('body').css('cursor', 'wait')\n      options.batch.push(['restoreCursor'])\n      // Fire restoreCursor only once per batch, even if there are other\n      // change events pending.\n      options.batch[sym] = true\n      // This counter is in case we hook several Rect-s or other objects\n      // controlling the cursor.\n      // We could also use the counter alone, ditching Symbol and allowing\n      // duplicate restoreCursor events per batch but that'd be slightly\n      // less efficient.\n      waiting++\n    }\n  })\n  rect.on('restoreCursor', function () {\n    --waiting || $('body').css('cursor', '')\n  })\n  `]\n  In a real application you should make lengthy processes async to avoid\n  freezing the UI. Luckily, `#Async exists just for that.\n\n Generally speaking, it is permitted to modify `[options.batch`] in other\n ways as well, except touching the member corresponding to the event being\n fired. However, this is not recommended as it may quickly become\n unmanageable. In particular, since the order in which listeners are\n called is hard to predict, there is no guarantee that the batch update\n function alike to `'_recalc above will be affected by these modifications\n (such as an added or removed `'change_width) because it might have\n already executed. Or, with the `'skip() function example in `#skb,\n appending a new `#change event that would trigger `'update() will cause\n `'skip() to wrongly report a batch with such event as \"new\" because\n `'skip()'s internal on-batch-end listener has already deleted `'batchID\n from `'seenBatches.\n\n This problem does not exist for internal events like `'restoreCursor and\n `'mySkip that are not used outside of their private scope.","start":{"line":4168,"column":4,"offset":164149},"end":{"line":4256,"column":4,"offset":167294},"forced":null,"modifiers":[],"file":"main.js"},"977":{"type":"class","id":977,"name":"Sqimitive.Base","comment":" Implements what makes Sqimitive `*the`* Sqimitive - options (`#opt),\n children (`#chld) and filtering (`#util) on top of `#Core, which provides\n the fundamental event framework (`#evt).\n\n If you work with DOM then look for `@Sqimitive\\jQuery`@, which adds `#el\n and `#elEvents. If you want ordered children - use the\n `@Sqimitive\\Ordered`@ `#mixIn.\n\n?\n  It's good practice to extend this class just once in your application and\n  use the new base class everywhere else:\n  `* If Sqimitive's class hierarchy or your needs change, you'd have to\n     change just one reference to `#Base.\n  `* You're likely to implement some application-specific application-wise\n     logic sooner or later (such as logging) and it's easily done if you\n     have just one base class (of course, you should not ever change\n     Sqimitive's own prototypes).\n  `[\n     var MyApp = {\n       VERSION: '0.1',\n     }\n\n     MyApp.Sqimitive = Sqimitive.Base.extend()\n     // Or, if your application is DOM-based:\n     MyApp.Sqimitive = Sqimitive.jQuery.extend()\n\n     // Now use MyApp.Sqimitive as a base class throughout your code:\n     MyApp.ClassOne = MyApp.Sqimitive.extend(...)\n     MyApp.ClassTwo = MyApp.Sqimitive.extend(...)\n  `]\n\n Traditional OOP-style inheritance is not the only form of functionality\n extension supported by Sqimitive. For multi-parent inheritance, aka\n mix-ins, aka traits and for generics (parametrized mix-ins) see `#mixIn().","start":{"line":4299,"column":2,"offset":168973},"end":{"line":7344,"column":2,"offset":283335},"forced":null,"modifiers":[],"file":"main.js"},"978":{"type":"var","id":978,"name":"_opt","comment":"#+tag_Options\n* `@Base._opt`@\n#\n\n ` `*May be set upon declaration via `@Core::extend()`@ or `#mixIn, read\n on run-time with `#get() and written with `#set().`*\n\n List of \"`#opt'ions\" (public properties) of this instance.\n\n= object {name: value} `- keys are option names and values are anything,\n  of arbitrary type\n\n On run-time, use `#get()/`#set() to access this data (both from within\n this class' methods and from the outside - it's a public interface).\n\n When any option's value is changed, `#ifSet:\n* Fires the `#normalize_OPT event to allow for value normalization and\n  validation.\n* If no error occurred, changes the value in `[this._opt`] and fires\n  `#change_OPT and `#change to notify the interested parties.\n\n?`[\n   var Parent = Sqimitive.Base.extend({\n     _opt: {caption: 'unnamed'},\n\n     events: {\n       '+normalize_caption': function (res, s) {\n         return s.trim()\n       },\n\n       change: function (optName, newValue) {\n         alert(optName + '=' + newValue)\n       },\n     },\n   })\n\n   var Child = Parent.extend({\n     _opt: {body: 'unbodied'},\n\n     events: {\n       change_caption: function (newValue) {\n         alert('New caption = ' + newValue)\n       },\n     },\n   })\n\n   var child = new Child\n     // child._opt = {caption: 'unnamed', body: 'unbodied'}\n\n   child.set('caption', 'Foo')\n     // alerts: New caption = foo   - Child's change_caption handler\n     // alerts: caption=foo         - Parent's change handler\n\n   child.set('body', 'Bar')\n     // alerts: body=foo            - Parent's change handler\n\n   child.set('caption', ' S P A C E ')\n     // _opt.caption  = 'S P A C E'\n   child.set('body',    ' S P A C E ')\n     // _opt.body     = ' S P A C E '\n `]\n\n When given to `#extend(), the `'_opt key specifies initial options (their\n defaults) for new instances.\n\n#-inMergeProps\n\n It's highly advised to access `#_opt's values only via `#get()/`#set() -\n performance benefits of direct access are questionable (especially when\n those methods are not events/`#firer-s, i.e. almost always) while lack of\n `#normalize_OPT and others often cause bugs.\n\n#-inBB\n In Backbone terms \"options\" are called `@bb:Model-attributes`@.","start":{"line":4374,"column":4,"offset":171616},"end":{"line":4374,"column":11,"offset":171623},"forced":null,"modifiers":["protected"],"file":"main.js"},"979":{"type":"var","id":979,"name":"_parent","comment":"#+tag_Nesting\n* `@Base._parent`@\n\n#-readOnly\n\n Holds the reference to the Sqimitive that owns object, or `'null.\n\n You can read this property from inside methods of the same class.\n Changing it (from any context) is highly discouraged because it's easy to\n break object integrity - use `#nest(), `#unnest() and others.\n\n##parentAndKey\n Non-`#_owning sqimitives never change `#_parent and `#_parentKey of their\n `#_children.\n\n?`[\n   Sqimitive.Base.extends({\n     events: {\n       owned: function () {\n         // CORRECT: reading _parent from within this class' context:\n         alert('New parent is ' + this._parent._cid)\n         alert('My key under my parent is ' + this._parentKey)\n         // WRONG: do not change _parent:\n         this._parent = null\n       },\n     },\n   })\n\n   // WRONG: do not access _parent from the outside:\n   alert(sqim._parent._cid)\n `]","start":{"line":4407,"column":4,"offset":172684},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"980":{"type":"var","id":980,"name":"_parentKey","comment":"#+tag_Nesting\n* `@Base._parentKey`@\n\n#-readOnly\n\n Holds the key under which this instance is listed in its `#_parent's list\n of `#_children, or `'null.\n\n= string if owned`, null if not `- if `'null then `#_parent is also `'null\n\n#-parentAndKey\n\n? This key can be given to `#nested() and others:\n  `[\n     Sqimitive.Base.extends({\n       pull: function () {\n         this._parent.unlist(this._parentKey)\n           // this is a contrived example since this.remove() does\n           // exactly the same\n       },\n     })\n  `]","start":{"line":4431,"column":4,"offset":173360},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"981":{"type":"var","id":981,"name":"_children","comment":"#+tag_Nesting\n* `@Base._children`@\n#\n\n Holds references to objects contained within this instance\n (\"collection\").\n\n= object {key: Sqimitive} `- keys are arbitrary strings as given to `#nest\n  (`#_parentKey-s if `'this is `#_owning) and values are the children\n  themselves (objects)\n\n You're advised against accessing `#_children at all. Instead, use\n `#nested() and other methods.\n\n Other notes:\n* Both `#_owning sqimitives and not list their children here. For\n  non-`#_owning, `#_children keys naturally differ from `#_parentKey of\n  their children.\n* This parent-child relationship is purely formal and doesn't dictate any\n  DOM or other structure (children can have their `#el-s outside of the\n  parent's node). Moreover, if `#_owning is unset then it doesn't imply\n  the reverse relationship (from children to their parent).\n* See the children overview (`#chld) for examples.","start":{"line":4456,"column":4,"offset":174404},"end":{"line":4456,"column":16,"offset":174416},"forced":null,"modifiers":["protected"],"file":"main.js"},"982":{"type":"var","id":982,"name":"_owning","comment":"#+tag_Nesting\n* `@Base._owning`@\n\n#-setOnDecl\n\n Specifies if this object manages its children or not (by default it\n does).\n\n= true the default `- \"Managing\" (owning) parent. All of its children know\n  who owns them (`#_parent) and under which key (`#_parentKey). It makes\n  sure the children only ever have one parent - itself, and that they\n  cannot duplicate in its `#_children. Essentially makes a bi-directional\n  tree.\n= false `- Unmanaged (non-owning) parent. Acts as a simple collection.\n  Imposes no hierarchy onto its children, who do not even know that they\n  are listed here and may duplicate in `'this own `#_children (same child\n  under different keys).\n\n ` `#_owning only affects a subset of features (`#nest(), etc.). Most\n features - filtering (`#util), `#_forward'ing `#_childEvents, etc. can be\n used in both modes.\n\n See `#chld children overview for more details.\n\n?`[\n   var Owning = Sqimitive.Base.extend()\n\n   var NonOwning = Sqimitive.Base.extend({\n     _owning: false,\n   })\n\n   var child = new Sqimitive.Base\n   var owning = new Owning\n   var nonOwning = new NonOwning\n   owning.nest('key', child)\n   nonOwning.nest('key2', child)\n   alert(child._parent == owning)             //=> true\n   alert(child._parentKey)                    //=> 'key'\n   alert(owning.nested('key') == child)       //=> true\n   alert(nonOwning.nested('key'))             //=> undefined\n   alert(nonOwning.nested('key2') == child)   //=> true\n\n   var owning2 = new Owning\n   owning2.nest('key3', child)\n     // child._parent == owning2, _parentKey == 'key3'\n   alert(owning.nested('key'))                //=> undefined\n `]","start":{"line":4505,"column":4,"offset":176329},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"983":{"type":"var","id":983,"name":"_childClass","comment":"#+tag_Nesting\n* `@Base._childClass`@\n\n#-settable\n\n Ensures `#_children contains instances of a certain class only.\n\n= Object to disable type checking`, Sqimitive.Base the default`, array`,\n  string `- array and string are indirect declaration-time references\n  (`#classref)\n\n?`[\n   var MyToDoItem = Sqimitive.Base.extend()\n   var SpecialMyToDoItem = MyToDoItem.extend()\n\n   var MyToDoList = Sqimitive.Base.extend({\n     _childClass: MyToDoItem,\n   })\n\n   ;(MyToDoList).nest(new MyToDoItem)         // works (the _childClass)\n   ;(MyToDoList).nest({})                     // throws an exception\n   ;(MyToDoList).nest(new Sqimitive.Base)     // throws an exception\n   ;(MyToDoList).nest(new SpecialMyToDoItem)  // works (subclass of _childClass)\n `]\n\n? Disabling the check with `'Object: `[\n   var MyToDoList = Sqimitive.Base.extend({\n     _childClass: Object,\n   })\n\n   ;(MyToDoList).nest(new MyToDoItem)         // works\n   ;(MyToDoList).nest({})                     // works\n   ;(MyToDoList).nest(new Sqimitive.Base)     // works\n   ;(MyToDoList).nest(new SpecialMyToDoItem)  // works\n  `]\n\n Other notes:\n* Typically, `#_childClass specifies a subclass of `[Sqimitive.Core`]\n  (`#Core) since non-sqimitives are unlikely to work properly as children.\n  This is not checked though.\n* `#_childClass constraint is enforced as long as children are added via\n  `#nest() and other standard methods, not by direct manipulation of\n  `#_children (which is highly discouraged anyway).\n* Changing `#_childClass on run-time affects only new nesting attempts\n  (existing children are not validated).\n* `#_childClass is listed in `#_shareProps by default.\n\n#classref Indirect references\n It's often convenient to provide `#_childClass as an array or string to\n `#extend() or `#mixIn(). In this case `#init() resolves the value of\n `#_childClass to the actual class, once per instantiation of every class\n (this makes it tad slower than providing an object value):\n> array like `[[BaseObject, 'Sub.Class.Path']`] `- same as evaluating\n  `[BaseClass.Sub.Class.Path`]\n> string like `['Sub.Class.Path'`] `- relative to static properties of\n  `'this\n> string empty `''' `- the class of `'this\n\n ` `#init() errors if no class was found.\n\n? Indirect references are useful for \"forward type declaration\" where the\n  child class is defined after the collection's class or appears later on\n  run-time:\n  `[\n     var MyToDo = {}\n\n     MyToDo.List = Sqimitive.Base.extend({\n       _childClass: [MyToDo, 'Item'],\n     })\n\n     MyToDo.Item = Sqimitive.Base.extend()\n  `]\n  Or for the conventional Sqimitive hierarchy of `[<Collection>.<Child>`]:\n  `[\n     MyToDo.List = Sqimitive.Base.extend({\n       // All declarations below are equivalent:\n       _childClass: [MyToDo, 'List.Item'],\n       _childClass: [MyToDo.List, 'Item'],\n       _childClass: 'Item',\n     })\n\n     MyToDo.List.Item = Sqimitive.Base.extend()\n\n     alert(MyToDo.List.prototype._childClass)                   //=> 'Item'\n     alert((new MyToDo.List)._childClass == MyToDo.List.Item)   //=> true\n  `]","start":{"line":4593,"column":4,"offset":179907},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"984":{"type":"var","id":984,"name":"_childEvents","comment":"#+tag_Nesting\n* `@Base._childEvents`@\n\n#-settable\n\n Lists event names for automatic `#_forward'ing from children to the\n collection object.\n\n= array `- `[['-nest_', 'change', ...]`]\n\n Whenever a new child is `#nest()'ed, listens to these events on it,\n firing events on `'this with the same name but prefixed with a dot `'.\n (e.g. `'render -> `'.render) and with the child's object pushed in front\n of the event's arguments. Think of this as of the usual `[../../path`]\n notation in file systems where each dot means \"one [parent] above\".\n\n Nothing special is done to stop listening when a child is removed since\n the default `#unnested() implementation calls `[child.off(this)`] (see\n `#off).\n\n?`[\n   var MyList = Sqimitive.Base.extend({\n     _childEvents: ['-change'],\n\n     events: {\n       '.-change': function (sqim, name) {\n         alert('Option ' + name + ' is about to change on ' + sqim._cid)\n       },\n     },\n   })\n `]\n\n Warning: don't list `#unnest here - `#_parent will `#off() itself before\n that and never receive the notification. Use `#unnested instead. Using\n `'-unnest is also possible but in this case if an exception occurs during\n unnesting your handler won't know this and will be called anyway, while\n the child is possibly left nested.\n\n#-inMergePropsA\n\n Other notes:\n\n##chevaoff\n* Use `#_childEvents to track events of `#_children; use `#autoOff() to\n  track events of the outside objects.\n##\n* If `#_childEvents is changed on run-time, only new children are\n  affected.\n* For the impementation see `#_forward().\n* See Children overview (`#chld) for a comprehensive example.\n\n? Using `#_childEvents is identical to manually calling `#on() but more\n  convenient. However, since it's `#on() in disguise, you can use any\n  event prefixes (`#evtpf), specify methods that will be automatically\n  turned into events (`#evt), etc.\n  `[\n    var Collection = Sqimitive.Base.extend({\n      _childEvents: ['=click'],\n\n      _opt: {\n        enabled: true,\n      },\n\n      events: {\n        '.=click': function (child, sup) {\n          if (this.get('enabled')) {\n            return sup(this, arguments)\n          } else {\n            console.error('Clicking is disabled! Stop playing, ' + child._cid)\n          }\n        },\n\n        '-unnested': function (child) {\n          child.off(this)\n        },\n      },\n    })\n\n    var Item = Sqimitive.Base.extend({\n      click: function () { alert('Oh... feels good!') },\n    })\n\n    var col = new Collection\n    var item = new Item\n    item.click()    // alerts; click is a method\n    col.nest(item)\n      // item.click is no longer the original method but the wrapping handler\n    item.click()    // alerts\n    col.set('enabled', false)\n    item.click()    // no more alerts\n    col.unlist(item)\n    item.click()    // alerts again; click is again the original method\n  `]\n\n? You can forward already forwarded events with multi-level nesting\n  (children of children of your collection) the same way. The number of\n  dots indicates the number of child instances prepended to event's\n  arguments: `[\n   var MyListGroup = Sqimitive.Base.extend({\n     // Indicate this object nests MyList instances from the first\n     // example.\n     _childClass: MyList,\n\n     // MyList forwards '-change' on its children as '.-change' on itself\n     // so we can foward that event too on this grouping instance.\n     // There's no limit - '....-change' is perfectly fine and works on\n     // 4th nesting level. Each forward gets originating object pushed in\n     // front so '..-change' gets MyList as first argument. '...-change'\n     // would get (MyListGroup, MyList).\n     _childEvents: ['.-change'],\n   })\n\n   // Listening to '-change' that occurred on a MyList child, with MyList\n   // being nested into MyListGroup.\n   ;(new MyListGroup).on('..-change', function (myListGroup, myList) { ... })\n  `]\n\n  And of course you can use the usual event prefixes (`#evtpf) on these\n  already-forwarded events:\n  `[\n     // Trigger event on this before other handlers of '.-change'.\n     _childEvents: ['-.+normalize'],\n\n     // ...\n\n     ;(new MyListGroup)\n       .on('.-.+normalize_caption', function (myListGroup, myList,\n                                              currentResult, newValue) {\n         return newValue.trim()\n       })\n  `]","start":{"line":4726,"column":4,"offset":185000},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"985":{"type":"var","id":985,"name":"_respToOpt","comment":"#+tag_Options\n* `@Base._respToOpt`@\n\n#-settable\n\n Specifies rules for transforming an external input object (e.g. an API\n response) into `#_opt'ions used by `#assignResp().\n\n See also `#_initToOpt that is used to assign `'opt given to `#init()\n (`'new) to `'this.`#_opt.\n\n#rtobase\n= object {respKey: optValue}.\n\n ` `#_respToOpt's keys are input object's keys (except the special `[''`])\n and values are one of the following (`'optValue):\n> false `- Skip input item regardless of `[options.onlyDefined`] as given\n  to `#assignResp().\n> true `- Assign input item's value to the option named `'respKey (i.e.\n  keys of the option and the input object are the same).\n> string `- Assign input item's value to the option by this name. If\n  begins with `[.`], assign directly to a property on `'this (if sole `'.\n  then assign to property named `'respKey) - typically used for public\n  read-only properties.\n> function (respValue, key, resp, options) `- Input item transformation.\n  This function is called in `'this context and must return\n  `[[false|'optToSet|.[prop]', value]`] or falsy (equals `[[false]`]),\n  with the first member treated as above.\n\n  `'respKey only determines the `'respValue given to this function; the\n  latter can access the entire input object (`'resp). The (new) option's\n  name is retrieved from the returned array (`'optToSet), not from\n  `'respKey.\n\n  The `'key argument equals `'respKey (i.e. is the key's name under which\n  the function is listed in `'_respToOpt), `'options is the object given\n  to `#assignResp().\n\n  If `'optToSet is `'false then the input item is skipped and `'value is\n  unused, otherwise it's the option name to set `'value to (`'value can be\n  of any type). It's similar to calling `#set() but more declarative and\n  future-proof.\n\n The special key `''' (empty string) must be a function `[(resp,\n options)`] returning object `[{optToSet: value}`] or `'null (equivalent\n to `[{}`]). It's called in the beginning of `#assignResp() and, as other\n keys, if `'resp has an empty string key - check `[arguments.length`] if\n you expect it. This key is useful for unserializing fields that match\n multiple options or vice-versa:\n[\n   Sqimitive.Base.extend({\n     _respToOpt: {\n       '': function (resp) {\n         return {personsName: resp.firstName + ' ' + resp.secondName}\n           // same as set('personsName', '<firstName> <secondName>')\n       }\n\n       // The opposite of the above - if there are two options in one\n       // input key.\n       '': function (resp) {\n         var name = resp.personsName.split(' ')\n         return {firstName: name[0], secondName: name[1]}\n       }\n     },\n   })\n]\n\n?`[\n   Sqimitive.Base.extend({\n     _respToOpt: {setAsIs: true, setAsFoo: 'Foo'},\n   })\n\n   // ...\n\n   sqim.assignResp({setAsIs: 123, setAsFoo: 'xyz'})\n     // sqim._opt is {setAsIs: 123, Foo: 'xyz'}\n\n   // Equivalent to:\n   sqim.set('setAsIs', 123)\n   sqim.set('Foo', 'xyz')\n `]\n\n? Using transformation functions:\n  `[\n   Sqimitive.Base.extend({\n     _respToOpt: {\n       ignore: function () { return [false] },\n       rename: function (value) { return ['foo', value] },\n       date: function (value) { return ['date', new Date(value)] },\n       merge: function (v, k, resp, options) {\n         // v = 5, k = 'merge', resp = {unlisted: ...}, options = {}\n         return ['bar', resp.a.concat(resp.b)\n       },\n       setUndefined: function () { return ['baz', undefined] },\n     }\n   })\n\n   // ...\n\n   sqim.assignResp({unlisted: 1, ignore: 2, rename: 3, date: 4,\n                    merge: 5, a: 6, b: 7, setUndefined: 8})\n     // sqim._opt is {foo: 2, date: Date, bar: [6, 7], baz: undefined}\n  `]\n\n##-unordered\n Keys are restored in arbitrary order except `''' is always called first.\n The below example is buggy because `'object may be called before\n `'objects, when `[this.objects`] is not yet unserialized:\n `[\n   Sqimitive.Base.extend({\n     objects: null,   // some kind of collection\n     object: null,    // a member of objects\n\n     _respToOpt: {\n       objects: function (list) {\n         this.objects.assignChildren(list)\n       },\n       object: function (key) {\n         this.object = this.objects.nested(key)\n       },\n     },\n   })\n `]\n `'objects must be restored from within `[''`]:\n `[\n     _respToOpt: {\n       '': function (resp) {\n         this.objects.assignChildren(resp.objects)\n       },\n       object: function (key) {\n         // As before.\n       },\n     },\n `]\n This has to be done even if `'objects assignment is simple:\n `[\n     // WRONG:\n     _respToOpt: {\n       objects: true,\n       object: function (key) {\n         this.object = this.objects[key]\n       },\n     },\n\n     // WRONG:\n     _respToOpt: {\n       // No objects key = true if onlyDefined is false (as it is by default).\n\n       object: function (key) {\n         this.object = this.objects[key]\n       },\n     },\n\n   assignResp({objects: {k: ...}, object: 'k'}, {onlyDefined: false})\n `]\n\n##-inMergeProps\n\n Other notes:\n* Options are assigned with `#set() so normalization and `#change events\n  take place as usual.\n* Missing keys may or may not become options by the same name - this\n  depends on the `[options.onlyDefined`] flag of `#assignResp().\n* Leading `'. has no effect on `'respKey-s missing from `'schema: they are\n  always either ignored (`'!onlyDefined) or `#set(): `[\n    sqim.assignResp({'.x': 1, '.y': 2}, {schema: {'.x': true}})\n      //=> sqim.x is 1, sqim._opt['.y'] is 2\n    sqim.assignResp({'.x': 1, '.y': 2}, {schema: {'.x': true}, onlyDefined: false})\n      //=> sqim.x is 1, sqim._opt['.y'] is unchanged\n  `]","start":{"line":4898,"column":4,"offset":191619},"end":{"line":4898,"column":17,"offset":191632},"forced":null,"modifiers":["protected"],"file":"main.js"},"986":{"type":"var","id":986,"name":"_initToOpt","comment":"#+tag_Options\n* `@Base._initToOpt`@\n\n#-setOnDecl\n\n Specifies `#_respToOpt rules for transforming `'opt given to `#init()\n (`'new) into `'this.`#_opt.\n\n ` `#_initToOpt is the `#assignResp()'s schema used by `#init(). `#Base's\n value directly merges the `'opt object into own `#_opt, ignoring `'el.\n `'el by convention is meant to replace the declared class value, possibly\n mutated (see `#jQuery, for example).\n\n?`[\n  var My = Sqimitive.Base.extend({\n    _initToOpt: {context: false},\n    _context: null,\n\n    events: {\n      init: function (opt) {\n        this._context = opt.context\n      },\n    },\n  })\n\n  // Or, shorter:\n  var My = Sqimitive.Base.extend({\n    _initToOpt: {context: '._context'},\n    _context: null,\n  })\n\n  var my = new My({context: cx})\n    //=> my._opt = {}\n    //=> my._context = cx\n `]\n\n? Keeping `#_opt clean by assigning only whitelisted keys:\n  `[\n  var My = Sqimitive.Base.extend({\n    _opt: {\n      quux: 'initial',\n    },\n\n    // Thanks to _mergeProps, _initToOpt keys are merged with Base's.\n    _initToOpt: {\n      foo: true,        // set foo under _opt.foo\n      bar: 'newBar',    // set bar under _opt.newBar\n      // By default, assignResp() copies unlisted keys as is.\n      '': function (opt, options) { options.onlyDefined = true },\n    },\n  })\n\n  new My({quux: 0, foo: 1, bar: 2, baz: 3, el: 4})\n    //=> _opt = {quux: 'initial', foo: 1, newBar: 2}\n    //\n    // 1. Keeps class' value for quux (because of onlyDefined)\n    // 2. Takes foo\n    // 3. Renames bar to newBar\n    // 4. Ignores baz (because of onlyDefined)\n    // 5. And el (because of {el: false} inherited from Base)\n  `]\n\n#-rtobase","start":{"line":4963,"column":4,"offset":193654},"end":{"line":4963,"column":26,"offset":193676},"forced":null,"modifiers":["protected"],"file":"main.js"},"988":{"type":"var","id":988,"name":"el","comment":"#+tag_Lifecycle\n* `@Base.el`@\n\n#-settable\n\n \"Element\" - an external \"form\" of this Sqimitive (such as a DOM node).\n\n Even though this is technically a public read/write property, it's\n usually best not to change it on run-time (after initialization) or at\n least not from the outside context.\n\n#elstub\n `@Sqimitive\\Base`@ doesn't define any element-related functionality but\n only provides stubs for several common fields (`#el, `#render(),\n `#remove(), etc.) for standardized extension. See `@Sqimitive\\jQuery.el`@\n for one such subclass.","start":{"line":4982,"column":4,"offset":194333},"end":null,"forced":null,"modifiers":[],"file":"main.js"},"989":{"type":"var","id":989,"name":"elEvents","comment":"#+tag_Lifecycle\n* `@Base.elEvents`@\n\n#baseElEvents\n##-setOnDecl\n\n Declares event listeners for `#el, bound automatically by `#attach().\n\n= object {event: func}\n\n ` `#elEvents' format is consistent among `#Base's subclasses and follows\n Backbone's `@bb:Model-events`@: keys are event references of form\n `[event[.ns][ .sel #ector]`] and values are strings (`#expandFunc()) or\n functions, called as `[function (nativeEventObject)`] (see `#argDanger).\n\n##-inMergeProps\n\n The `'.ns part is ignored but can be used to create unique keys for the\n purpose of inheritance. By convention, the class' own handlers don't have\n `'ns while handlers of `#mixIn-s do.\n\n##-es6thiswarn\n\n This property is not advised to change on run-time since it's usually\n unpredictable when it will take effect. For example,\n `@Sqimitive\\jQuery.attach()`@ only binds events when nesting `#el into a\n new parent node:\n[\n   sqim.attach()\n   sqim.elEvents['click'] = function () { alert('foo') }\n   sqim.attach()    // will do nothing and 'click' will not be bound\n   sqim.el.remove()\n   sqim.attach()    // now events are bound\n]\n\n#-elstub","start":{"line":5020,"column":4,"offset":195673},"end":{"line":5020,"column":15,"offset":195684},"forced":null,"modifiers":[],"file":"main.js"},"990":{"type":"var","id":990,"name":"length","comment":"#-readOnly\n\n The number of `#_children `#nest()'ed into this object.\n\n Just like `[$('p').length`] or `@bb:Collection-length`@.\n\n See also `#slice().","start":{"line":5029,"column":4,"offset":195884},"end":null,"forced":null,"modifiers":[],"file":"main.js"},"991":{"type":"func","id":991,"name":"constructor","comment":"! `, +fna=function ( [opt] )\n\n Calls `@Core.constructor()`@ and `#fire()-s `#init and `#postInit,\n passing `'opt to all.\n\n `'opt is the first argument optionally given to `'new:\n `[new Sqimitive.Base({opt...})`].\n\n This method ensures `'opt is always an object before passing it on so\n there is no need for checks like `[(opt && opt.foo)`].\n\n? `#init/`#postInit handlers may propagate changes in user-given `'opt to\n  other handlers or even to the caller of `'new (`#optpropag).\n  `[\n    var MyClass = Sqimitive.Base.extend({\n      events: {\n        init: function (opt) { opt.changed = 123 },\n      },\n    })\n\n    var opt = {}\n    ;(new MyClass(opt))\n      // opt.changed == 123\n  `]\n\n Constructors are reminiscents of the traditional JavaScript OOP (if it\n can be called so). They are hard to work with in Sqimitive (you can't\n override them using events) so you want to leave them alone, instead\n working with `#init() and `#postInit() which are \"regular\" Sqimitive\n methods.","start":{"line":5061,"column":4,"offset":197059},"end":{"line":5072,"column":4,"offset":197640},"forced":null,"modifiers":["constructor"],"file":"main.js"},"992":{"type":"func","id":992,"name":"init","comment":"! `, +fna=function ( [opt] )\n\n#+tag_Lifecycle\n* `@Base.init()`@\n#\n\n Resolves `#_childClass and sets `#_opt'ions from `'opt.\n\n Arguments of `#init() and `#postInit() that follows it match those given\n to the `#constructor, which in turn gets them from `'new. Usually only\n the first one (`'opt) is used but you can use others:\n[\n   var MyClass = Sqimitive.Base.extend({\n     events: {\n       init: function (opt, extra, fooArray) { ... },\n     }\n   })\n\n   new MyClass({opt...}, 'extra', ['foo'])\n]\n\n Options are set in `#batch by giving `#assignResp() `'opt (or `[{}`]) and\n `'schema of `#_initToOpt. By default, `#_opt keys missing from `'opt\n remain with the declaration-time values while `[opt.el`] is ignored even\n if present.\n\n Other notes:\n* `#init() stores resolved relative `#_childClass in the prototype of\n  `'this so subsequent constructors of `'this' class no longer need to do\n  it.\n\n#initonce\n* Both `#init() and `#postInit() are only called once in a given object's\n  lifetime.\n#-plainstub\n\n#\n\n?`[\n   var MyClass = Sqimitive.Base.extend({\n     _opt: {a: 1, b: 2},\n   })\n\n   new MyClass({b: 3, c: 4})\n     // _opt is {a: 1, b: 3, c: 4}\n `]","start":{"line":5120,"column":4,"offset":199077},"end":{"line":5137,"column":4,"offset":199653},"forced":null,"modifiers":[],"file":"main.js"},"995":{"type":"func","id":995,"name":"postInit","comment":"! +fn=postInit:opt +ig\n\n#+tag_Lifecycle\n* `@Base.postInit()`@\n#\n\n Called after `#init() to bootstrap the new instance after\n `#constructor'ing.\n\n Logically, `#init is part of the object construction while `#postInit is\n part of its lifecycle; while `#init is inseparable from `'new, `#postInit\n could be called at a later time (in theory) so it should not make the\n object inconsistent. Thinking about it that way helps to decide which of\n the two events to hook.\n\n Usually `#init() creates and configures related objects (DOM nodes,\n collections, etc.) while `#postInit() starts timers, resource preloading,\n etc. This way you don't depend on the order of `#init() handlers (it may\n so happen that the `'init handler of a subclass is executed before the\n inherited `'init of its base class, when internal objects are not yet\n initialized).\n\n Other notes:\n\n#-initonce\n* `#Base does nothing in `#postInit().\n\n?`[\n   var MySqimitive = Sqimitive.Base.extend({\n     _button: null,\n\n     events: {\n       init: function () {\n         this._button = this.nest(new MyButton)\n       },\n\n       postInit: function () {\n         this._button.startAnimation()\n       },\n     },\n   })\n `]","start":{"line":5139,"column":4,"offset":199661},"end":{"line":5180,"column":4,"offset":201080},"forced":true,"modifiers":[],"file":"main.js"},"996":{"type":"func","id":996,"name":"render","comment":"#+tag_Lifecycle\n* `@Base.render()`@\n#\n\n Populate from scratch or update the object's \"view\" - `#el.\n\n#renderAttach\n\n##baseAttach\n\n= object `- `'this\n\n Here's a typical Sqimitive object lifecycle:\n* construct with `'new: `[new Class({opt...})`]\n* `#attach() (to DOM, etc.), for members - when nested to a collection\n* `#render() when required for user to see it first time\n* `#render() again when something changes that affects the visual\n  presentation (usually in response to a `#change of some `#_opt'ion)\n* finally, `#remove()\n\n Complete re-rendering on change is simple and adequate for many simple\n sqimitives but if it's heavy, it's customary to perform a partial update\n using method(s) named `'update(). There are no such methods by default\n but see `#vw for an example.\n\n?`[\n    var Label = Sqimitive.jQuery.extend({\n      _opt: {caption: 'untitled'},\n\n      events: {\n        render: function () {\n          this.el.text(this.get('caption'))\n        },\n\n        change_caption: 'render',\n      },\n    })\n                                        // Lifecycle:\n    ;(new Label)                        // 1) construct\n      .attach('body')                   // 2) attach\n      .render()                         // 3) render\n      .set('caption', 'render again!')  // 4) update\n `]\n\n##-elstub\n\n#\n\n ` `#Base's `#render() calls `#attach() on all children of self (but not\n on self).","start":{"line":5233,"column":4,"offset":202802},"end":{"line":5236,"column":4,"offset":202874},"forced":null,"modifiers":[],"file":"main.js"},"997":{"type":"func","id":997,"name":"attach","comment":"#+tag_Lifecycle\n* `@Base.attach()`@\n#\n\n Attach the object to its parent and bind \"external\" event handlers\n (`#elEvents).\n\n#-renderAttach\n\n ` `#Base's `#attach() does nothing. You may be looking for\n `@Sqimitive\\jQuery.attach()`@.","start":{"line":5249,"column":4,"offset":203179},"end":{"line":5251,"column":4,"offset":203229},"forced":null,"modifiers":[],"file":"main.js"},"998":{"type":"func","id":998,"name":"getSet","comment":"! `, +fna=function ( toGet [, toSet [, toReturn]] [, func[, cx]] )\n\n#+tag_Options\n* `@Base.getSet()`@\n#\n\n Performs `#batch'ed `#get() and/or `#set() on multiple options.\n\n> toGet     string `#_opt name`, array of names\n> toSet     string `#_opt name`, array of names`, null/omitted assume\n  `'toGet\n> toReturn  string `#_opt name`, array of names`, null/omitted assume\n  `'toSet `- Values for names prefixed with `'- are obtained before\n  setting `'toSet (`'- is ignored by `'toGet/`'toSet).\n> func `- Given `'G arguments (`'G = length of `'toGet), returns an array\n  or a single value (if `'toSet is a string) - option value(s) to set.\n  Returned array's length must be <= length of `'toSet. Missing members of\n  `'toSet are not set.\n\n  If `'func is missing sets every `[toSet[N]`] to `[toGet[N]`]. The length\n  of `'toSet must be <= length of `'toGet.\n\n> cx object`, null/omitted use `'this `- the context for `'func\n\n= array of values if `'toReturn is an array`, mixed single value if not\n\n Other notes:\n* Errors if called without arguments (without `'toGet).\n##getmul\n* Use `#getSet`[(['foo', 'bar'])`] to retrieve multiple properties as an\n  array. Use `[_.pick(this.get(), 'foo', 'bar', _.forceObject)`] to\n  retrieve them as an object.\n\n##\n\n?`[\n   // Multi-get() - but ensure given arrays have no properties beginning with '-':\n   sqim.getSet(['opt1', 'opt2', 'opt3'])\n     //=> [value of opt1, value of opt2, value of opt3]\n     // Even though the above not only get()-s but also set()-s them,\n     // unless a normalize_OPT returns a different value then no change\n     // events are fired since each option is set to its current value.\n\n   // Returns new value of opt2 (same as value of opt1):\n   sqim.getSet('opt1', 'opt2')\n   // Similar but returns this:\n   sqim.set('opt2', sqim.get('opt1'))\n   // Similar but returns value of opt3, not opt2 (opt2 == opt1):\n   sqim.getSet('opt1', 'opt2', 'opt3')\n\n   // Value exchange:\n   sqim.getSet(['left', 'right'], ['right', 'left'])\n   // Equivalent to:\n   var temp = sqim.get('left')\n   sqim.set('left', sqim.get('right'))\n   sqim.set('right', temp)\n\n   // Temporary change:\n   var old = sqim.getSet(['foo', 'bar'])\n   try {\n     // ...\n   } finally {\n     sqim.getSet(['foo', 'bar'], () => old)\n   }\n `]\n\n? Usage of `[-`]:\n  `[\n   // toReturn defaults to toSet which defaults to toGet. Returns old + 1:\n   var newRound = sqim.getSet('round',  old => old + 1)\n\n   // Dash prefix in toReturn causes pre-toSet values to be returned (i.e. old):\n   var oldRound = sqim.getSet('round', 'round', '-round', old => old + 1)\n\n   // Given dashes in toGet/toSet are ignored, this is an equivalent:\n   var oldRound = sqim.getSet('-round', old => old + 1)\n  `]\n\n? Updating an option based on another option:\n  `[\n    Sqimitive.Base.extend({\n      _opt: {money: 0, income: 10},\n    })\n\n    var newMoney = sqim.getSet(['money', 'income'], 'money',\n                               (money, income) => money + income)\n    alert(newMoney)    //=> 10\n\n    // Equivalent to:\n    var newMoney = sqim.get('money') + sqim.get('income')\n    sqim.set('money', newMoney)\n    alert(newMoney)\n  `]\n\n? Common idiom of re-applying `#normalize_OPT():\n  `[\n    Sqimitive.Base.extend({\n      _opt: {position: 0, max: 0},\n\n      events: {\n        change_max: function (now) {\n          this.getSet('position')\n        },\n\n        '+normalize_position': function (res, now) {\n          return Math.min(now, this.get('max'))\n        },\n      },\n    })\n\n    sqim.set('position', 10)\n    sqim.set('max', 5)\n    sqim.get('position')    //=> 5\n  `]","start":{"line":5367,"column":4,"offset":207482},"end":{"line":5392,"column":4,"offset":208542},"forced":null,"modifiers":[],"file":"main.js"},"1000":{"type":"func","id":1000,"name":"get","comment":"! `, +fna=function ( [opt] )\n\n#+tag_Options\n* `@Base.get()`@\n#\n\n Returns the value of one `#_opt or values of all of them (if no\n argument).\n\n?`[\n   sqim.get('opt1')   //=> 'value'\n   sqim.get()         //=> {opt1: 'value', opt2: 123, ...}\n `]\n\n All options' values are returned in an object shallow-copied from `#_opt\n meaning it's safe to change the object itself (add/remove properties) but\n changing non-scalar values will indirectly change options inside the\n object:\n[\n   var MyClass = Sqimitive.Base.extend({\n     _opt: {array: [1, 2]},\n   })\n\n   var obj = new MyClass\n   var opts = obj.get()   //=> {array: [1, 2]}\n   opts.new = 3\n   obj.get()              //=> {array: [1, 2]} - same\n   opts.array.push(4)\n   obj.get()              //=> {array: [1, 2, 4]} - changed\n]\n\n Override this method to read non-existing options or transform them like\n this:\n[\n   var MySetter = Sqimitive.Base.extend({\n     _opt: {\n       foo: 'foo!',\n     },\n\n     events: {\n       // Now any option can be read as option:up to turn its value into\n       // upper case.\n       '+get': function (res, name) {\n         if (name = name.match(/^([^:]+):up$/)) {\n           return this.get(name[1]).toUpperCase()\n         }\n       },\n     },\n   })\n\n   alert((new MySetter).get('foo'))       //=> foo!\n   alert((new MySetter).get('foo:up'))    //=> FOO!\n]\n\n Other notes:\n\n* Cloning a sqimitive is often as easy as doing `[new MySqim(orig.get())`]\n  sans `#_initToOpt considerations. Don't use `[clone orig`] (new object\n  will have wrong state, e.g. references to the original `#_parent).\n#-getnset\n#-getmul\n\n#-unordered\n There are no guarantees in which order options would be iterated over.","start":{"line":5458,"column":4,"offset":210606},"end":{"line":5460,"column":4,"offset":210705},"forced":null,"modifiers":[],"file":"main.js"},"1001":{"type":"func","id":1001,"name":"set","comment":"! `, +fna=function ( opt, value[, options] )\n\n#+tag_Options\n* `@Base.set()`@\n#\n\n Changes the value of one `#_opt'ion and returns `'this.\n\n ` `#set() is identical to `#ifSet() except the latter returns\n `'true/`'false indicating if the new value was different from the old one\n or `[options.forceFire`] was set.\n\n If you are overriding the \"setter\" behaviour you should override `#ifSet\n instead of `#set which calls the former.\n\n?`[\n   sqim.set('key', 'foo')     //=> this\n\n   // Fires normalize/change_key/change despite the fact that old key's\n   // value is the same:\n   sqim.set('key', 'foo', {forceFire: true})\n `]\n\n The description of `#ifSet() follows.\n\n#-ifSetSet","start":{"line":5488,"column":4,"offset":211541},"end":{"line":5491,"column":4,"offset":211639},"forced":null,"modifiers":[],"file":"main.js"},"1002":{"type":"func","id":1002,"name":"normalize_OPT","comment":"! +fn=normalize_OPT:value:options\n\n#+tag_Options\n* `@Base.normalize_OPT()`@\n#\n\n Called to normalize and/or validate new `#_opt'ion `'value before it's\n set. Returning `'undefined keeps it unchanged.\n\n ` `#ifSet() fires an event named \"normalize_\" + the option's name before\n the value is actually set to `#_opt. Here you should clean it up (e.g.\n trim whitespace) or throw an error if it has a wrong format (e.g. not\n `[YYYY-MM-DD`] for dates).\n\n##normopt\n `'options is the object originally given to `#set() or `#ifSet().\n\n##\n\n? Removing spaces and converting to lower case: `[\n   var MyNorm = Sqimitive.Base.extend({\n     _opt: {\n       stringie: '',\n     },\n\n     // Now 'stringie' is guaranteed to have no surrounding whitespace\n     // and be lower case - as long as it's not written directly as\n     // this._opt.stringie, which is a bad idea in general.\n     normalize_stringie: function (value) {\n       return _.trim(value).toLowerCase()\n     },\n   })\n\n   var str = (new MyNorm)\n     .set('stringie', '  Foo\\n')\n     .get('stringie')\n       //=> 'Foo'\n  `]\n\n#normiseq\n? `#ifSet() fires `#normalize_OPT, then `#isEqual(). The first operates in\n  context of specific `#_opt'ion and has its result interpreted by\n  `#isEqual(), which in turn is option-agnostic.\n\n  For example, if `'foo is an unordered array of numbers then\n  `#normalize_OPT can prevent `#change_OPT if new value has the same\n  numbers by returning current value which by default `#isEqual (`[===`])\n  to itself:\n  `[\n      '+normalize_foo': function (res, value) {\n        return (value = _.unique(value)) + '' == this.get('foo') ? this.get('foo') : value\n      },\n  `]\n  On the other hand, `#isEqual() may prevent `'NaN from being inequal to\n  itself, for all `#_opt'ions:\n  `[\n      '+isEqual': function (res, a, b) {\n        return res || (isNaN(a) && isNaN(b))\n      },\n  `]\n\n#\n\n? Validating new value (see the sample To-Do application for a complete\n  primer): `[\n   var MyValid = Sqimitive.Base.extend({\n     _opt: {\n       date: null,    //= Date or 'YYYY-MM-DD'\n     },\n\n     normalize_date: function (value) {\n       if (!(value instanceof Date) &&\n           (value = value.trim().match(/^(\\d{4})-(\\d\\d)-(\\d\\d)$/))) {\n         value = new Date(value[1], value[2] - 1, value[3])\n       }\n       if (!(value instanceof Date)) {\n         throw new TypeError('Bad date format')\n       }\n       return value\n     },\n   })\n\n   ;(new MyValid).set('date', new Date)       // works\n   ;(new MyValid).set('date', '2020-02-20')   // works\n   ;(new MyValid).set('date', 'whatchadoin')  // TypeError\n  `]\n     `&sup1 It's customary in Sqimitive to leave a comment explaining\n     non-trivial options' types or formats.\n\n Unlike with `#change/`#change_OPT, there is no global normalization\n function (since every option usually needs a unique approach) but you can\n override `#ifSet() if you need this.\n\n Remember: when defined in `#events, function's return value is ignored\n unless `'= or `'+ prefixes are used (`#evtpf). Also, see `#evtconc and\n `#es6this.\n[\n    Sqimitive.Base.extend({\n      events: {\n        // WRONG: return value is ignored:\n        normalize_stringie:    function (value) { return _.trim(value) },\n        // CORRECT: adding handler after others:\n        '+normalize_stringie': function (res, value) { return _.trim(value) },\n        // CORRECT: adding handler instead of others:\n        '=normalize_stringie': function (sup, value) { return _.trim(value) },\n      },\n\n      // CORRECT, but only if no normalize_string is defined in any base\n      // class (see #evtconc):\n      normalize_stringie: function (value) { return _.trim(value) },\n    })\n]\n\n#-setoptpropag","start":{"line":5495,"column":4,"offset":211727},"end":{"line":5608,"column":4,"offset":216054},"forced":true,"modifiers":[],"file":"main.js"},"1003":{"type":"func","id":1003,"name":"change_OPT","comment":"! +fn=change_OPT:now:old:options\n\n#+tag_Options\n* `@Base.change_OPT()`@\n#\n\n Called to notify that the value of `#_opt'ion named `'OPT has changed\n from `'old to `'now.\n\n#changeAndOpt\n ` `#ifSet normalizes (`#normalize_OPT) new option's value (`'now) and, if\n it's different from the current one (`'old) fires an event named\n \"change_\" + the option's name (`#change_OPT), then fires `#change.\n\n New value is already written to `[this._opt.OPT`] by the time change\n events occur.\n\n##-normopt\n\n With `'new being a reserved word, it's customary to name the first\n argument \"`'now\" rather than \"`'value\" to clearly indicate which argument\n is the new value (\"now\" and \"old\").\n\n?`[\n   var MyClass = Sqimitive.Base.extend({\n     _opt: {\n       caption: '',\n     },\n\n     events: {\n       // When _opt.caption is changed - call render() to update the looks.\n       change_caption: 'render', //\n     },\n   })\n `]\n    `&sup1 Be aware of `#argDanger as your handler might care for extra\n    arguments. If it does then use a masked reference (see `#masker()):\n    `[\n      events: {\n        // Pass no arguments thanks to '-':\n        change_caption: 'updateCaption-',\n      },\n    `]\n\n?`[\n   var MyClass = Sqimitive.jQuery.extend({\n     el: {tag: 'form'},\n\n     _opt: {\n       caption: '',\n       body: '',\n     },\n\n     events: {\n       // When any option is changed - update the corresponding <input>.\n       change: function (name, now) {\n         // change_OPT doesn't receive option's name as the first argument.\n         //\n         // now is used as is - if clean-up is required then normalize_OPT\n         // events must be handled.\n         this.$('[name=\"' + name + '\"]').val(now)\n       },\n     },\n   })\n `]\n\n##setoptpropag\n? Propagation of `'options (`#optpropag):\n  `[\n   sqim.on('change_foo', function (now, old, options) {\n     if (!options.noSync) {\n       $.ajax({\n         url: 'update',\n         type: 'POST',\n         data: this.get(),\n       })\n     }\n   })\n\n   // The handler above performs an AJAX request:\n   sqim.ifSet('foo', 123)\n\n   // But not now (set() passes options through to ifSet()):\n   sqim.set('foo', 123, {noSync: true})\n\n   // assignResp() passes options to set() so no request is performed too:\n   sqim.assignResp({foo: 123}, {noSync: true})\n  `]","start":{"line":5612,"column":4,"offset":216139},"end":{"line":5699,"column":4,"offset":218932},"forced":true,"modifiers":[],"file":"main.js"},"1004":{"type":"func","id":1004,"name":"change","comment":"! +fn=change:opt:now:old:options\n\n#+tag_Options\n* `@Base.change()`@\n#\n\n Called to notify that the value of some `#_opt'ion (`'opt) has changed\n from `'old to `'now.\n\n#-changeAndOpt","start":{"line":5703,"column":4,"offset":219008},"end":{"line":5712,"column":4,"offset":219228},"forced":true,"modifiers":[],"file":"main.js"},"1005":{"type":"func","id":1005,"name":"ifSet","comment":"! `, +fna=function ( opt, value[, options] )\n\n#+tag_Options\n* `@Base.ifSet()`@\n#\n\n Changes the value of one `#_opt'ion and returns `'true if it was\n different from current.\n\n= true if events were fired (value different or `[options.forceFire`]\n  set)`, false otherwise\n\n?`[\n   sqim.ifSet('key', 'foo')   //=> true (changed)\n   sqim.ifSet('key', 'foo')   //=> false (unchanged)\n   sqim.ifSet('key', 'foo', {forceFire: true})    //=> true (forced change)\n `]\n\n#ifSetSet\n Fires `#normalize_OPT giving it `'value; if the result is not `#isEqual\n to `[this._opt[opt]`] or if `[options.forceFire`] is set - changes `'_opt\n and fires `#batch'ed `#change_OPT event, then `#change.\n\n? You can take advantage of `#ifSet()'s return value to perform\n  interlocking operations saving a call to `#get():\n  `[\n   if (sqim.ifSet('eventsBound', true)) {\n     // eventsBound was previously not isEqual() and it was now changed to\n     // true so we can do what we need, once until it changes to non-true\n     // again.\n   }\n  `]\n  ...As a short form of writing:\n  `[\n   if (!sqim.get('eventsBound')) {\n     sqim.set('eventsBound', true)\n     // ...\n   }\n  `]\n\n Other notes:\n* Avoid `'forceFire because it calls not only your object's handlers\n  (which you expect) but also other instances' (which you usually don't).\n* Use `#set() which returns `'this if you don't care for the return value\n  but want method chaining.\n* Use `#getSet() if you want to update options based on other options\n  (e.g. increment a value).\n* Use `#batch() to assign related options and defer on-change behaviour.\n* There's no `'set() version that writes multiple options at once. You\n  might be looking for `#assignResp(), possibly with `'schema (useful when\n  assigning an API response): `[assignResp(opts, {schema: {}})`] -\n  equivalent to `#batch'ed bunch of `#set()-s. Generally, consider\n  `#assignResp() if you find yourself writing a series of `'set().\n* It is safe to change `#_opt from within `#normalize_OPT or `#change\n  handlers - they are written to `[this._opt`] immediately but subsequent\n  `#change_OPT and `#change events are `#batch'ed in FIFO fashion (first\n  set - first fired). This preserves \"incremental\" update order but also\n  means that `'set() is not always immediately followed by a call to these\n  handlers.\n* Because `#ifSet() creates an implicit `#batch, `#change_OPT and `#change\n  fired for `'OPT receive the same `[options.batchID`] even if you don't\n  wrap the `#ifSet() call into a `#batch().\n##getnset\n* `#get() and `#set() (`#ifSet()) may be seen as public or private API at\n  user's discretion. A complex class may opt for wrappers around these,\n  discouraging its users from direct access to options:\n  `[\n    title: function () { return this.get('title') }\n  `]\n* See also Options overview (`#opt).\n\n##\n\n? Overriding `#ifSet() is possible but most of the time `#normalize_OPT is\n  what you need:\n  `[\n   var MySetter = Sqimitive.Base.extend({\n     _opt: {\n       readOnly: 'foo',\n     },\n\n     events: {\n       // Our handler will be called before the inherited ifSet() and\n       // will prevent modification of this._opt.readOnly when they are\n       // done via set/ifSet (i.e. the recommended way).\n       //\n       // Make sure not to hook '-set' because set() calls ifSet() and it\n       // would be still possible to change 'readOnly' with\n       // ifSet('readOnly', 'bar').\n       '-ifSet': function (opt) {\n         if (opt == 'readOnly') {\n           throw new Error('You shouldn\\'t really change what is called readOnly, you know?')\n         }\n       },\n\n       // normalize_OPT would be better though:\n       normalize_readOnly: function () {\n         throw new Error('You shouldn\\'t change what is called readOnly, you know!')\n       },\n     },\n   })\n  `]\n  Hooking `#ifSet() specifically allows immediate, not `#batch'ed reaction\n  (but consider using `[priority^`] - see `#evtref). `'options will lack\n  some fields at this point though (`#_batchOptions()).\n  `[\n    '-ifSet': function (opt, value, options) {\n      console.log('Option ', opt, ' is about to change to ', value)\n    },\n  `]\n\n#optpropag\n `'options can be used to propagate custom data to the handlers of\n `#normalize_OPT(), `#change_OPT() and `#change(), and even back from them\n (`'options is always an object, possibly empty):\n[\n   Sqimitive.Base.extend({\n     change_foo: function (now, options) {\n       options.foo = 123\n     },\n   })\n\n   var options = {}\n   sqim.set('foo', options)\n   alert(options.foo)       //=> 123\n]","start":{"line":5840,"column":4,"offset":224515},"end":{"line":5875,"column":4,"offset":225953},"forced":null,"modifiers":[],"file":"main.js"},"1006":{"type":"func","id":1006,"name":"isEqual","comment":"#+tag_Utilities\n* `@Base.isEqual()`@\n#\n\n Returns `'true if both arguments are \"same enough\" and `#ifSet() should\n not change `#_opt and fire `#change_OPT.\n\n Default implementation compares arguments using strict equality operator\n (`[===`]).\n\n Remember that in JavaScript, `[NaN !== NaN`] so `[sqim.set('num', NaN)`]\n will fire `#change_OPT even if `'num is already `'NaN.\n\n? You can override `#isEqual() to use `'== if you're ready for flaky\n  behaviour (see `@no@isEqual`@()). `@un:isEqual`@() is another option.\n  `[\n    var MyBase = Sqimitive.Base.extend({\n      events: {\n        '=isEqual': function (sup, a, b) {\n          return _.isEqual(a, b)\n        },\n      },\n    })\n  `]\n\n#-normiseq","start":{"line":5903,"column":4,"offset":226814},"end":{"line":5905,"column":4,"offset":226866},"forced":null,"modifiers":[],"file":"main.js"},"1007":{"type":"func","id":1007,"name":"nest","comment":"! `, +fna=function ( [key,] sqim|opt [, options] )\n\n#+tag_Nesting\n* `@Base.nest()`@\n#\n\n Adds a new child using a shorter syntax than `#nestEx().\n\n= `'sqim `- the added child\n\n> key string`, number`, omitted `- if omitted, `#_defaultKey() is used\n  which by default returns `'sqim's `#_cid (unique instance identifier)\n> sqim object `- new child to nest\n> opt object `- in place of `'sqim, only when `#_childClass is not\n  `'Object - a plain `'{} object of `'opt'ions for `#_childClass'\n  constructor\n> options object`, null/omitted `- keys `'key and `'child are set by\n  `#nest()\n\n? `'sqim vs `'opt:\n  `[\n    var Parent = Sqimitive.Base.extend({\n      // Inherited _childClass is Sqimitive.Base.\n    })\n\n    var parent = new Parent\n    parent.nest(new Sqimitive.Base({foo: 123}))\n    // Equivalent to:\n    parent.nest(new parent._childClass({foo: 123}))\n    // Equivalent to:\n    parent.nest({foo: 123})\n\n    // Constructing with default (no) opt:\n    parent.nest(new Sqimitive.Base())\n    // Equivalent to:\n    parent.nest({})\n  `]\n\n If you are overriding the \"nesting\" behaviour you should override\n `#nestEx instead of `#nest which calls the former.\n\n#-nestExDesc","start":{"line":5949,"column":4,"offset":228293},"end":{"line":5964,"column":4,"offset":228897},"forced":null,"modifiers":[],"file":"main.js"},"1010":{"type":"func","id":1010,"name":"nestEx","comment":"#+tag_Nesting\n* `@Base.nestEx()`@\n#\n\n Adds a new child to self (`#_children), `#unnest'ing the old one at the\n same key (if any).\n\n= object `- `'options with added details about the operation\n\n The caller must set these keys in `'options:\n> child object `- a sqimitive to nest\n> key string`, number `- new `[options.child`]'s key in `#_children\n\n ` `#nestEx() mutates and returns `'options with updated keys:\n> key string always\n> previous object`, undefined\n> changed bool `- whether any changes were done to the collection\n\n Subclasses and `#mixIn-s can use other `'options keys - for example,\n `@Sqimitive\\Ordered`@ receives insertion order in `[options.pos`] and\n sets `[options.index`] on return.\n\n After the call, old `#length of self could be determined as follows:\n[\n   this.length - (options.previous && options.changed)\n]\n\n In most cases `#nest() is more convenient to use as it allows omitting\n `[options.key`] and avoiding object notation for `'options.\n\n#nestExDesc\n?`[\n   sqim.nest(new Sqimitive.Base)          // _parentKey = 'p123' (the _cid)\n   sqim.nest('key', new Sqimitive.Base)   // _parentKey = 'key'\n   // Same:\n   sqim.nestEx({key: 'key', child: new Sqimitive.Base})\n\n   sqim.unlist('key')\n     // if sqim._owning is false - removes the child under 'key' if any,\n     // else calls sqim.remove(); returns the found child or undefined\n `]\n\n? When hooking `#nestEx() to listen for changes (newly added sqimitives),\n  check `[options.changed`] to avoid triggering your update logic if\n  `'child was already nested:\n  `[\n    Sqimitive.Base.extend({\n      events: {\n        // WRONG: will re-render even if the child was already there:\n        nestEx: 'render',\n\n        // CORRECT:\n        '+nestEx': function (options) {\n          if (options.changed) { this.render() }\n        },\n\n        // CORRECT since nestEx() returns the same options object as\n        // given as its first argument:\n        nestEx: function (options) {\n          if (options.changed) { this.render() }\n        },\n      },\n    })\n\n    var child = new Sqimitive.Base\n    col.nest(child)   // calls render()\n    col.nest(child)   // doesn't call\n      // child is already under the same key (_defaultKey() returns\n      // _cid which is constant for the lifetime of an object)\n  `]\n\n Other notes:\n* There's no `'nest() version that adds multiple children at once as you\n  would do in some kind of \"sync\" operation. You might be looking for\n  `#assignChildren() (useful when assigning an API response).\n* As with other `'options-accepting methods (e.g. `#ifSet()), the\n  `'options object may be used to propagate custom data to event listeners\n  (`#optpropag); `'options are also passed through by `#assignChildren().\n\n## Internal operation\n ` `#nestEx() checks and errors if `[options.key`] is an object of any\n type (including `'null or `'undefined), or if `[options.child`] is of a\n wrong class (not `#_childClass). Then it converts and sets\n `[options.key`] to string, sets `[options.previous`] to the child\n currently occupying `'key (possibly `'undefined) and sets\n `[options.changed`] to `'false if `'previous is exactly `'child.\n\n If `[options.changed`] is `'false then exits, otherwise:\n* If `#_owning is `'true (as it is by default), every child of `'this can\n  have exactly one `#_parent thus forming a bi-directional tree (see\n  `#chld). `#nestEx() calls `#unnest() on the old and new children (which\n  call `#unnested() in turn) and updates `#_parent and `#_parentKey of the\n  new child.\n* If `#_owning is `'false, children don't know they are part of `'this.\n  `#nestEx() simply calls `#unnested() on self if there was any previous\n  child at `'key.\n\n Finally, if the child was nested (`[options.changed`] set), `#nestEx()\n `#_forward-s its `#_childEvents and, if `#_owning, calls new `'child's\n `#owned() to notify it of the parent change.\n\n Observe that `#nestEx():\n* Does nothing if `'child is already contained in this instance under the\n  same `'key, i.e. when `[options.previous == child`] (`'changed is\n  `'false).\n* `#unnest-s and nests `'child again if `'key differs.\n#nestdup\n* Always adds `'child if `'this is non-`#_owning so it may duplicate in\n  `#_children. To avoid this, hook `'=nestEx and call `'sup (`#evtpf) only\n  if `[!this.includes(options.child)`] (`#util).","start":{"line":6076,"column":4,"offset":233853},"end":{"line":6110,"column":4,"offset":235010},"forced":null,"modifiers":[],"file":"main.js"},"1011":{"type":"func","id":1011,"name":"_defaultKey","comment":"#+tag_Nesting\n* `@Base._defaultKey()`@\n#\n\n Return an automatic (implied) key for the given to-be child.\n\n= string`, number\n\n ` `#_defaultKey() is called by `#nest() and `#assignChildren() to\n generate a key for the new child (`'sqim) that is about to be nested into\n this instance. Usage within base Sqimitive allows it to have side effects\n (such as to produce sequential keys).\n\n Default `#Base's implementation returns `'sqim's `#_cid.\n\n Make sure the returned value is constant for a given child so that if\n nesting the same child with no explicit key several times it isn't\n constantly re-nested due to a different key (see `#nestEx()).\n\n Warning: if you want to index children by some \"ID\" attribute (like\n Backbone's `@bb:Collection`@ does) note that `#_parentKey `*will not`* be\n automatically updated if that ID attribute changes. You should track it\n and update the collection. For example (see `#_childEvents):\n[\n   var MyCollection = Sqimitive.Base.extend({\n     _childEvents: ['.change_id'],\n\n     events: {\n       // '.change_id' will only occur for \"models\" which _parent is this.\n       // They will be re-nested with the key expanding to\n       // this._defaultKey(sqim), basically doing nest(newID, sqim) - and\n       // since this is an _owning collection, nest() will cause sqim to\n       // be unnest()'ed and then nested with the new key.\n       '.change_id': function (sqim) { this.nest(sqim) },\n\n       // Same but shorter using a masked function reference:\n       '.change_id': 'nest.',\n\n       '=_defaultKey': function (sup, sqim) {\n         return sqim.get('id')\n       },\n     },\n   })\n]\n\n#-unordered\n If you want to not just keep some attribute synced with `#_parentKey but\n also maintain a specific order based on it - use the\n `@Sqimitive\\Ordered`@ `#mixIn.\n\n#-inBB\n In Backbone, `@bb:Model-idAttribute`@ names the property used for a\n similar purpose but in Sqimitive it's a function allowing flexible\n automatic naming.","start":{"line":6176,"column":4,"offset":237629},"end":{"line":6178,"column":4,"offset":237687},"forced":null,"modifiers":["protected"],"file":"main.js"},"1012":{"type":"func","id":1012,"name":"owned","comment":"! +fn=owned +ig\n\n#+tag_Nesting\n* `@Base.owned()`@\n#\n\n Called after `'this instance has been `#nest'ed into an `#_owning\n sqimitive (changed parents or got a first `#_parent).\n\n By the time `#owned is called `#_parent and `#_parentKey of self are\n already set to new values.\n\n See also `#unnest() that gets called before `#_parent is changed/removed.\n\n?`[\n   var MyChild = Sqimitive.Base.extend({\n     events: {\n       // Will append this.el to parent's .some-point node as soon as\n       // this instance gets a new parent. If you want to do this in\n       // production though, look for the attachPath _opt'ion of\n       // Sqimitive\\jQuery.\n       owned: function () {\n         this.attach(this._parent.$('.some-point'))\n       },\n     },\n   })\n `]\n\n Other notes:\n\n#plainstub\n* This method returns nothing.\n* It should not be called directly.\n#\n* It's defined as `#stub in `#Base which lets Sqimitive remove this\n  function instead of calling it as a handler doing nothing when a new\n  handler is registered for this event (e.g. in a subclass via `#events as\n  in the example above).","start":{"line":6180,"column":4,"offset":237695},"end":{"line":6217,"column":4,"offset":238978},"forced":true,"modifiers":[],"file":"main.js"},"1013":{"type":"func","id":1013,"name":"unlist","comment":"#+tag_Nesting\n* `@Base.unlist()`@\n#\n\n Removes a child by its key or instance from own `#_children.\n\n= object removed sqimitive`, undefined nothing found\n\n> key string or number key which to clear`, null to do nothing`,\n  object instance to remove as per `#findKey()\n\n?`[\n    collection.unlist('foo')    //=> Sqimitive or undefined\n    collection.unlist(collection.nested('foo'))   // identical to above\n    collection.unlist(child)    //=> Sqimitive (child) or undefined\n `]\n\n If `#_owning is set (as it is by default) calls `#remove(), else deletes\n the key in `#_children and calls `#unnested() on self.\n\n Does nothing if this `'key/child is not contained (returns `'undefined).\n\n See also `#unnest() which is called on the child (not on the parent\n object). However, it's only usable in `#_owning collections since there's\n no reverse child -> parent relationship in non-`#_owning mode.","start":{"line":6245,"column":4,"offset":240072},"end":{"line":6265,"column":4,"offset":240476},"forced":null,"modifiers":[],"file":"main.js"},"1014":{"type":"func","id":1014,"name":"unnest","comment":"#+tag_Nesting\n* `@Base.unnest()`@\n#\n\n Removes this instance from its `#_parent object, if any.\n\n= `'this\n\n ` `#unnest() does nothing if `#_parent of `'this is already `'null (i.e.\n not owned).\n\n Note: it normally doesn't remove own `#el from its parent node - use\n `#remove() for this.\n\n#-rmvsunn\n\n? A child reacting to its unnesting:\n  `[\n   var MyChild = Sqimitive.Base.extend({\n     events: {\n       '-unnest': function () {\n         // this._parent and _parentKey are still set if this instance\n         // was attached to any parent, otherwise they are null.\n         this._parent && alert(\"I am about to be... unnested! :'(\")\n       },\n\n       unnest: function () {\n         // At this point _parent and _parentKey are certainly null but\n         // there's no telling if they will remain so - or if this\n         // instance had any parent before unnest() was called.\n         alert('I am now as free as the wind!')\n       },\n\n       // In contrast to the above, here we can reliably determine if\n       // this sqimitive was previously nested and if it was - do\n       // something after it was unnested by calling the inherited\n       // implementation via sup.\n       '=unnest': function (sup) {\n         var hadParent = this._parent != null\n         sup(this, arguments)\n         hadParent && alert('I was abducted but you saved me!')\n         return res\n       },\n     },\n   })\n  `]\n\n Other notes:\n* `#unnest() can be called when `#_parent is already `'null; one such\n  example is `#nestEx() that unconditionally calls `#unnest() on new\n  child.\n* `#unnest() clears `#_parent and `#_parentKey and calls\n  `#unnested`[(this)`] on the former parent.\n* This effectively creates a new detached tree (if `'this has nested\n  `#_children) or a leaf (if not) - more in Children concept (`#chld).","start":{"line":6322,"column":4,"offset":242614},"end":{"line":6332,"column":4,"offset":242894},"forced":null,"modifiers":[],"file":"main.js"},"1017":{"type":"func","id":1017,"name":"unnested","comment":"#+tag_Nesting\n* `@Base.unnested()`@\n#\n\n Called right after a child (`'sqim) was detached from its parent (`'this)\n where it was listed under `'key.\n\n#unnestedoff\n ` `#Base's implementation of `#unnested() calls `'sqim.`#off(`'this) to\n unregister all event handlers that might have been previously attached to\n the removed child by this instance (provided they were not hardwired with\n `#fuse() and used `[cx === this`]).\n\n#\n\n By the time `#unnested is called, `'sqim's `#_parent and `#_parentKey are\n already `'null.\n\n Former `'key is useful for non-`#_owning collections, especially when it\n may have duplicates (same child object under different keys).\n\n?`[\n   var MyParent = Sqimitive.Base.extend({\n     events: {\n       unnested: function (sqim, key) {\n         alert('Whence thou goeth, my ' + key + '...')\n       },\n     },\n   })\n `]\n\n Other notes:\n* For `#_owning collections `#unnested() is called by `'sqim.`#unnest().\n* For non-`#_owning it's called by `'this.`#unlist() and by\n  `'this.`#nestEx() when nesting a new child under an occupied key.\n#-plainstub","start":{"line":6370,"column":4,"offset":244187},"end":{"line":6377,"column":4,"offset":244412},"forced":null,"modifiers":[],"file":"main.js"},"1018":{"type":"func","id":1018,"name":"nested","comment":"! `, +fna=function ( [key] )\n\n#+tag_Nesting\n* `@Base.nested()`@\n#\n\n Returns a single child by key or instance or all `#_children (if no\n argument).\n\n= object all children if `'key not given`, object the found child`,\n  undefined if given `'key/child isn't nested in `'this\n\n> key omitted return a shallow copy of `#_children`, string or number\n  return the object at that key (case-sensitive) or `'null`, object return\n  the argument itself if this object is nested as per `#findKey()\n\n?`[\n   sqim.nested()   //=> {childKey1: Sqimitive, ...}\n   sqim.nested('childKey1')    //=> Sqimitive by its key\n   sqim.nested('foobarbaz!')   //=> undefined - key not found in sqim._children\n\n   var child = sqim.nested('childKey1')\n   sqim.nested(child)          //=> child by its object\n   sqim.nested(new Sqimitive)  //=> undefined - object not listed in sqim._children\n `]\n\n? The object `'key form allows using `#nested() as `@no@includes`@()\n  (`#util) to check if a child is part of the collection:\n  `[\n    if (col.nested(sqim)) {\n      // ...\n    }\n  `]\n\n#parentkeyowning\n Note: key only matches the child's `#_parentKey if `'this is `#_owning,\n else it may differ.\n\n#-unordered\n Order of keys in the returned `#_children's copy may be unpredictable.\n\n#nestedslice\n ` `#nested() without arguments returns an object - children with keys.\n `#slice() returns an array - children only, dropping their keys.","start":{"line":6423,"column":4,"offset":246082},"end":{"line":6433,"column":4,"offset":246445},"forced":null,"modifiers":[],"file":"main.js"},"1019":{"type":"func","id":1019,"name":"slice","comment":"! `, +fna=function ( [start [, end]] )\n\n#+tag_Utilities\n* `@Base.slice()`@\n#\n\n Treats this instance's `#_children as an ordered array and returns a\n portion of it.\n\n `'start defaults to 0, `'end - to `#length + 1.\n\n Attention: the `'end index is not included into result. If `[start ==\n end`] then an empty array is always returned.\n\n?`[\n  slice()       // get all children; toArray() does the same\n  slice(1, 2)   // get 2nd child as an array\n  slice(-1)     // get last child as an array; last() is more convenient\n  slice(5, 8)   // get 6th and 7th children as an array; no 8th!\n  slice(0, 0)   // start == end - always an empty array\n  slice(1, -1)  // get all children except the first and last\n `]\n\n Along with `#length, `#slice() makes sqimitives look like an array and so\n `#slice()'s interface is the same as `'Array's `'slice():\n `@https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice`@\n\n#-nestedslice\n\n# Unordered objects warning\n#-unordered\n ` `#slice() may return entries in arbitrary order.\n\n It should not be used unless special measures were taken to make this\n instance properly ordered or if the caller doesn't care for child order\n (but then it should never use a positive `'start as there are no\n guarantees which child will be at that index).\n\n Use either the `#Ordered `#mixIn (and see `#at()) or override `#slice()\n to sort `#_children based on some criteria before taking a portion of it\n (this may be slower than `#Ordered that maintains sort order as children\n come and go without resorting on every call to `#slice()):\n[\n  events: {\n    '=slice': function (sup, start, end) {\n      var sorter = function (a, b) { return a.get('pos') - b.get('pos') }\n      return sup(this).sort(sorter).slice(start, end)\n      // WRONG: do not use any #util functions to avoid recursion:\n      return this.toArray()...\n    }\n  }\n]\n\n Making `#slice() \"ordered\" is enough to make the Sqimitive ordered\n because `#slice is used by all other functions that treat `#_children as\n an array (`'each(), `'find() and others, see `#util).","start":{"line":6491,"column":4,"offset":248868},"end":{"line":6498,"column":4,"offset":249208},"forced":null,"modifiers":[],"file":"main.js"},"1020":{"type":"func","id":1020,"name":"findKey","comment":"! `, +fna=function ( sqim | func [, cx] )\n\n#+tag_Nesting tag_Utilities\n* `@Base.findKey()`@\n#\n\n Returns the string key of the given child (in `#_children of self) or of\n the first child matched by the callback, or `'undefined.\n\n ` `#findKey() has two call forms:\n\n* `[function (sqim)`] - If `'sqim is part of `#_children, returns its key.\n\n* `[function (func [, cx])`] - Call `'func in the `'cx context (`'this if\n  `'null or omitted) giving it the usual iterator's set of arguments:\n  `[childObject, childKey, childrenObject`] (as in Underscore, etc.).\n  Returns `'childKey as soon as `'func returns a truthy value.\n\n  Warning: do not modify `'childrenObject as it's the `#_children itself.\n\n In any case, `#findKey() returns `'undefined if no match was found.\n\n?`[\n   col.findKey(col.first())   // get key of the first child\n   col.findKey(ch => ch.get('enabled'))   // get key of the first \"enabled\" child\n `]\n\n Other notes:\n* `#findKey() is similar to `'findIndex() `#util.\n* It returns an arbitrary key if `'this has duplicate children\n  (non-`#_owning), even if `#Ordered.\n* If `#_owning and when given a `'sqim, `#findKey() does a quick check on\n  `#_parent without iterating over children.\n\n#-parentkeyowning\n\n#-unordered\n Either `'func() should match exactly 0 or 1 children or the caller should\n not care which of the matched ones `#findKey() returns (since it may\n return a different matching child every time).","start":{"line":6540,"column":4,"offset":250879},"end":{"line":6552,"column":4,"offset":251281},"forced":null,"modifiers":[],"file":"main.js"},"1023":{"type":"func","id":1023,"name":"sort","comment":"! `, +fna=function ( func [, cx] )\n\n#+tag_Utilities\n* `@Base.sort()`@\n#\n\n Returns `#_children as an array in order specified by comparison `'func.\n\n> func function `- receives two members, must return `'-1/`'+1 if first\n  member should go before/after second or `[0`] if order doesn't matter\n  (may cause non-deterministic result)\n> cx object`, null/omitted use `'this `- the context for `'func\n\n This differs from standard `'Array's `'sort() that works in-place and\n doesn't accept `'cx.\n\n Use `'sortBy() `#util to compare based on weight values returned by\n `'func.\n\n?`[\n  nest({foo: 5})\n  nest({foo: 1})\n  sort(function (a, b) { return a.get('foo') - b.get('foo') })\n    //=> [ {foo: 1}, {foo: 5} ]\n  sortBy(function (a) { return a.get('foo') })\n    //=> same order\n `]","start":{"line":6581,"column":4,"offset":252224},"end":{"line":6583,"column":4,"offset":252310},"forced":null,"modifiers":[],"file":"main.js"},"1024":{"type":"func","id":1024,"name":"_","comment":"#+tag_Utilities\n* `@Base._()`@\n#\n\n Returns wrapped `#_children array for chaining with your utility library.\n\n Chaining is useful for transforming the value (array of children) several\n times. Call `'value() to obtain the final value. If you're only doing a\n single transformation - just call it directly on `'this since most of\n them are exposed as methods (see `#util).\n\n Note: Underscore (see `@un:chain`@()) and LoDash support chaining but\n NoDash doesn't (`@no@COMPATIBILITY`@) and `#_() will error.\n\n The reference to the utility library itself (the global `[_`] object) is\n accessible via `[Sqimitive._`].\n\n?`[\n   col._().filter(...).sort(...).value()    //=> array of children\n\n   // Same as:\n   var _ = Sqimitive._\n   _.chain(col.toArray()).filter(...).sort(...).value()\n\n   // Same as:\n   _.sort(col.filter(...), ...)\n `]","start":{"line":6612,"column":4,"offset":253312},"end":{"line":6614,"column":4,"offset":253368},"forced":null,"modifiers":[],"file":"main.js"},"1025":{"type":"func","id":1025,"name":"remove","comment":"#+tag_Nesting tag_Lifecycle\n* `@Base.remove()`@\n#\n\n Removes `#el and calls `#unnest().\n\n#baseRemove\n= object `- `'this\n\n##rmvsunn\n Use `#unnest() when an object is temporary elided from the hierarchy\n (e.g. because it's changing parents). Use `#remove() when it's completely\n destroyed and its \"view\" (DOM node, etc.) is no longer needed. By\n convention, `#remove() is also used on `#el-less objects (where it's\n identical to `#unnest() in effect) to convey the intention of destroying\n them.\n\n?`[\n   var child = new Sqimitive.Base({el: '<p>Some text.</p>'})\n   var parent = new Sqimitive.Base({el: '<article>'})\n   parent.nest(child).attach(parent.el)\n     // now we have <article><p>Some text.</p></article>\n\n   child.unnest()\n     // we still have <article><p>Some text.</p></article> even though\n     // child is no more listed under parent._children\n\n   // But if we would have done this:\n   child.remove()\n     // we would have <article></article> with the child removed from\n     // both the parent's _children list and from its the parent's el\n `]\n\n##\n\n#-elstub\n\n ` `#Base's `#remove() simply calls `#unnest().","start":{"line":6654,"column":4,"offset":254723},"end":{"line":6656,"column":4,"offset":254776},"forced":null,"modifiers":[],"file":"main.js"},"1026":{"type":"func","id":1026,"name":"assignChildren","comment":"! `, +fna=function ( resp [, options] )\n\n#+tag_Nesting\n* `@Base.assignChildren()`@\n#\n\n Unserializes children: updates own `#_children based on data of arbitrary\n format.\n\n Merges external \"response\" `'resp into `#_children by updating existing\n nested sqimitives and adding new and/or removing unlisted ones. `'resp is\n a list of data objects, one object per every child:\n[\n   resp = [ {caption: 'foo', body: 'bar'}, {caption: 'bazz'}, ... ]\n            ^^^ the first child's data ^^  ^ the second child\n]\n\n `'options keys used by this method (context for all `'...Func is `'this):\n> newFunc function returning a constructed child; receives response data\n  object (`#assignResp() is still called so it's usually unneeded)`,\n  `'null/omitted create using `#_childClass of `'this\n> eqFunc `'null/omitted if `'keepMissing then do nothing, else remove all\n  children prior to assignment`, string option name for `#get()`, function\n  `[(child, opt)`] returning `'true when the given child is the \"same\" as\n  one of `'resp data objects and should be kept and have its `#_opt\n  updated without creating a new child for that `'opt\n> keepMissing true to keep children \"not present\" in `'resp (as reported\n  by `'eqFunc) unchanged`, false to ensure all `#_children left after\n  `#assignChildren() were present in `'resp and that others were\n  `#unlist()'ed from self\n> keyFunc `'null/omitted use `#_defaultKey() of `'this (returns `#_cid by\n  default)`, function returning key (string or number); receives a\n  constructed Sqimitive (before it's `#nest'ed) and `'resp data object\n> posFunc `'null/omitted provide no explicit `'pos`, function returning\n  child's `'pos'ition in `@Ordered.nestEx`@; same arguments as `'keyFunc\n> unFunc `'null/omitted use `#unlist`, function receiving a nested child\n  plus some junk arguments; the child must become unnested when `'unFunc\n  returns (no async operation)\n\n= array `[[nested, unlisted]`] `- `'nested is an array of `#nestEx()\n  return values, `'unlisted is an object of child sqimitives (by their\n  keys in `'this) that were not found in `'resp.\n\n  Some members of `'nested may not belong to `'this. For example, if\n  several `'resp objects were given the same key, only the last's child\n  will have `#_parent of `'this.\n\n  If `[options.eqFunc`] was unset then `'unlisted is either always `'{}\n  (given a set `[options.keepMissing`]) or the copy of `#_children before\n  `#assignChildren().\n\n#assignchre\n ` `#assignChildren() \"unserializes\" own `#_children objects while\n `#assignResp() \"unserializes\" own `#_opt'ions (\"attributes\").\n\n#\n\n?`[\n   var MyList = Sqimitive.Base.extend()\n\n   var MyItem = Sqimitive.Base.extend({\n     _opt: {foo: ''},\n   })\n\n   var list = new MyList\n   var item1 = new MyItem({foo: 'existing'})\n\n   list.nest(item1)\n   var resp = [{foo: 'incoming#1'}, {foo: 'existing'}]\n   list.assignChildren(resp)\n     //=> [ [item with 'foo' of 'incoming#1', item with 'foo' of 'existing'], {item1} ]\n     // item1 was removed from list and the latter got two new children\n     // with 'foo' of 'incoming#1' and 'existing' (the latter has\n     // identical _opt with the removed item but a new object was\n     // nevertheless created and nested)\n\n   // Let's restore the list.\n   list.invoke('remove')\n   list.nest(item1)\n\n   list.assignChildren(resp, {eqFunc: function (sqim, opt) {\n     return sqim.get('foo') == opt.foo\n   }})\n     //=> [ [item with 'foo' of 'incoming#1'], {} ]\n     // Now item1 wasn't removed because the function we've passed\n     // compared its foo option with resp's foo value and returned true\n     // to indicate that existing child represents the same entity as the\n     // incoming data object. In addition to item1, list got one new item\n     // with foo of 'incoming#1'.\n\n   // We can use this short form of eqFunc if we're simply matching some\n   // option with a field by the same name in resp's objects:\n   list.assignChildren(resp, {eqFunc: 'foo'})\n `]\n\n?`[\n   list.assignChildren([], {keepMissing: true})\n     //=> [ [], {} ]\n     // nothing done as there were no items in resp\n\n   list.assignChildren([])\n     //=> [ [], {old list._children} ]\n     // the list was cleared as keepMissing defaults to false\n `]\n\n?`[\n  assignChildren([ {key: 'foo'}, {key: 'bar'} ], {eqFunc: 'key'})\n    // adds/updates 2 children with _opt = {key: 'foo'} and {key: 'bar'};\n    // \"same\" sqimitives are those having the same value for the 'key'\n    // option and data object's 'key' field\n\n  assignChildren([ {key: 'foo'}, {key: 'bar'} ],\n                 {eqFunc: function (sqim, opt) { return sqim.get('key') == opt.key }})\n    // identical to the above\n\n  assignChildren({ foosh: {key: 'foo'}, barrsh: {key: 'bar'} }, {eqFunc: 'key'})\n    // identical to the above (resp is an object, keys ignored)\n\n  assignChildren({ foosh: {key: 'foo'}, barrsh: {key: 'bar'} },\n                 {eqFunc: 'key', keepMissing: true})\n    // identical to the above but keeps old children\n\n  assignChildren([ {key: 'foo'}, {key: 'bar'} ])\n    // similar but always removes all nested sqimitives and adds 2 new\n    // ones\n\n  assignChildren(..., {onlyDefined: true, forceFire: true})\n    // passes onlyDefined to assignResp() and forceFire to set()\n `]\n\n? Normally a child is constructed with no `'opt (in `'new/`#init) and gets\n  them via a later `#assignResp(). Use `'newFunc to supply some `'opt'ions\n  early but remember that for existing children (`'eqFunc) only\n  `#assignResp() is called:\n  `[\n  var data = [{foo: 1, bar: 2}, {foo: 3, bar: 4}]\n  assignChildren(data, {\n    newFunc: resp => new ChildClass(_.pick(resp, 'foo', _.forceObject)),\n    // Optionally, if we don't want foo to be considered by assignResp():\n    schema: {foo: false},\n    // Or, if a suitable schema is declared on ChildClass:\n    schema: 'schemaProp',\n  })\n  `]\n\n# The operation\n First, `#assignChildren() determines which `'resp objects are new and\n which are \"serialized\" forms of one of the existing `#_children by\n calling `[options.eqFunc`] with combinations of `[(child, obj)`] for\n every child and data object. `'eqFunc should return `'true exactly for\n none or one such combination. If `[options.eqFunc`] is a string then it's\n assumed that children are identified by an `#_opt'ion by this name (like\n \"id\"), mapping to data objects with the same value of this property:\n[\n   var resp = [ {id: 1, caption: 'foo'}, {id: 2, caption: 'bar'} ]\n   var child = new Sqimitive.Base({id: 1, caption: 'quux'})\n   col.nest(child)\n   col.assignChildren(resp)\n     // col now has 2 children: id=1 'foo', id=2 'bar'\n     // but the first is a new object, not our child object even though\n     // it's the same entity (given the same ID) - we should preserve it\n     // since it may have event listeners set up by other objects\n\n   // But if we'd have done this:\n   col.assignChildren(resp, {eqFunc: 'id'})\n     // col would have 2 children with the same _opt values\n     // but the first would be the same child as nested in the beginning\n     // so its event listeners would be preserved, just 'caption' updated\n\n   // String eqFunc is the same as:\n   col.assignChildren(resp, {eqFunc: function (child, obj) {\n     return child.get('id') == obj.id\n   }})\n]\n\n To recap: children keys (`#_parentKey) are not used when linking\n `#_children and `'resp objects unless you code this in your\n `[options.eqFunc`].\n\n If `[options.eqFunc`] is unset then all existing children are\n `#unlist()'ed unless `[options.keepMissing`] is set - in this case they\n are preserved and for each item in `'resp a new child is nested. However,\n on duplicate keys (`[options.keyFunc`]) only the last child is kept and\n others are removed as per the usual behaviour of `#nest()\n (`#assignChildren() doesn't handle this specially and such\n \"removed-by-nesting\" children are not reflected in the returned array).\n\n Then, for data objects mapped to an existing child `#assignChildren()\n calls `#assignResp() on that child giving it the mapped data object to\n essentially update it. For unmapped, it creates a new Sqimitive by\n `[options.newFunc`], calls `#assignResp() and `#nest-s it under the key\n of `[options.keyFunc`].\n\n Finally, if `[options.keepMissing`] is unset `#assignChildren() removes\n all children which were neither updated not created during this call. If\n it's set then they are just left unchanged as `#_children of `'this.\n\n# Propagation of `'options\n##assignoprop\n ` `#assignChildren() and `#assignResp() call/fire several methods/events\n (`#evt), all of which receive the same `'options object. This allows\n changing those methods' options as well as propagating data back from\n them to the original caller (see `#optpropag).\n\n##\n\n In particular, `#assignChildren() calls `#assignResp(),\n `#set()/`#ifSet(), `#nestEx() firing `#normalize_OPT, `#change_OPT and\n `#change, as well as `#nestEx-produced events (however, for `#nestEx() a\n shallow-copy of `'options is given).\n\n[\n   sqim.assignChildren({a: 1, b: 2}, {schema: api3, forceFire: true})\n     // passes schema to assignResp() instead of _respToOpt and\n     // passes forceFire to set() to always fire change events\n]\n\n Additionally, this method sets `[options.assignChildren`] to `'true so\n you can determine when an option is being set as a result of this method\n call:\n[\n   Sqimitive.Base.extend({\n     events: {\n       change_caption: function (now, options) {\n         // Don't refresh the view when unserializing.\n         if (!options.assignChildren) { this.render() }\n       },\n     },\n   })\n\n   sqim.assignChildren([{caption: 'foo'}, ...])\n   sqim.render()    // call it once after finishing the update\n]\n\n# Format of `'resp\n `'resp is either an array of objects or an \"object of objects\" - then\n it's converted using `@no@values`@() ignoring the keys. Use `'keyFunc if\n you want to have the object's keys (or any other keys) assigned to\n children:\n[\n  var resp = {\"foo\": {opt: 123}, \"bar\": {opt: 456}}\n  // Since assignChildren() discards resp's keys, copy them to each object:\n  _.each(resp, (opt, key) => opt._key = key)\n  col.assignChildren(resp, {keyFunc: (child, opt) => opt._key})\n]\n\n   Sqimitive prior to v1.2 allowed `'resp to be an object with the `'data\n   key to integrate with Python's Flask framework but it's no longer\n   supported - see\n   `@https://flask.palletsprojects.com/en/1.1.x/security/#json-security`@.\n\n#-unordered\n ` `#assignChildren() may process `'resp and `#nest/update children in any\n order. If you need specific order then pass `'resp as an array instead of\n object.\n\n# Other notes\n* There's no `'assignChildren() version that takes ready-made objects\n  (like Backbone's `@bb:Collection-set`@()) because many questions arise:\n  do you need to keep old duplicate children or replace them with supplied\n  objects and what to do with event listeners on the old children if you\n  do replace them, or with listeners on the new if you don't; what to\n  consider \"duplicate\" (some ID attribute? exact same object?), do you\n  want to keep old options, etc. etc. Instead of making Sqimitive figure\n  or enforce them on you it just lets you implement exactly what you need.\n#assignname\n* This method is named \"assign\" to emphasize the fact that data may\n  undergo transformations before being assumed by the sqimitive.\n\n#","start":{"line":6928,"column":4,"offset":267630},"end":{"line":6979,"column":4,"offset":269540},"forced":null,"modifiers":[],"file":"main.js"},"1030":{"type":"func","id":1030,"name":"assignResp","comment":"! `, +fna=function ( resp [, options] )\n\n#+tag_Options\n* `@Base.assignResp()`@\n#\n\n Unserializes options: updates own `#_opt in `#batch based on a `'resp\n data object of arbitrary format.\n\n ` `#assignResp() calls `[options.schema`]'s empty key and then `#set()-s\n own `#_opt based on transformation rules (`[options.schema`]) for the\n external input `'resp (e.g. an API response) - all of this in a`#batch().\n `'resp is an object where one member usually represents one option (but\n this is not a requirement).\n\n `'options keys used by this method:\n> schema null/omitted to use `#_respToOpt`, object in `#_respToOpt format\n  including empty `[{}`]`, string own property name\n> onlyDefined null/omitted to call `#set(key) for every key in `'resp not\n  listed in `'schema`, true to ignore such keys\n\n= array of changed option names (as reported by `#ifSet() called by\n  `#assignResp(), not by `'schema's functions; doesn't list `[.props`])\n\n#-assignchre\n\n? In the simplest case when `#_respToOpt is not overridden (i.e. is\n  `[{}`]) and `'onlyDefined is unset `#assignResp() acts as a\n  \"multi-`#set()\":\n  `[\n  sqim.assignResp({date: '2000-01-01', id_key: '123'})\n    // without _respToOpt, schema and onlyDefined is equivalent to:\n    // sqim.set('date', '2000-01-01').set('id_key', '123')\n\n  // Works the same regardless of sqim's _respToOpt - useful as mass-set().\n  sqim.assignResp({date: '2000-01-01', id_key: '123'}, {schema: {}})\n  `]\n\n#assignrespvs\n? Using `#assignResp() in conjunction with `#_respToOpt to \"blend\" into\n  this object a typical JSON response from a backend:\n  `[\n   var MyModel = Sqimitive.Base.extend({\n     _opt: {\n       date: new Date(0),\n       id_key: 0,\n     },\n\n     _respToOpt: {\n       // Create a Date object from the incoming value:\n       date: function (value, key) {\n         return [key, new Date(value)]\n       },\n\n       // Pass the value through to _opt as is.\n       id_key: true,\n     },\n\n     events: {\n       change_id_key: 'render',\n\n       '=normalize_id_key': function (sup, value) {\n         value = parseInt(value)\n         if (isNaN(value)) { throw new Error('What kind of ID is that?') }\n         return value\n       },\n     },\n   })\n\n   var sqim = new MyModel\n\n   // Since it's using regular set() to assign new values all the usual\n   // normalize/change events are fired. In particular, MyModel's\n   // normalize_id_key and then change_id_key are called. As a result\n   // _opt setting happens exactly the same as if it was done with the\n   // usual set() from the outside.\n   sqim.assignResp({date: '2000-01-01', id_key: '123', bazzz: 'Ouch!'})\n\n   // Now sqim.get() is {date: new Date('2000-01-01'), id_key: 123, bazzz: 'Ouch!'}.\n   // date was turned into a Date object thanks to the transformation\n   // function in _respToOpt.\n   // id_key was turned into a number thanks to normalize_id_key.\n   // bazzz was assigned too because we didn't pass {onlyDefined: true}.\n  `]\n\n? If you have several API routes with different formats but logically the\n  same data (so they unserialize to the same object), pass\n  `[options.schema`] without changing `#_respToOpt on run-time:\n  `[\n    sqim.assignResp(apiResp1, {schema: {id: 'id_key'}})\n      // set('id_key', apiResp1.id) and set other keys as is\n\n    var schema = _.extend({extra: s => ['info', JSON.parse(s)]}, sqim._respToOpt)\n    sqim.assignResp(apiResp2, {schema})\n      // set('extra', JSON.parse(apiResp2.info)) and\n      // handle other keys according to sqim._respToOpt\n  `]\n\n  If storing schema(s) within the object itself, set `[options.schema`] to\n  the property name:\n  `[\n    var MyModel = Sqimitive.Base.extend({\n      apiSchema: {foo: 'bar'}\n    })\n    var obj = new MyModel\n    obj.assignResp(apiResp, {schema: 'apiSchema'})\n    // Equivalent to:\n    obj.assignResp(apiResp, {schema: obj.apiSchema})\n  `]\n\n  `'schema is not meant for changing `'resp's shape, e.g. from array\n  `[[['opt', 'name'], ...]`] to object `[{opt: 'name', ...}`] - declare a\n  specialized public method instead of making your consumers pass `'schema\n  or know how to treat the data:\n  `[\n    assignBillingResponse: function (resp) {\n      this.assignResp(_.object(resp), {\n        schema: this._billingRespToOpt,\n        onlyDefined: true,\n      })\n    }\n  `]\n\n Having `[options.onlyDefined`] unset is similar to having all keys in\n `'resp missing from `#_respToOpt listed there with the value of `'true:\n[\n   Sqimitive.Base.extend({\n     _respToOpt: {a: false, b: true},\n   })\n\n   sqim.assignResp({a: 1, b: 2, c: 3}, {onlyDefined: true})\n     // _opt is {b: 2}\n\n   sqim.assignResp({a: 1, b: 2, c: 3})\n     // _opt is {b: 2, c: 3}\n     // as if _respToOpt had also {c: true}\n]\n\n? Some `#Base methods internally call `#assignResp() with `'schema. If\n  overriding this method, don't change `'options for such calls. For\n  example, to force skipping `'resp keys not defined in `#_respToOpt\n  (handy if this method is used directly by API consumers, i.e. there's no\n  specialized \"`'unserialize()\"):\n  `[\n    var MySqimitive = Sqimitive.Base.extend({\n      events: {\n        '=assignResp': function (sup, resp, options) {\n          if (!options || !options.schema) {\n            options = _.extend({}, options, {onlyDefined: true})\n          }\n          return sup(this, [resp, options])\n        },\n      },\n    })\n  `]\n\n# Propagation of `'options\n#-assignoprop\n\n In particular, `#assignResp() calls `#set()/`#ifSet() firing\n `#normalize_OPT, `#change_OPT and `#change.\n[\n   sqim.assignResp({a: 1, b: 2}, {forceFire: true})\n     // passes forceFire to set() causing change events of a and/or b\n     // to fire even if they had the same values before assignResp()\n]\n\n Additionally, this method sets `[options.assignResp`] to `'true so you\n can determine when an option is being set as a result of this method call\n (see `#assignoprop for an example). If called by `#assignChildren(),\n `'options has both `'assignChildren and `'assignResp set.\n\n# `'normalize/`'change vs `#_respToOpt\n You may notice that `'=normalize_id_key and `'_respToOpt's `'date in\n example `#assignrespvs fulfill a similar purpose. That example could have\n been written like this:\n[\n  var MyModel = Sqimitive.Base.extend({\n    _respToOpt: {\n      date: function (value, key) {\n        return [key, new Date(value)]\n      },\n\n      id_key: function (value, key) {\n        value = parseInt(value)\n        if (isNaN(value)) { throw new Error('What kind of ID is that?') }\n        return [key, value]\n      },\n    },\n\n    events: {\n      change_id_key: 'render',\n      // No '=normalize_id_key', moved to _respToOpt.\n    },\n  })\n]\n Or like this:\n[\n  var MyModel = Sqimitive.Base.extend({\n    _respToOpt: {\n      // No date, became normalize_date.\n    },\n\n    events: {\n      change_id_key: 'render',\n\n      '=normalize_date': function (sup, value) {\n        return new Date(value)\n      },\n\n      '=normalize_id_key': function (sup, value) {\n        value = parseInt(value)\n        if (isNaN(value)) { throw new Error('What kind of ID is that?') }\n        return value\n      },\n    },\n  })\n]\n\n Indeed, `#normalize_OPT and others are fired by `#ifSet() and they occur\n during `#assignResp() because the latter is calling `#set() internally.\n However, `#_respToOpt is only used by `#assignResp() so both of the above\n examples have issues:\n* If there is no `'=normalize_id_key then `#assignResp() works as expected\n  while `[set('id_key', 'zabzab')`] doesn't trigger an error.\n* If there are no `'_respToOpt rules then `#assignResp() again works as\n  expected but `[set('date', new Date)`] results in `[_opt.date`] becoming\n  `[new Date(new Date)`].\n\n Additionally, `#assignResp() allows different \"unserialization profiles\"\n by passing rules in `[options.schema`] rather than defining them in\n `#_respToOpt.\n\n#-unordered\n ` `#assignResp() may process `'resp and call `#set() in any order.\n\n# Other notes\n#-assignname","start":{"line":7219,"column":4,"offset":278850},"end":{"line":7255,"column":4,"offset":279973},"forced":null,"modifiers":[],"file":"main.js"},"1031":{"type":"func","id":1031,"name":"bubble","comment":"#+tag_Events\n* `@Base.bubble()`@\n#\n\n Calls the method `'func with arguments `'args on every `#_parent\n (recursively, if any) and optionally `'onSelf.\n\n#bubsin\n= this\n\n If `'onSelf is `'true then first calls `'func on `'this, if defined.\n\n ` `#bubble() proceeds upstream while `#sink() descends downstream.\n However, the first walks only `#_owning sqimitives (since it's using\n `#_parent) while the second works for non-`#_owning too (since it's using\n `#_children).\n\n You can \"recursively\" fire events as well since events typically create\n methods (`#evt; see `'_wrapHandler()'s source code for details).\n\n#\n\n ` `#bubble() is very much like DOM's event bubbling except that it\n happens on sqimitives, not on their `#el's.\n\n While it should not be abused because it makes the execution flow less\n obvious (much like `'goto or `'longjmp()), it's indispensible for\n propagating generic signals like errors and logs to whoever is on top.\n\n?`[\n   // Causes self and all parent sqimitives to be rendered:\n   sqim.bubble('render', [], true)\n\n   // Recursively calls invoke('render') on all parents which results\n   // in them calling attach() on children (given the default behaviour\n   // of attach()):\n   sqim.bubble('invoke', ['attach'])\n\n   // We can use it to obtain data from \"some\" (unspecified) _owning\n   // object:\n   var out = {}\n   sqim.bubble('giveMeData', [out])\n   alert(out.data)\n   // The above will work if any parent has a handler like this:\n   parent.on('giveMeData', function (out) { out.data = 'here goes' })\n `]","start":{"line":7303,"column":4,"offset":281786},"end":{"line":7307,"column":4,"offset":281967},"forced":null,"modifiers":[],"file":"main.js"},"1032":{"type":"func","id":1032,"name":"sink","comment":"#+tag_Events\n* `@Base.sink()`@\n#\n\n Calls the method `'func with arguments `'args on all nested `#_children\n (recursively) and optionally `'onSelf.\n\n#-bubsin\n\n Note that it might get quite intense with heavy nesting.\n\n?`[\n   // Recursively causes all nested views and self to be rendered:\n   sqim.sink('render', []. true)\n\n   // Recursively calls remove() on self, all children and their\n   // children, removing every single sqimitive from its parent (useful\n   // when removing a parent el doesn't automatically free resources of\n   // its children like it does in DOM):\n   sqim.sink('invoke', ['remove'], true)\n\n   // We can use it to serialize the entire tree:\n   var serialized = []\n   sqim.sink('saveTo', [serialized])\n   localStorage.setItem('saved', JSON.stringify(serialized))\n   // Now if children implement something like this then serialized will\n   // contain a portable representation of the current hierarchy (without\n   // self):\n   child.on('saveTo', function (ser) { ser.push(this.get()) })\n `]","start":{"line":7339,"column":4,"offset":283167},"end":{"line":7343,"column":4,"offset":283330},"forced":null,"modifiers":[],"file":"main.js"},"1033":{"type":"class","id":1033,"name":"Sqimitive.Ordered","comment":"! +cl=Sqimitive.Ordered\n\n A `#mixIn that transparently makes Sqimitive reliably ordered.\n\n* Provide explicit child positions via new `#nestEx() `'pos option.\n* Listen for `#_repos() to react to children changing positions.\n* Override `#_sorter() to maintain a custom sort order.\n\n?`[\n  obj.mixIn(Sqimitive.Ordered)    // add to an instance (must be empty!)\n  Class.mixIn(Sqimitive.Ordered)  // or add to a class\n\n  // Or add to a class when declaring it:\n  var Class = Sqimitive.Base.extend({\n    mixIns: [Sqimitive.Ordered],\n    // ...\n  })\n `]\n\n JavaScript objects are unordered, even if it appears to work the way you\n expect (it's very browser-specific). For example: `[Object.keys({9: 0, 1:\n 0})`] returns `[[1, 9]`]. Since `@Sqimitive\\Base`@ stores children in an\n object (`#_children), sqimitives are unordered by default; this affects\n `#nested(), `'toArray() (`#util) and many other functions.\n\n ` `#Ordered maintains order of children without disrupting the standard API\n but makes nesting and unnesting on such sqimitives slower (access time is\n unaffected).\n\n ` `#Ordered supports any `#_owning mode (but `#_owning works faster). Like\n with `#Base, duplicate children may appear if `#_owning is unset - to\n disallow this wrap `'=nestEx in a check with `'includes() (see `#nestdup).","start":{"line":7354,"column":2,"offset":283718},"end":{"line":7979,"column":2,"offset":309747},"forced":true,"modifiers":[],"file":"main.js"},"1034":{"type":"var","id":1034,"name":"_ordered","comment":" Holds positional information about objects contained within this\n instance.\n\n= array of object `- keys:\n  `> child object `- a Sqimitive in `#_children\n  `> key string `- `'child's key in `#_children\n  `> pos any `- the value from `#nestEx's `[options.pos`]\n\n ` `#_ordered is a properly sorted array of `#_children, in order\n determined by `#_sorter(). It's kept in sync with `#_children\n automatically.\n\n The format of `#_ordered objects conveniently matches the format of\n object accepted by `#nestEx():\n[\n   // Assuming both collections are Ordered and _owning, this removes\n   // the first child from col1 and inserts it in col2, preserving\n   // the same position and key:\n   col2.nestEx(col1.at(0))\n]\n\n You're advised against accessing `#_ordered at all. Instead, use `#at().","start":{"line":7409,"column":4,"offset":286081},"end":null,"forced":null,"modifiers":["protected"],"file":"main.js"},"1036":{"type":"func","id":1036,"name":"nestEx","comment":"! +fn=nestEx:options +ig\n `#Ordered extends the inherited `'nestEx (typically `@Base.nestEx()`@)\n and handles new `'options keys:\n> pos any, optional `- the caller may explicitly specify new child's\n  position relative to other children; `'pos may be used by `#_sorter()\n  (in the default implementation it is)\n> repos bool, optional `- if set, acts as if `'pos was changed and\n  re-calculates the child's index\n> index number `- set on return to the actual position of the new child\n  in `#_ordered; `'index can be given to `#at()\n> oldIndex number `- only set on return if `[options.changed`] is unset\n\n If re-nesting the same child on the same key, `@Base.nestEx()`@ does\n nothing but `#Ordered's `#nestEx compares old and new `[options.pos`].\n If they are not `#isEqual() or if `'repos is set, it updates the\n child's position in `#_ordered and calls `#_repos() if it's different.\n This doesn't affect `[options.changed`], it remains `'false even on\n `#_repos() but you can detect this situation by comparing `'index with\n `'oldIndex:\n[\n   col.nestEx({child: sqim, pos: -123})   // new child, explicit pos\n     //=> {..., changed: true, previous: null, index: 0}\n   col.nestEx({child: sqim, pos: 9000})   // existing child, changed pos\n     //=> {..., changed: false, previous: sqim, index: 3, oldIndex: 0}\n]\n? `'repos is typically used when `#_sorter's order depends on something\n  other than `'key and `'pos - changes to these can be only done via\n  `#nestEx() and are therefore handled automatically. Adapted code\n  snippet from the sample To-Do application:\n  `[\n     App.Tasks = App.Base.extend({\n       _childEvents: ['change'],\n       events: {\n         '.change': function (sqim, option) {\n           option == 'caption' && this.nest(sqim, {repos: true})\n         },\n         // Overridden _sorter:\n         '=_sorter': function (sup, a, b, posB) {\n           var posA = a.pos == null ? a.child.get('caption') : a.pos\n           // ...\n         },\n       },\n     })\n  `]\n  Compare with \"external\" approach based on `'pos alone:\n  `[\n     App.Tasks = App.Base.extend({\n       _childEvents: ['change'],\n       events: {\n         '.change': function (sqim, option, now) {\n           option == 'caption' && this.nest(sqim, {pos: now})\n         },\n         // Default _sorter is good.\n       },\n     })\n  `]\n  Note: you must provide the child's current key (or have (default)\n  `#_defaultKey() do that as in these examples) to only update the order\n  without re-nesting the child. See `#poskey for details.","start":{"line":7412,"column":6,"offset":286116},"end":{"line":7470,"column":6,"offset":289036},"forced":true,"modifiers":[],"file":"main.js"},"1038":{"type":"func","id":1038,"name":"_sorter","comment":" The comparison function for determining desired child order.\n\n= < 0 if `'a must go before `'b`, > 0 if it must go after`, 0 if they can\n  go in any order; it's generally recommended to avoid 0 to ensure that\n  re-sorting the same array doesn't result in a different order of members\n\n You want to override `#_sorter() if you are not happy with the default\n implementation. If you do, see `#indexFor() for the invocation format.\n Default implementation compares using `'pos (if given to `#nestEx()) or\n `'key (if nesting using `#_defaultKey() then keys are `#_cid-s).\n\n? Adapted code snippet from the sample To-Do application that is using the\n  value of the `'order option of a given child if no explicit `'pos was\n  provided for it when nesting:\n  `[\n     '=_sorter': function (sup, a, b, posB) {\n       var posA = a.pos == null ? a.child.get('order') : a.pos\n       return arguments.length == 2 ? posA\n         : (posA > posB ? +1 : (posA < posB ? -1\n             // If properties match - sort stably by unique and constant _cid-s.\n             : (a.child._cid - b.child._cid)))\n     },\n  `]\n\n `'a and `'b are objects in the `#_ordered format. `'b is `'null on the\n first iteration (see `#indexFor()). This object's state is inconsistent\n when `#_sorter() is called so avoid accessing data outside of the given\n arguments:\n* During `#nestEx() one of `'a/`'b may be missing from `#_ordered but\n  present in `#_children.\n* During `#resort() order of `#_ordered members is unspecified.\n\n Note: if consumers of this object are using `'pos, make sure either they\n supply correct types or you normalize them in `#_sorter: number `[10`]\n is > `[2`] but string `['10'`] is < `['2'`]. Children keys are always\n cast to strings, such as here: `[nestEx({key: 10})`].","start":{"line":7611,"column":4,"offset":295669},"end":{"line":7616,"column":4,"offset":295898},"forced":null,"modifiers":["protected"],"file":"main.js"},"1040":{"type":"func","id":1040,"name":"resort","comment":" Re-sorts the entire collection from scratch.\n\n= this\n\n Call `#resort() if an option that affects the sort order (`#_sorter) was\n changed or if sorting was temporary disabled.\n\n Calls `#_repos() on every member after sorting `#_ordered.\n\n?`[\n   Sqimitive.Base.extend({\n     mixIns: [Sqimitive.Ordered],\n     _opt: {invert: false},\n\n     events: {\n       '=_sorter': function (sup) {\n         var res = sup(this, arguments)\n         // Invert sort order based on the option's value:\n         return this.get('invert') ? -res : res\n       },\n\n       change_invert: 'resort-',\n     },\n   })\n `]\n\n? Temporary disabling automatic sorting is useful during mass-assignment\n  (`#assignChildren()):\n  `[\n     var hook = this.on('=_indexFor', Sqimitive.Core.stub)\n     try {\n       this.assignChildren(data)\n     } finally {\n       this.off(hook)\n       this.resort()\n     }\n  `]","start":{"line":7655,"column":4,"offset":296998},"end":{"line":7663,"column":4,"offset":297308},"forced":null,"modifiers":[],"file":"main.js"},"1041":{"type":"func","id":1041,"name":"_repos","comment":"! +fn=_repos:child:index +ig\n Called when a child's position has changed or was assumed for the first\n time.\n\n> sqim object `- the child that has changed position\n> index int `- `'sqim's current (new) index in `'this; can be given to\n  `#at()\n\n Typically, you'd listen to/override this method to keep positions of\n children on screen (in their parent's `@Base.el`@) in sync with their\n \"logical\" order (in `'this).\n\n? Adapted code snippet from the sample To-Do application:\n  `[\n     _repos: function (child, index) {\n       index >= this.length - 1\n         ? child.el.appendTo(this.el)\n         : child.el.insertBefore(this.el.children()[index])\n     },\n  `]\n\n ` `#_repos() is called for newly `#nest'ed `#_children and those that\n have changed `'pos. It's not called for removed children. The default\n implementation in `#Ordered does nothing.\n\n ` `#_repos() is called before `#nestEx returns. An example when this\n matters:\n[\n    // models holds data, views - its representations. Both are Ordered.\n    models.on({\n      '+nestEx': function (res) {         // (1)\n        views.nest(res.key, new View(...))\n      },\n      _repos: function (child, index) {   // (2)\n        var key = child._parentKey\n        views.nest(key, views.nested(key), {pos: index})\n      },\n    })\n\n    models.nest(new Model(...))\n    // 1. models.nestEx inherited from Base runs\n    // 2. models.nestEx (_nested) inherited from Ordered runs\n    // 3. ...which fires models._repos\n    // 4. (2) runs first - views.nested() returns null leading to error\n    // 5. (1) would run once all _repos listeners including (2) were called\n]\n This can be properly rewritten as follows:\n[\n    models.on({\n      '+nestEx': function (res) {\n        views.nest(res.key, new View(...), {pos: res.index})\n      },\n      _repos: function (child, index) {\n        var view = views.nested(child._parentKey)\n        view && views.nest(child._parentKey, view, {pos: index})\n      },\n    })\n]\n\n ` `#resort() calls `#_repos() for all children (even if some didn't\n change positions - this is hard to determine). Here, note `'Array's\n `'forEach() implications: going in ascending order from child #0 to last,\n and if `#_repos() mutates children then `#_repos() is not called for some\n of them (so don't mutate).\n\n#-plainstub","start":{"line":7665,"column":4,"offset":297316},"end":{"line":7730,"column":4,"offset":299973},"forced":true,"modifiers":["protected"],"file":"main.js"},"1042":{"type":"func","id":1042,"name":"at","comment":"#+tag_Utilities\n* `@Ordered.at()`@\n#\n\n Returns detailed info about a child by its index in this collection.\n\n= undefined`, object entry in the format of `#_ordered\n\n With `#at() you can obtain a child's key or `'pos. Use it from `#util\n functions like `'each() which provide you with an index in `#_ordered (or\n in the result of `#slice()).\n\n Warning: `#at() returns the object from `#_ordered verbatim - do not\n change it, or shallow-copy before you do.\n\n Unlike `#slice(), `#at() does not accept negative `'index.\n\n?`[\n   sqim.at(0)        //=> {child: Sqimitive, key: 'foo', pos: 3}\n   sqim.at(999)      //=> undefined (if length <= 999)\n   sqim.at(-1)       //=> always undefined\n\n   this.groupBy(function (sqim, i) { return this.at(i).pos })\n     //=> {pos1value: [child, ...], value2: [child, ...]}\n\n   // If clone is a non-_owning Ordered collection, populate it from orig:\n   orig.each(function (child, i) {\n     clone.nestEx(orig.at(i))\n   })\n\n   // Using nest() is possible but will discard pos and keys of children:\n   orig.each(function (child) {\n     clone.nest(child)\n   })\n `]\n\n#poskey\n One common pitfall when updating `'pos is passing a different key to\n `#nest() or `#nestEx(). In particular, omitting `'key of `#nest() means\n \"take `#_defaultKey() value\", not \"take current `'child's `#_parentKey\".\n[\n  var Collection = Sqimitive.Base.extend({\n    _owning: false,\n  })\n  col = new Collection\n  col.nest('x', sqim1, {pos: 1})\n  col.nest('y', sqim2, {pos: 2})\n  col.nest(/*_defaultKey => sqim1._cid, */ sqim1, {pos: 3})\n    // col now has 3 members: {1: sqim1, 2: sqim2, 3: sqim1}\n  col.nest('x', sqim1, {pos: 4})\n    // changed pos of the first member: {2: sqim2, 3: sqim1, 4: sqim1}\n]","start":{"line":7785,"column":4,"offset":302031},"end":{"line":7787,"column":4,"offset":302092},"forced":null,"modifiers":[],"file":"main.js"},"1043":{"type":"func","id":1043,"name":"shift","comment":"#+tag_Utilities\n* `@Ordered.shift()`@\n#\n\n Removes the first child and returns it.\n\n#posh\n= object former child`, undefined if empty\n\n ` `#shift() and `#pop() allow treating an `#Ordered sqimitive as a queue\n (FIFO/LIFO). Use `#nest() with a counter to push/unshift.\n?`[\n    sqim.counter = 0\n    sqim.nest(new C1, {pos:  sqim.counter++})   // push\n    sqim.nest(new C2, {pos: -sqim.counter++})   // unshift\n    sqim.last()                                 //=> C1\n    sqim.first()                                //=> C2\n    sqim.pop()                                  //=> C1\n    sqim.shift()                                //=> C2\n    sqim.pop()                                  //=> undefined\n    sqim.shift()                                //=> undefined\n `]","start":{"line":7811,"column":4,"offset":302992},"end":{"line":7814,"column":4,"offset":303097},"forced":null,"modifiers":[],"file":"main.js"},"1044":{"type":"func","id":1044,"name":"pop","comment":"#+tag_Utilities\n* `@Ordered.pop()`@\n#\n\n Removes the last child and returns it.\n\n#-posh","start":{"line":7823,"column":4,"offset":303234},"end":{"line":7826,"column":4,"offset":303342},"forced":null,"modifiers":[],"file":"main.js"},"1045":{"type":"func","id":1045,"name":"reverse","comment":"#+tag_Utilities\n* `@Ordered.reverse()`@\n#\n\n Returns `#_children in reverse order.\n\n This differs from standard `'Array's `'reverse() that works in-place.","start":{"line":7835,"column":4,"offset":303546},"end":{"line":7839,"column":4,"offset":303685},"forced":null,"modifiers":[],"file":"main.js"},"1047":{"type":"func","id":1047,"name":"indexFor","comment":"#+tag_Utilities\n* `@Ordered::indexFor()`@\n#\n\n Determines insertion position for a new member `'value in a sorted\n `'array using binary search.\n\n ` `#indexFor() is an adaptation of Underscore's `@un:sortedIndex`@().\n It supports two sort callback styles: relative (`[(a, b)`], as for\n `'Array's `'sort()) and weight-based (`[(a)`], as for `@no@sortBy`@()).\n\n First time `'func is called it's given only 1 argument (`'value) and\n expected to return `'value's weight (which is stored for later calls),\n then it's called repeatedly to compare `'value against other members\n (returning < 0 if `'b must go before `'a, > 0 if after, == 0 if their\n sort order is the same and either can go in front of another).\n\n In `#Ordered, `#indexFor() is used to maintain the order of children\n (in `#_ordered) using `#_sorter() for `'func. Usually there's no need\n to call `#indexFor() directly.\n\n `'cx is `'func's context (required).\n\n `'oldIndex is `'value's current position in `'array. This allows\n checking if re-positioning is needed once `'value weight has possibly\n changed without pulling it out, as long as other members remain sorted.\n `'func with 3 arguments is never called for `'oldIndex.\n\n? Relative `'func ignores the first call, otherwise is the same as with\n  standard `'sort():\n  `[\n   Sqimitive.Ordered.indexFor(a, v, function (a, b) {\n     return a > b ? +1 : (a < b ? -1 : 0)\n     // This would fail without a check because b may be null:\n     return b && (a.prop - b.prop)\n   })\n  `]\n\n  Weight-based `'func uses all 3 arguments:\n  `[\n   Sqimitive.Ordered.indexFor(a, v, function (a, b, posB) {\n     var posA = a.someWeightProp    // assuming it's a number\n     return arguments.length == 1 ? posA : (posA - posB)\n   })\n  `]\n\n? `#indexFor() is generic and doesn't have to be used for sorting. For\n  example, given a slow `'pathfind() function, a long `'path (where\n  members are `[{x, y}`] objects in order: first - the closest possible\n  step, last - the goal) and the task of determining the farthest\n  reachable `'path item:\n  `[\n    // path = [ {x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}, ... ]\n\n    for (var i = 0; i < path.length; i++) {\n      if (!pathfind(path[i].x, path[i].y, maxCost)) { break }\n    }\n      // path[i - 1] = last reachable item\n  `]\n  The above code works but does up to `[path.length`] calls to\n  `'pathfind() whereas this approach with `#indexFor() will do less\n  calls on average:\n  `[\n   var i = indexFor(_.range(path.length), null, function (a) {\n     if (arguments.length > 1) {\n       return pathfind(path[a].x, path[a].y, maxCost) ? -1 : +1\n     }\n   })\n  `]\n\n? If `'oldIndex is given then result of `[oldIndex`] or `[oldIndex + 1`]\n  indicates that `'value is already in the correct position. Result of\n  `[oldIndex + 2`] and greater indicates that it should be moved after\n  its current position, which usually means `'value is `'splice()'d from\n  `'oldIndex and then `'splice()'d to `[result - 1`].\n  `[\n    indexFor([1, 3, 5], 2, (a, b) => a - b)            //=> 1\n    indexFor([1, 3, 5], 3, (a, b) => a - b, null, 1)   //=> 1 or 2\n    indexFor([1, 7, 5], 7, (a, b) => a - b, null, 1)   //=> 3\n  `]","start":{"line":7924,"column":6,"offset":307509},"end":{"line":7937,"column":6,"offset":308165},"forced":null,"modifiers":["static"],"file":"main.js"}},"parents":{"801":794,"802":794,"803":794,"804":794,"805":794,"806":794,"807":794,"808":794,"809":794,"810":794,"811":794,"812":794,"813":794,"814":794,"815":794,"816":795,"817":797,"818":797,"819":797,"820":797,"821":797,"877":839,"878":847,"825":824,"828":824,"834":824,"839":824,"840":824,"841":824,"842":824,"843":824,"844":824,"845":824,"846":824,"847":824,"848":824,"849":824,"850":824,"851":824,"853":852,"854":852,"855":852,"856":852,"860":852,"861":852,"871":852,"873":852,"876":852,"902":882,"884":882,"885":882,"886":882,"887":882,"888":882,"889":882,"890":882,"891":882,"896":882,"897":882,"898":882,"1048":914,"1049":916,"1050":925,"1051":925,"1052":926,"1053":947,"1054":947,"1055":947,"1056":948,"1057":948,"1058":952,"1059":952,"1060":952,"1061":952,"1062":959,"1063":972,"1064":972,"1065":979,"1066":983,"1067":984,"1068":985,"1069":988,"1070":989,"1071":992,"1072":996,"1073":996,"1074":998,"1075":1002,"1076":1002,"1077":1003,"1078":1003,"1079":1005,"1080":1005,"1081":1005,"1082":1010,"1083":1010,"1084":1012,"1085":1017,"1086":1018,"1087":1018,"1088":1025,"1089":1025,"1090":1026,"1091":1026,"1092":1026,"1093":1030,"1094":1031,"1095":1042,"1096":1043,"907":906,"908":906,"910":909,"911":909,"914":909,"915":909,"916":909,"917":909,"918":909,"920":909,"921":909,"922":909,"923":909,"924":909,"925":909,"926":909,"927":909,"933":909,"940":909,"942":909,"943":909,"944":909,"945":909,"946":909,"947":909,"948":909,"949":909,"952":909,"953":909,"955":909,"959":909,"962":909,"965":909,"966":909,"972":909,"978":977,"979":977,"980":977,"981":977,"982":977,"983":977,"984":977,"985":977,"986":977,"988":977,"989":977,"990":977,"991":977,"992":977,"995":977,"996":977,"997":977,"998":977,"1000":977,"1001":977,"1002":977,"1003":977,"1004":977,"1005":977,"1006":977,"1007":977,"1010":977,"1011":977,"1012":977,"1013":977,"1014":977,"1017":977,"1018":977,"1019":977,"1020":977,"1023":977,"1024":977,"1025":977,"1026":977,"1030":977,"1031":977,"1032":977,"1034":1033,"1036":1033,"1038":1033,"1040":1033,"1041":1033,"1042":1033,"1043":1033,"1044":1033,"1045":1033,"1047":1033}}